<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx 学习笔记</title>
      <link href="/9-nginx-xue-xi-bi-ji.html"/>
      <url>/9-nginx-xue-xi-bi-ji.html</url>
      
        <content type="html"><![CDATA[<h4 id="Nginx-学习笔记"><a href="#Nginx-学习笔记" class="headerlink" title="Nginx 学习笔记"></a><strong>Nginx 学习笔记</strong></h4><p>总结<br>1 、 Nginx 简介<br>（ 1 ） 什么是Nginx 和可以做什么事情<br>（ 2 ） 正向代理<br>（ 3 ） 反向代理<br>（ 4 ） 动静分离</p><p>2 、 在Linux中安装nginx</p><p>3 、 Nginx的常用命令和配置文件</p><p>4 、 Nginx配置实例 1 反向代理</p><p>5 、 Nginx配置实例 2 负载均衡</p><p>6 、 Nginx配置实例 3 动静分离</p><p>7 、 Nginx的高可用集群<br>（ 1 ） nginx配置主从模式<br>（ 2 ） nginx配置双主模式</p><h1 id="Nginx-的简介"><a href="#Nginx-的简介" class="headerlink" title="Nginx 的简介"></a>Nginx 的简介</h1><h5 id="1-、什么是nginx"><a href="#1-、什么是nginx" class="headerlink" title="1 、什么是nginx"></a>1 、什么是nginx</h5><p>Nginx是高性能的HTTP和反向代理的服务器，处理高并发能力是十分强大的，能经受高负<br>载的考验,有报告表明能支持高达 50,000个并发连接数。</p><h5 id="2-、正向代理"><a href="#2-、正向代理" class="headerlink" title="2 、正向代理"></a>2 、正向代理</h5><p>（ 1 ）需要在客户端配置代理服务器进行指定网站访问，隐藏了客户端的IP地址</p><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109110252280.png" alt="image-20210109110252280"></p><h5 id="3-、反向代理"><a href="#3-、反向代理" class="headerlink" title="3 、反向代理"></a>3 、反向代理</h5><p>服务器配置代理服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109110233040.png" alt="image-20210109110233040"></p><h5 id="4-、负载均衡"><a href="#4-、负载均衡" class="headerlink" title="4 、负载均衡"></a>4 、负载均衡</h5><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡</p><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109111630765.png" alt="image-20210109111630765"></p><h5 id="5-、动静分离"><a href="#5-、动静分离" class="headerlink" title="5 、动静分离"></a>5 、动静分离</h5><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速<br>度。降低原来单个服务器的压力。</p><blockquote><p>不需要跟数据库交互获取的资源都是静态资源</p></blockquote><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109113424433.png" alt="image-20210109113424433"></p><h1 id="Nginx-的安装"><a href="#Nginx-的安装" class="headerlink" title="Nginx 的安装"></a>Nginx 的安装</h1><h5 id="1-、准备工作"><a href="#1-、准备工作" class="headerlink" title="1 、准备工作"></a>1 、准备工作</h5><p>（ 1 ）打开虚拟机，使用远程连接工具连接linux操作系统<br>（ 2 ）到nginx官网下载软件：<a href="http://nginx.org/">http://nginx.org/</a></p><h5 id="2-、开始进行nginx安装"><a href="#2-、开始进行nginx安装" class="headerlink" title="2 、开始进行nginx安装"></a>2 、开始进行nginx安装</h5><blockquote><p>本来可以用 apt-get 的一起装的，但是想熟悉一下wget</p></blockquote><p>（ 1 ）安装pcre依赖</p><ol><li><p>联网下载pcre压缩文件依赖</p><pre><code>wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</code></pre></li><li><p>解压压缩文件</p><pre><code>tar –zxvf pcre-8.37.tar.gz</code></pre></li><li><p>执行<code>./configure</code></p></li><li><p>回到pcre目录下执行<code>make</code>，最后执行<code>make install</code></p></li><li><p>查看版本：</p><pre><code>pcre-config --version</code></pre></li></ol><p>（ 2 ）安装openssl 、zlib 、 gcc 依赖</p><pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</code></pre><p>（ 3 ）安装nginx</p><ol><li>使用命令解压</li><li>./configure</li><li>make &amp;&amp; make install</li></ol><p>进入目录 /usr/local/nginx/sbin/nginx 启动服务</p><blockquote><p>在windows系统中访问linux中nginx，默认不能访问的，因为防火墙问题<br>（ 1 ）关闭防火墙<br>（ 2 ）开放访问的端口号， 80 端口</p></blockquote><p>查看开放的端口号</p><pre><code>firewall-cmd --list-all</code></pre><p>设置开放的端口号</p><pre><code>firewall-cmd --add-service=http – permanentfirewall-cmd --add-port=80/tcp --permanent</code></pre><p>重启防火墙</p><pre><code>firewall-cmd **–** reload</code></pre><h1 id="Nginx-的常用的命令"><a href="#Nginx-的常用的命令" class="headerlink" title="Nginx 的常用的命令"></a>Nginx 的常用的命令</h1><p>进入nginx目录中<br>cd /usr/local/nginx/sbin</p><p>1 、查看nginx版本号</p><pre><code>./nginx -v或者nginx -v</code></pre><p>2 、启动nginx</p><pre><code>./nginxservice nginx start</code></pre><p>3 、停止nginx</p><pre><code>./nginx -s stop</code></pre><p>4 、重新加载nginx</p><pre><code>./nginx -s reload</code></pre><h1 id="Nginx-的配置文件"><a href="#Nginx-的配置文件" class="headerlink" title="Nginx 的配置文件"></a>Nginx 的配置文件</h1><h5 id="1-、nginx配置文件位置"><a href="#1-、nginx配置文件位置" class="headerlink" title="1 、nginx配置文件位置"></a>1 、nginx配置文件位置</h5><pre><code>cd /usr/local/nginx/conf/nginx.conf使用apt-get安装时，配置文件在 /etc/nginx 中</code></pre><h5 id="2-、配置文件中的内容"><a href="#2-、配置文件中的内容" class="headerlink" title="2 、配置文件中的内容"></a>2 、配置文件中的内容</h5><p>（ 1 ）全局块：配置服务器整体运行的配置指令</p><p>​            比如<code>worker_processes 1</code>：处理并发数的配置</p><p>（ 2 ）events块：影响 Nginx 服务器与用户的网络连接</p><p>​            比如<code>worker_connections 1024</code>： 支持的最大连接数为 1024</p><p>（ 3 ）http块<br>还包含两部分：<br>http全局块<br>server块</p><h1 id="Nginx-配置实例-反向代理实例-1"><a href="#Nginx-配置实例-反向代理实例-1" class="headerlink" title="Nginx 配置实例-反向代理实例 1"></a>Nginx 配置实例-反向代理实例 1</h1><h5 id="1-、实现效果"><a href="#1-、实现效果" class="headerlink" title="1 、实现效果"></a>1 、实现效果</h5><p>（ 1 ）打开浏览器，在浏览器地址栏输入地址 <strong><em><a href="http://www.123.com/">http://www.123.com</a></em></strong> ，跳转到liunx系统tomcat主页面中</p><h5 id="2-、准备工作"><a href="#2-、准备工作" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）在liunx系统安装tomcat，使用默认端口 8080</p><ul><li>tomcat安装文件放到liunx系统中，解压</li><li>进入tomcat的bin目录中，./startup.sh启动tomcat服务器</li></ul><h3 id="（-2-）对外开放访问的端口"><a href="#（-2-）对外开放访问的端口" class="headerlink" title="（ 2 ）对外开放访问的端口"></a>（ 2 ）对外开放访问的端口</h3><pre><code>firewall-cmd --add-port=80 80 /tcp --permanentfirewall-cmd **–** reload</code></pre><h3 id="查看已经开放的端口号"><a href="#查看已经开放的端口号" class="headerlink" title="查看已经开放的端口号"></a>查看已经开放的端口号</h3><pre><code>firewall-cmd --list-all</code></pre><p>（ 3 ）在windows系统中通过浏览器访问tomcat服务器</p><h5 id="3-、访问过程的分析"><a href="#3-、访问过程的分析" class="headerlink" title="3 、访问过程的分析"></a>3 、访问过程的分析</h5><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109115049027.png" alt="image-20210109115049027"></p><h5 id="4-、具体配置"><a href="#4-、具体配置" class="headerlink" title="4 、具体配置"></a>4 、具体配置</h5><p>第一步 在windows系统的host文件进行域名和ip对应关系的配置</p><p>（ 1 ）添加内容在host文件中</p><p>第二步 在nginx进行请求转发的配置（反向代理配置）</p><h5 id="5-、最终测试"><a href="#5-、最终测试" class="headerlink" title="5 、最终测试"></a>5 、最终测试</h5><h1 id="Nginx-配置实例-反向代理实例-2"><a href="#Nginx-配置实例-反向代理实例-2" class="headerlink" title="Nginx 配置实例-反向代理实例 2"></a>Nginx 配置实例-反向代理实例 2</h1><h5 id="1-、实现效果-1"><a href="#1-、实现效果-1" class="headerlink" title="1 、实现效果"></a>1 、实现效果</h5><p>使用nginx反向代理，根据访问的路径跳转到不同端口的服务中<br>nginx监听端口为 9001 ，</p><p>访问 <a href="http://192.168.17.129:9001/edu/">http://192.168.17.129:9001/edu/</a> 直接跳转到127.0.0.1:808 0<br>访问 <a href="http://">http://</a> 192.168.17.129:9001/vod/ 直接跳转到127.0.0.1:808 1</p><h5 id="2-、准备工作-1"><a href="#2-、准备工作-1" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）准备两个tomcat服务器，一个 8080 端口，一个 8081 端口<br>（ 2 ）创建文件夹和测试页面</p><h5 id="3-、具体配置"><a href="#3-、具体配置" class="headerlink" title="3 、具体配置"></a>3 、具体配置</h5><p>（ 1 ）找到nginx配置文件，进行反向代理配置</p><p>（ 2 ）开放对外访问的端口号 9001 8080 8081</p><h5 id="4-、最终测试"><a href="#4-、最终测试" class="headerlink" title="4 、最终测试"></a>4 、最终测试</h5><h1 id="Nginx-配置实例-负载均衡"><a href="#Nginx-配置实例-负载均衡" class="headerlink" title="Nginx 配置实例-负载均衡"></a>Nginx 配置实例-负载均衡</h1><h5 id="1-、实现效果-2"><a href="#1-、实现效果-2" class="headerlink" title="1 、实现效果"></a>1 、实现效果</h5><p>（ 1 ）浏览器地址栏输入地址 <a href="http://192.168.17.129/edu/a.html%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%88%E6%9E%9C%EF%BC%8C%E5%B9%B3%E5%9D%87">http://192.168.17.129/edu/a.html，负载均衡效果，平均</a> 8080<br>和 8081 端口中</p><h5 id="2-、准备工作-2"><a href="#2-、准备工作-2" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）准备两台tomcat服务器，一台 8080 ，一台 8081<br>（ 2 ）在两台tomcat里面webapps目录中，创建名称是edu文件夹，在edu文件夹中创建<br>页面a.html，用于测试</p><h5 id="3-、在nginx的配置文件中进行负载均衡的配置"><a href="#3-、在nginx的配置文件中进行负载均衡的配置" class="headerlink" title="3 、在nginx的配置文件中进行负载均衡的配置"></a>3 、在nginx的配置文件中进行负载均衡的配置</h5><h5 id="4-、nginx分配服务器策略"><a href="#4-、nginx分配服务器策略" class="headerlink" title="4 、nginx分配服务器策略"></a>4 、nginx分配服务器策略</h5><p>第一种 轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>第二种weight<br>weight代表权重默认为1,权重越高被分配的客户端越多</p><p>第三种ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器</p><p>第四种fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><h1 id="Nginx-配置实例-动静分离"><a href="#Nginx-配置实例-动静分离" class="headerlink" title="Nginx 配置实例-动静分离"></a>Nginx 配置实例-动静分离</h1><h5 id="1-、什么是动静分离"><a href="#1-、什么是动静分离" class="headerlink" title="1 、什么是动静分离"></a>1 、什么是动静分离</h5><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109115255261.png" alt="image-20210109115255261"></p><p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏<br>览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源<br>设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，<br>所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，<br>不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一<br>个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304 ，<br>如果有修改，则直接从服务器重新下载，返回状态码 200 。</p><h5 id="2-、准备工作-3"><a href="#2-、准备工作-3" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）在liunx系统中准备静态资源，用于进行访问</p><h5 id="3-、具体配置-1"><a href="#3-、具体配置-1" class="headerlink" title="3 、具体配置"></a>3 、具体配置</h5><p>（ 1 ）在nginx配置文件中进行配置</p><h5 id="4-、最终测试-1"><a href="#4-、最终测试-1" class="headerlink" title="4 、最终测试"></a>4 、最终测试</h5><p>（ 1 ）浏览器中输入地址：<a href="http://192.168.17.129/image/01.jpg">http://192.168.17.129/image/01.jpg</a></p><ul><li>因为配置文件 autoindex on</li></ul><p>（ 2 ）在浏览器地址栏输入地址：<a href="http://192.168.17.129/www/a.html">http://192.168.17.129/www/a.html</a></p><h1 id="Nginx-配置高可用的集群"><a href="#Nginx-配置高可用的集群" class="headerlink" title="Nginx 配置高可用的集群"></a>Nginx 配置高可用的集群</h1><h5 id="1-、什么是nginx高可用"><a href="#1-、什么是nginx高可用" class="headerlink" title="1 、什么是nginx高可用"></a>1 、什么是nginx高可用</h5><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109115401695.png" alt="image-20210109115401695"></p><p>（ 1 ）需要两台nginx服务器<br>（ 2 ）需要keepalived<br>（ 3 ）需要虚拟ip</p><h5 id="2-、配置高可用的准备工作"><a href="#2-、配置高可用的准备工作" class="headerlink" title="2 、配置高可用的准备工作"></a>2 、配置高可用的准备工作</h5><h3 id="（-1-）需要两台服务器-192-168-17-129-和-192-168-17"><a href="#（-1-）需要两台服务器-192-168-17-129-和-192-168-17" class="headerlink" title="（ 1 ）需要两台服务器 192.168.17.129 和 192.168.17."></a>（ 1 ）需要两台服务器 192.168.17.129 和 192.168.17.</h3><p>（ 2 ）在两台服务器安装nginx<br>（ 3 ）在两台服务器安装keepalived</p><h5 id="3-、在两台服务器安装keepalived"><a href="#3-、在两台服务器安装keepalived" class="headerlink" title="3 、在两台服务器安装keepalived"></a>3 、在两台服务器安装keepalived</h5><p>（ 1 ）使用yum命令进行安装<br>yum install keepalived <strong>–</strong> y</p><p>（ 2 ）安装之后，在etc里面生成目录keepalived，有文件keepalived.conf</p><h5 id="4-、完成高可用配置（主从配置）"><a href="#4-、完成高可用配置（主从配置）" class="headerlink" title="4 、完成高可用配置（主从配置）"></a>4 、完成高可用配置（主从配置）</h5><p>（ 1 ）修改/etc/keepalived/keepalivec.conf配置文件</p><pre><code>global_defs {notification_email {acassen@firewall.locfailover@firewall.locsysadmin@firewall.loc}notification_email_from Alexandre.Cassen@firewall.locsmtp_server 192.168.17.smtp_connect_timeout 30router_id LVS_DEVEL}vrrp_script chk_http_port {script "/usr/local/src/nginx_check.sh"interval 2 #（检测脚本执行的间隔）weight 2}vrrp_instance VI_1 {state BACKUP # 备份服务器上将 MASTER 改为 BACKUPinterface ens33 //网卡virtual_router_id 51 # 主、备机的virtual_router_id必须相同priority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小advert_int 1authentication {auth_type PASSauth_pass 1111}virtual_ipaddress {192.168.17.50 // VRRP H虚拟地址}}</code></pre><p>（ 2 ）在/usr/local/src添加检测脚本</p><pre><code>#!/bin/bashA=`ps -C nginx –no-header |wc -l`if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx sleep 2 if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then killall keepalived fifi</code></pre><p>（ 3 ）把两台服务器上nginx和keepalived启动<br>启动nginx：./nginx<br>启动keepalived：systemctl start keepalived.service</p><h5 id="5-、最终测试-1"><a href="#5-、最终测试-1" class="headerlink" title="5 、最终测试"></a>5 、最终测试</h5><p>（ 1 ）在浏览器地址栏输入 虚拟ip地址 192.168.17.</p><p>（ 2 ）把主服务器（192.168.17.129）nginx和keepalived停止，再输入192.168.17.</p><h2 id="Nginx的原理"><a href="#Nginx的原理" class="headerlink" title="Nginx的原理"></a>Nginx的原理</h2><p>1 、mater和worker</p><p>2 、worker如何进行工作的</p><p>3 、一个master和多个woker有好处<br>（ 1 ）可以使用nginx <strong>–</strong> s reload 热部署，利用nginx进行热部署操作<br>（ 2 ）每个woker是独立的进程，如果有其中的一个woker出现问题，其他woker独立的，<br>继续进行争抢，实现请求过程，不会造成服务中断</p><p>4 、设置多少个woker合适</p><p>worker数和服务器的cpu数相等是最为适宜的</p><p>5 、连接数worker_connection<br>第一个：发送请求，占用了woker的几个连接数？<br>答案： 2 或者 4 个</p><p>第二个：nginx有一个master，有四个woker，每个woker支持最大的连接数 1024 ，支持的<br>最大并发数是多少？</p><ul><li>普通的静态访问最大并发数是： worker_connections * worker_processes /2</li><li>而如果是HTTP作 为反向代理来说，最大并发数量应该是worker_connections *<br>worker_processes/4。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jest笔记</title>
      <link href="/8-jest-xue-xi-bi-ji.html"/>
      <url>/8-jest-xue-xi-bi-ji.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、jest介绍"><a href="#1、jest介绍" class="headerlink" title="1、jest介绍"></a>1、jest介绍</h1><p>主流前端测试框架：Jasmine，MOCHA，jest</p><h4 id="jest优点："><a href="#jest优点：" class="headerlink" title="jest优点："></a>jest优点：</h4><ul><li>新技术</li><li>性能好、功能多、简单易用</li><li>能差异化测试，只测试变化的模块</li><li>快出覆盖率</li><li>多项目并行</li></ul><h4 id="单元测试和集成测试的区别"><a href="#单元测试和集成测试的区别" class="headerlink" title="单元测试和集成测试的区别"></a>单元测试和集成测试的区别</h4><ul><li><strong>单元测试unit testing</strong>：指对软件中的最小可测试单元进行检查和验证。<strong>前端所说的单元测试就是对一个模块进行测试</strong></li><li><strong>集成测试</strong>：也叫组装测试或者联合测试。在单元测试的基础上，将所有模块按照涉及要求组装成为子系统或系统，进行集成测试。</li></ul><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><ol><li><code>npm i jest</code></li><li>修改package.json 的<code>script</code>的<code>test</code>为<code>jest</code>, 或者<code>jest --watchAll</code>(自动监测变化并测试，但有时测试结果是错误的:&lt;)</li><li><code>npm test</code></li></ol><h1 id="2、jest配置"><a href="#2、jest配置" class="headerlink" title="2、jest配置"></a>2、jest配置</h1><blockquote><p>只对<code>&lt;name&gt;.test.js</code>的文件进行测试</p></blockquote><h4 id="生成配置文件jest-config-js："><a href="#生成配置文件jest-config-js：" class="headerlink" title="生成配置文件jest.config.js："></a>生成配置文件jest.config.js：</h4><pre><code>npx jest --init</code></pre><h4 id="生成覆盖率报告："><a href="#生成覆盖率报告：" class="headerlink" title="生成覆盖率报告："></a>生成覆盖率报告：</h4><pre><code>npx jest --coverage</code></pre><blockquote><p>覆盖率报告文件夹的名字可通过 jest.config.js的<code>coverageDirectroy</code>指定</p></blockquote><h4 id="使jest支持es6的import语法：利用babel将es6转为commonjs语法"><a href="#使jest支持es6的import语法：利用babel将es6转为commonjs语法" class="headerlink" title="使jest支持es6的import语法：利用babel将es6转为commonjs语法"></a>使jest支持es6的import语法：利用babel将es6转为commonjs语法</h4><p>​    配置：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"presets"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>      <span class="token property">"targets"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"node"</span><span class="token operator">:</span> <span class="token string">"current"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h1 id="3、匹配器"><a href="#3、匹配器" class="headerlink" title="3、匹配器"></a>3、匹配器</h1><p>官网匹配器地址：<a href="https://jestjs.io/docs/en/expect">https://jestjs.io/docs/en/expect</a></p><ol><li><p>toBe(): 相当于 <code>===</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'toBe'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 就是 ===</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">expect</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>toEqual()： 外形是否一样</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'toEqual'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 外形</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">expect</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>toBeNull()：是null</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeNull', () => {  let a = null  expect(a).toBeNull()})</code></pre></li><li><p>toBeUndefined / toBeDefined：是否定义</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeUndefined', () => {  let a   expect(a).toBeUndefined()})</code></pre></li><li><p>toBeTruthy / toBeFalsy：转换为布尔值后为true还是false</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'toBeTruthy'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">expect</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBeTruthy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>toBeGreaterThan / toBeLessThan / toBeGreaterThanOrEqual / toBeLessThanOrEqual：数值比较</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeGreaterThan', () => {   // 大于  let a = 10  expect(a).toBeGreaterThan(4)})</code></pre></li><li><p>toBeCloseTo ：解决浮点数计算不精确的问题</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeCloseTo', () => {       // 解决浮点数计算不精确的问题  expect(0.1 + 0.2).toBeCloseTo(0.3)})</code></pre></li><li><p>toMatch：字符串内是否包含</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toMatch', () => {         // 字符串内是否包含  const arr = 'li, liu, wang'  expect(arr).toMatch('wang')})</code></pre></li><li><p>toContain：数组、set内是否包含</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toContain', () => {       // 数组、set内是否包含  const arr=['谢大脚','刘英','小红']  const data = new Set(arr)  expect(data).toContain('谢大脚')})</code></pre></li><li><p>toThrow：程序内是否抛出异常</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toThrow', () => {       // 程序内是否抛出异常  function throwError() {    // throw new Error('this is an error')  }  expect(throwError).not.toThrow('this is an error')    //使用 .not取反  // expect(outError).toThrow('this is an error')})</code></pre></li></ol><h1 id="4、异步代码测试"><a href="#4、异步代码测试" class="headerlink" title="4、异步代码测试"></a>4、异步代码测试</h1><blockquote><p>未明白原理，需要补充！！！！！！</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'异步代码测试'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//使用`done`表征异步完成</span>  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">expect</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>使用async/await实现：</p><pre><code></code></pre><h1 id="5、钩子函数"><a href="#5、钩子函数" class="headerlink" title="5、钩子函数"></a>5、钩子函数</h1><blockquote><p>钩子函数只作用于当前的文件</p></blockquote><ul><li><p>beforeAll(callback)：在所有测试用例之前进行执行</p></li><li><p>afterAll(callback)：完成所有测试用例之后才执行的函数</p></li><li><p>beforeEach(callback)：每个测试用例前都会执行一次的钩子函数</p></li><li><p>afterEach(callback)：每次测试用例完成测试之后执行一次的钩子函数</p><pre class=" language-JavaScript"><code class="language-JavaScript">// 举例afterEach(()=>{        console.log('afterEach')})</code></pre></li></ul><h1 id="6、测试作用域"><a href="#6、测试作用域" class="headerlink" title="6、测试作用域"></a>6、测试作用域</h1><p><code>describe(测试用例)</code>：创建作用域</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> jest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babel学习笔记</title>
      <link href="/7-babel-xue-xi-bi-ji.html"/>
      <url>/7-babel-xue-xi-bi-ji.html</url>
      
        <content type="html"><![CDATA[<p>学习地址：<a href="https://www.jiangruitao.com/babel/">姜瑞涛的官方网站</a></p><blockquote><p>babel是一个工具集，主要用于将ES6的js代码转为ES5等向后兼容的js代码</p></blockquote><h2 id="一、必要部分："><a href="#一、必要部分：" class="headerlink" title="一、必要部分："></a>一、必要部分：</h2><ol><li>babel配置文件：babelrc、babel.js、babel.config.js或package.json</li><li>相关的npm依赖</li><li>需要转码的js文件</li></ol><h2 id="二、作用："><a href="#二、作用：" class="headerlink" title="二、作用："></a>二、作用：</h2><ol><li>语法转换</li><li>补齐api     =&gt; polyfill (babel默认只转换JavaScript语法，不转换api)</li></ol><h2 id="三、版本"><a href="#三、版本" class="headerlink" title="三、版本"></a>三、版本</h2><blockquote><p>Babel是一个工具集，而这个工具集是围绕@babel/core这个核心npm包构成的。每次@babel/core发布新版本的时候，整个工具集的其它npm包也都会跟着升级到与@babel/core相同的版本号，即使它们的代码可能一行都没有改变</p></blockquote><ul><li><p>v7：<code>@babel/core</code></p></li><li><p>v6：<code>babel-core</code></p></li></ul><h2 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h2><blockquote><p>建议使用babel.config.js文件，可以进行逻辑处理</p></blockquote><ol><li><p>预设数组<code>presets</code>：就是一组Babel插件的集合</p><ol><li><strong>@babel/preset-env</strong>：TC39每年发布的进入标准的ES语法的转换器预设集合</li><li>@babel/preset-flow</li><li>@babel/preset-react</li><li>@babel/preset-typescript</li></ol></li><li><p>插件数组<code>plugins</code>：@babel/plugin-transform-runtime常用</p></li><li><p>其他<code>minified</code>、<code>ignore</code>等</p><blockquote><p><strong>plugin与preset的短名称：</strong></p><p>​    如果插件的npm包名称的前缀为 babel-plugin-，可以省略前缀。</p><p>​    如果npm包名称的前缀带有npm作用域@，例如@org/babel-plugin-xxx,短名称可以写成@org/xxx，但babel官方并没有给出明确的说明，所以还是推荐用全称。</p></blockquote></li></ol><p><strong>执行顺序：</strong></p><ul><li>插件比预设先执行</li><li>插件执行顺序是插件数组从前向后执行</li><li>预设执行顺序是预设数组从后向前执行</li></ul><h2 id="五、常用包及配置："><a href="#五、常用包及配置：" class="headerlink" title="五、常用包及配置："></a>五、常用包及配置：</h2><blockquote><p>默认为 v7</p></blockquote><ol><li>@babel/cli：Babel命令行转码工具，如果我们<strong>使用命令行</strong>进行Babel转码就需要安装它。</li></ol><ol start="2"><li>@babel/core：Babel的核心npm包。</li></ol><ol start="3"><li><p><strong>@babel/preset-env</strong>(常用)：提供了ES6转换ES5的语法转换规则</p><p>配置：</p><pre class=" language-json"><code class="language-json">presets<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"@babel/env"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    targets<span class="token operator">:</span> <span class="token punctuation">{</span>        //转码的最低环境        <span class="token property">"chrome"</span><span class="token operator">:</span> <span class="token string">"58"</span><span class="token punctuation">,</span>        <span class="token property">"ie"</span><span class="token operator">:</span> <span class="token string">"11"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    useBuiltIns<span class="token operator">:</span> <span class="token string">"usage"</span><span class="token punctuation">,</span>    //见下    corejs<span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>    //取值为<span class="token number">2</span>或<span class="token number">3</span>，指定core-js的使用版本    modules<span class="token operator">:</span><span class="token string">"false"</span><span class="token punctuation">,</span>     //见下<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre><ul><li><p><code>useBuiltIns</code>：</p><p>取值：    </p><ul><li><code>usage</code>：自动引入需要用到的polyfill</li><li><code>entry</code>：需要自行引入polyfill，且不会根据我们实际用到的API进行针对性引入polyfill</li><li><code>false</code></li></ul><blockquote><p>使用<code>entry</code>这种方式的时候，只能<code>import polyfill</code>一次，一般都是在入口文件。如果进行多次import，会发生错误。</p></blockquote></li><li><p><code>modules</code>：取值可以是<code>amd</code>、<code>umd</code> 、 <code>systemjs</code> 、 <code>commonjs</code> 、<code>cjs</code> 、<code>auto</code> 、<code>false</code>使用的模块语法</p><blockquote><p>在该参数项值是<code>auto</code>或不设置的时候，会发现我们转码前的代码里import都被转码成require了。</p><p>如果我们将参数项改成<code>false</code>，那么就不会对ES6模块化进行更改，还是使用import引入模块。</p></blockquote></li></ul></li></ol><ol start="4"><li><p><strong>@babel/polyfill</strong>： 垫片，从babel7.4开始，官方不推荐再使用了，因为@babel/polyfill本身其实就是两个npm包的集合：<strong>core-js与regenerator-runtime</strong>。</p><p>官方推荐直接使用这两个npm包。虽然@babel/polyfill还在进行版本升级，但其使用的core-js包为2.x.x版本，而core-js这个包本身已经发布到了3.x.x版本了，@babel/polyfill以后也不会使用3.x.x版本的包了。新版本的core-js实现了许多新的功能，例如数组的includes方法。</p><p>​        <strong>转码环境判断</strong>：如果我们的@babel/preset-env不设置任何参数，Babel就会完全根据package.json的<code>browserslist</code>的配置来做语法转换。如果没有browserslist，那么Babel就会把所有ES6的语法转换成ES5版本。</p><blockquote><p>注意：Babel使用browserslist的配置功能依赖于@babel/preset-env，如果Babel没有配置任何预设或插件，那么Babel对转换的代码会不做任何处理</p></blockquote></li></ol><ol start="5"><li><p><strong>@babel/runtime、<del>runtime-corejs2、</del>runtime-corejs3</strong>：原始的preset-env会在所有文件中重复注入辅助函数实现语法转换，将所有辅助函数移入runtime文件中再import入对应文件就不会增大项目体积了</p><p><a href="https://www.jiangruitao.com/babel/transform-runtime/">示例查看</a></p></li></ol><ol start="6"><li><p><strong>@babel/plugin-transform-runtime</strong>: @babel-runtime不能实现自动引入对应的辅助函数，借助此插件实现</p><pre class=" language-json"><code class="language-json">// 配置的默认值<span class="token punctuation">{</span>     <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span>        <span class="token string">"@babel/plugin-transform-runtime"</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            <span class="token property">"helpers"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    // 是否引入辅助包            <span class="token property">"corejs"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    //为<span class="token boolean">false</span>、<span class="token number">2</span>、<span class="token number">3</span>，一般开发JS库的时候才设置为<span class="token number">2</span>或<span class="token number">3</span>              <span class="token property">"regenerator"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    //转换async，await              <span class="token property">"useESModules"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>//是否使用es6的模块语法              <span class="token property">"absoluteRuntime"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    //用来自定义@babel/plugin-transform-runtime引入@babel/runtime/模块的路径规则              <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"7.0.0-beta.0"</span>    //该项主要是和@babel/runtime及其进化版@babel/runtime-corejs2、@babel/runtime-corejs3的版本号有关，这三个包我们只需要根据需要安装一个。我们把安装的npm包的版本号设置给version即可。例如，在上节的babel14例子里，安装的@babel/runtime-corejs3版本是^<span class="token number">7.10</span>.<span class="token number">4</span>，那么配置项version也取’^<span class="token number">7.10</span>.<span class="token number">4</span>’。//其实该项不填取默认值就行，目前填写版本号主要是可以减少打包体积。            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>​    作用：</p><ul><li>自动移除语法转换后内联的辅助函数，通过引入@babel/runtime/helpers里的辅助函数来替代；</li><li>当代码里使用了core-js的API，自动引入@babel/runtime-corejs3/core-js-stable/，以此来替代全局引入的core-js/stable</li><li>当代码里使用了Generator/async函数，自动引入@babel/runtime/regenerator以此来替代全局引入的regenerator-runtime/runtime；</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> babel </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在create-react-app创建的项目中对antd的样式按需引入</title>
      <link href="/6-zai-create-react-app-chuang-jian-de-xiang-mu-zhong-dui-antd-de-yang-shi-an-xu-yin-ru.html"/>
      <url>/6-zai-create-react-app-chuang-jian-de-xiang-mu-zhong-dui-antd-de-yang-shi-an-xu-yin-ru.html</url>
      
        <content type="html"><![CDATA[<h1 id="在create-react-app创建的项目中对antd的样式按需引入"><a href="#在create-react-app创建的项目中对antd的样式按需引入" class="headerlink" title="在create-react-app创建的项目中对antd的样式按需引入"></a>在create-react-app创建的项目中对antd的样式按需引入</h1><ol><li><p>下载 customize-cra,  react-app-rewired,  babel-plugin-import</p><blockquote><p><code>yarn add customize-cra react-app-rewired babel-plugin-import --dev</code></p></blockquote><p>​            customize-cra文档：<a href="https://github.com/arackaf/customize-cra">https://github.com/arackaf/customize-cra</a></p><p>​            react-app-rewired文档：<a href="https://github.com/timarney/react-app-rewired">https://github.com/timarney/react-app-rewired</a></p><p>​            babel-plugin-import文档：<a href="https://github.com/ant-design/babel-plugin-import">https://github.com/ant-design/babel-plugin-import</a></p></li></ol><ol start="2"><li><p>在package.json的同级创建config-overrides.js文件</p></li><li><p>config-overrides.js文件配置</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">{</span> override<span class="token punctuation">,</span> fixBabelImports <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'customize-cra'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">override</span><span class="token punctuation">(</span>    <span class="token function">fixBabelImports</span><span class="token punctuation">(</span><span class="token string">'import'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>           libraryName<span class="token punctuation">:</span> <span class="token string">'antd'</span><span class="token punctuation">,</span>        libraryDirectory<span class="token punctuation">:</span> <span class="token string">'lib'</span><span class="token punctuation">,</span>        style<span class="token punctuation">:</span> <span class="token string">"css"</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//如果是less文件则改为true</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>fixBabelImports配置：<a href="https://github.com/arackaf/customize-cra/blob/master/api.md#fixbabelimportslibraryname-options">https://github.com/arackaf/customize-cra/blob/master/api.md#fixbabelimportslibraryname-options</a></p></li></ol><p>   import部分配置找babel-plugin-import：<a href="https://github.com/ant-design/babel-plugin-import#usage">https://github.com/ant-design/babel-plugin-import#usage</a></p><ol start="4"><li><p>修改package.json的<code>script</code>选项</p><p>​    安装react-app-rewired后的：<a href="https://github.com/timarney/react-app-rewired#3-flip-the-existing-calls-to-react-scripts-in-npm-scripts-for-start-build-and-test">https://github.com/timarney/react-app-rewired#3-flip-the-existing-calls-to-react-scripts-in-npm-scripts-for-start-build-and-test</a></p><pre><code>  /* package.json */  "scripts": {-   "start": "react-scripts start",+   "start": "react-app-rewired start",-   "build": "react-scripts build",+   "build": "react-app-rewired build",-   "test": "react-scripts test",+   "test": "react-app-rewired test",    "eject": "react-scripts eject"}</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> antd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js设计模式</title>
      <link href="/5-js-she-ji-mo-shi.html"/>
      <url>/5-js-she-ji-mo-shi.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、设计模式"><a href="#一、设计模式" class="headerlink" title="一、设计模式"></a>一、设计模式</h2><blockquote><p><font color="brown"><strong>重中之重！！！：找出变化的地方，使变化的地方与不变的地方分离</strong></font></p></blockquote><h3 id="1-单例模式-singleton"><a href="#1-单例模式-singleton" class="headerlink" title="1. 单例模式 singleton"></a><strong>1. 单例模式 singleton</strong></h3><ol><li><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p></li><li><p>实现：用变量标志当前的是否已经为该类创造过实例对象，如果创造过则直接返回该实例，否则创造一个实例返回</p><pre class=" language-JavaScript"><code class="language-JavaScript">    let getSingle = (function() {        let instance;        return function (fn, ...rest) {     //fn: 用于创建单例的类            return instance || instance = fn.apply(this, rest);        }    })()</code></pre></li><li><p>惰性单例：在需要时才创建实例对象</p></li></ol><h3 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2.代理模式"></a><strong>2.代理模式</strong></h3><blockquote><p>当客户不方便直接访问一个对象，或者不满足需要的时候，提供一个替身对象让客户访问，替身对请求进行一些处理后再把请求转交给本体对象</p></blockquote><img src="/archives/5-js-she-ji-mo-shi.htm/images\5.代理模式.png" alt="5.代理模式" style="zoom: 25%;width:50px"><p><strong>注意</strong>：<strong>代理对象和本体对象的接口应一致</strong>，让客户使用代理对象，这个方便本体和代理使用的替换</p><ul><li><p>保护代理：用于过滤一些请求的代理</p></li><li><p>虚拟代理：选择在合适的时机处理请求的代理</p></li><li><p>缓存代理：使用代理暂时缓存远算结果，下次运算先在缓存容器里读取，没有再计算</p></li><li><p>其他代理：防火墙代理，远程代理，保护代理，智能引用代理，写时复制代理</p></li></ul><h3 id="3-发布订阅模式-PubSub"><a href="#3-发布订阅模式-PubSub" class="headerlink" title="3.发布订阅模式(PubSub)"></a><strong>3.发布订阅模式(PubSub)</strong></h3><ol><li><p>定义：又叫观察者模式，定义对象间的一种一对多的依赖关系，当对象改变时，所有依赖它的对象都会得到通知</p></li><li><p>实现：</p><ul><li>首先指定好谁充当发布者</li><li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者</li><li>发布消息时，发布者遍历这个列表，依次触发存放的订阅者的回调函数</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//订阅的通用实现</span><span class="token keyword">var</span> event <span class="token operator">=</span> <span class="token punctuation">{</span>         clientList<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 缓存列表</span>        listen<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span> key<span class="token punctuation">,</span> fn <span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//订阅函数， key用来判断发布者发布的事件是否是订阅者所希望收到订阅的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> fn <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 订阅的消息添加进缓存列表</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            trigger<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 发布函数</span>                <span class="token keyword">var</span> key <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">,</span>                 fns <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>fns <span class="token operator">||</span> fns<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没有绑定对应的消息</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> fn <span class="token operator">=</span> fns<span class="token punctuation">[</span> i<span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                    fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// arguments 是trigger 时带上的参数</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> installEvent <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token keyword">in</span> event <span class="token punctuation">)</span><span class="token punctuation">{</span>                obj<span class="token punctuation">[</span> i <span class="token punctuation">]</span> <span class="token operator">=</span> event<span class="token punctuation">[</span> i <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//个人认为应还应判断是否有重名方法</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取消订阅的通用实现</span>event<span class="token punctuation">.</span>remove <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> fns <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fns<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果key 对应的消息没有被人订阅，则直接返回</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果没有传入具体的回调函数，表示需要取消key 对应消息的所有订阅</span>      fns<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> l <span class="token operator">=</span> fns<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> l <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> l<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 反向遍历订阅的回调函数列表, 需要取消订阅的一般靠后，从后面开始遍历性能更好</span>            <span class="token keyword">var</span> _fn <span class="token operator">=</span> fns<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>_fn <span class="token operator">===</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>                fns<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除订阅者的回调函数</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ol><blockquote><p>缺点：</p><ul><li>创建订阅者本身要消耗一定的时间和内存，特别是订阅的消息一直未触发发布时，但这个订阅者会始终存在于内存中</li><li>发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解</li></ul></blockquote><blockquote><p>GitHub库：<a href="https://github.com/mroderick/PubSubJS">https://github.com/mroderick/PubSubJS</a></p></blockquote><h3 id="4-策略模式strategy"><a href="#4-策略模式strategy" class="headerlink" title="4. 策略模式strategy"></a>4. 策略模式strategy</h3><blockquote><p>个人理解： 将一个对象(事物, 情景)的不同情况都封装为方法，再在不同情况下去调用对应的方法</p></blockquote><ol><li>定义：将不同情况的解决办法定义为函数，并用对象封装起来，不同情况调用不同函数</li><li>目的：使算法的<strong>使用</strong>和<strong>实现</strong>分离，内部实现其功能，用户只用关心使用</li><li>组成：<ul><li>策略类strategy： 封装了解决不同情况的对个算法(函数), 负责计算具体过程</li><li>环境类context：接收用户的请求，并将请求委托(分发)给对应的策略，因此需要维持对策略类的引用</li></ul></li><li>典例：表单验证</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http:// xxx.com/register<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>registerForm<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            请输入用户名:&lt;input type="text" name="userName"/ > 请输入密码:&lt;input            type="text" name="password"/ > 请输入手机号码:&lt;input type="text"            name="phoneNumber"/ >            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>提交<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token comment" spellcheck="true">/***********************策略对象**************************/</span>            <span class="token keyword">var</span> strategies <span class="token operator">=</span> <span class="token punctuation">{</span>                isNonEmpty<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 传入表单值</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                minLength<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> length<span class="token punctuation">,</span> errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                isMobile<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex">/(^1[3|5|8][0-9]{9}$)/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***********************Validator 类**************************/</span>            <span class="token keyword">var</span> Validator <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 将需检查的规则全部缓存，不用考虑顺序</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 添加需检查的规则列表</span>            Validator<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>dom<span class="token punctuation">,</span> rules<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rule<span class="token punctuation">;</span> <span class="token punctuation">(</span>rule <span class="token operator">=</span> rules<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>rule<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 为什么需要闭包？</span>                        <span class="token keyword">var</span> strategyAry <span class="token operator">=</span> rule<span class="token punctuation">.</span>strategy<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> rule<span class="token punctuation">.</span>errorMsg<span class="token punctuation">;</span>                        self<span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//缓存规则检查前的信息加工函数</span>                            <span class="token keyword">var</span> strategy <span class="token operator">=</span> strategyAry<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            strategyAry<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>dom<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                            strategyAry<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">return</span> strategies<span class="token punctuation">[</span>strategy<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>dom<span class="token punctuation">,</span> strategyAry<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 依次调用cache的函数进行检查</span>            Validator<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> validatorFunc<span class="token punctuation">;</span><span class="token punctuation">(</span>validatorFunc <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> <span class="token function">validatorFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***********************客户调用代码**************************/</span>            <span class="token keyword">var</span> registerForm <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"registerForm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> validataFunc <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> validator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Validator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 添加检查需检查的表单项</span>                validator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registerForm<span class="token punctuation">.</span>userName<span class="token punctuation">,</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span> strategy<span class="token punctuation">:</span> <span class="token string">"isNonEmpty"</span><span class="token punctuation">,</span> errorMsg<span class="token punctuation">:</span> <span class="token string">"用户名不能为空"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token punctuation">{</span>                        strategy<span class="token punctuation">:</span> <span class="token string">"minLength:6"</span><span class="token punctuation">,</span>                        errorMsg<span class="token punctuation">:</span> <span class="token string">"用户名长度不能小于 10 位"</span><span class="token punctuation">,</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                validator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registerForm<span class="token punctuation">.</span>password<span class="token punctuation">,</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span>                        strategy<span class="token punctuation">:</span> <span class="token string">"minLength:6"</span><span class="token punctuation">,</span>                        errorMsg<span class="token punctuation">:</span> <span class="token string">"密码长度不能小于 6 位"</span><span class="token punctuation">,</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                validator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registerForm<span class="token punctuation">.</span>phoneNumber<span class="token punctuation">,</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span> strategy<span class="token punctuation">:</span> <span class="token string">"isMobile"</span><span class="token punctuation">,</span> errorMsg<span class="token punctuation">:</span> <span class="token string">"手机号码格式不正确"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> validator<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//绑定表单验证的事件</span>            registerForm<span class="token punctuation">.</span>onsubmit <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> <span class="token function">validataFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">alert</span><span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="5-迭代器模式"><a href="#5-迭代器模式" class="headerlink" title="5.迭代器模式"></a>5.迭代器模式</h3><blockquote><p>与策略模式的对比：策略模式的各种策略是自己已知的，而迭代器模式所需要元素是未知的，通过迭代后才能确定</p></blockquote><p>定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露对象的内部表示</p><p>分类：</p><ul><li>内部迭代器：规则隐藏在内部，外部不可见，缺点就是迭代规则不可控，交互只在第一次初始调用，</li><li>外部迭代器：迭代规则可手工控制，使迭代器更灵活，但调用也跟复杂了</li><li>倒序迭代器：从后面往前遍历的迭代器</li></ul><h3 id="6-命令模式"><a href="#6-命令模式" class="headerlink" title="6.命令模式"></a>6.命令模式</h3><blockquote><p>个人理解： 将执行的方法与执行的本体对象分离</p></blockquote><p>没有接收者的智能命令，和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们意图的不同。</p><p>策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标 的不同手段，它们的内部实现是针对“算法”而言的。</p><p>而智能命令模式指向的问题域更广，command 对象解决的目标更具发散性</p><h3 id="7-组合模式"><a href="#7-组合模式" class="headerlink" title="7.组合模式"></a>7.组合模式</h3><p>定义：用小的子对象来构建更大的对象，而这些子对象本身也有更小的孙对象构成</p><p>优点：</p><ul><li>用树形结构表示“部分-整体”的层次结构</li><li>通过对象的多态性，使用户对单个对象和组合对象的使用具有一致性(既方法名一样)</li></ul><p>注意：</p><ul><li>组合模式不是父子关系，只是组合对象把请求委托给叶子对象(类似职责链模式)</li><li>组合对象和叶子对象，叶子对象之间都必须是相同的接口，</li><li>组合对象和子对象为双向映射，一对一的关系，不能给同一个叶子对象两次请求委托</li></ul><p>缺点：</p><ul><li>系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解</li><li>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起</li></ul><h3 id="8-模板方法模式"><a href="#8-模板方法模式" class="headerlink" title="8.模板方法模式"></a>8.模板方法模式</h3><blockquote><p>个人理解：不变的封装到父类，可变的封装到子类</p></blockquote><p>在 JavaScript 中, 我们很多时候都不需要依样画瓢地去实现一个模版方法模式，<strong>高阶函数是更好的选择</strong></p><h3 id="9-享元模式"><a href="#9-享元模式" class="headerlink" title="9.享元模式"></a>9.享元模式</h3><blockquote><p>个人理解：一段逻辑本来需要许多重复或相似的对象，但只使用一个对象(带有内部状态)当做模板，每次使用时再包装(传入外部状态)成所需要的对象来达到效果</p></blockquote><p>关键是<strong>如何划分内部状态和外部状态</strong>：</p><ul><li>内部状态存储于对象内部</li><li>内部状态可以被一些对象共享</li><li>内部状态独立于具体的场景，通常不会改变</li><li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li></ul><p>例子：文件上传</p><pre class=" language-JavaScript"><code class="language-JavaScript">    Upload.prototype.delFile = function( id ){ // 文件删除函数        uploadManager.setExternalState( id, this );         if ( this.fileSize < 3000 ){            return this.dom.parentNode.removeChild( this.dom );        }        if ( window.confirm( '确定要删除该文件吗? ' + this.fileName ) ){            return this.dom.parentNode.removeChild( this.dom );        }    }    //实例化上传对象    var UploadFactory = (function(){        var createdFlyWeightObjs = {};        return {            create: function( uploadType){                 if ( createdFlyWeightObjs [ uploadType] ){  // 单例模式                    return createdFlyWeightObjs [ uploadType];                }                return createdFlyWeightObjs [ uploadType] = new Upload( uploadType);            }        }    })();    // 用统一的管理器封装外部状态    var uploadManager = (function(){        var uploadDatabase = {};        return {            add: function( id, uploadType, fileName, fileSize ){                var flyWeightObj = UploadFactory.create( uploadType );                var dom = document.createElement( 'div' );                dom.innerHTML =                '<span>文件名称:'+ fileName +', 文件大小: '+ fileSize +'</span>' +                '<button class="delFile">删除</button>';                dom.querySelector( '.delFile' ).onclick = function(){                    flyWeightObj.delFile( id );                }                document.body.appendChild( dom );                uploadDatabase[ id ] = {                    fileName: fileName,                    fileSize: fileSize,                    dom: dom                };                return flyWeightObj ;            },            setExternalState: function( id, flyWeightObj ){                var uploadData = uploadDatabase[ id ];                  for ( var i in uploadData ){        // 包装(传入外部状态)成所需要的对象                    flyWeightObj[ i ] = uploadData[ i ];                }            }        }    })();    // 触发开始上传的函数    var id = 0;    window.startUpload = function( uploadType, files ){        for ( var i = 0, file; file = files[ i++ ]; ){            var uploadObj = uploadManager.add( ++id, uploadType, file.fileName, file.fileSize );        }    };</code></pre><p>使用场景：</p><ul><li><p>一个程序中使用了大量的相似对象</p></li><li><p>由于使用了大量对象，造成很大的内存开销</p></li><li><p>对象的大多数状态都可以变为外部状态</p></li><li><p>剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象</p></li></ul><h3 id="10-职责链模式"><a href="#10-职责链模式" class="headerlink" title="10.职责链模式"></a>10.职责链模式</h3><p>定义：将多个对象连成一条链，若处理不了就将请求向下传递，直到有一个对象能处理，它避免请求对象与多个处理对象之间耦合的局面</p><p>优点：</p><ul><li>解耦了请求发送者和 N 个接收者之间的复杂关系，由于不知道链中的哪个节点可以处理你发出的请求，所以你只需把请求传递给第一个节点即可</li><li>链中的节点对象可以灵活地拆分重组</li><li>可以手动指定起始节点</li></ul><p>缺点</p><ul><li>需要在最后添加错误处理节点，以防没有成功处理请求的节点</li><li>可能存在多余的节点并未使用</li></ul><h3 id="11-中介者模式"><a href="#11-中介者模式" class="headerlink" title="11.中介者模式"></a>11.中介者模式</h3><blockquote><p>个人理解：让多个对象之间的相互联系变成多个对象只与中介者联系，由中介者统一进行管理，如vuex</p></blockquote><img src="/archives/5-js-she-ji-mo-shi.htm/hengBlog\source\images\5.中介者模式.png" style="zoom: 33%;"><p>优点：</p><ul><li>解耦对象之间的紧密关系</li><li>使对象间多对多的关系变成一对多关系</li></ul><h3 id="12-装饰者模式"><a href="#12-装饰者模式" class="headerlink" title="12.装饰者模式"></a>12.装饰者模式</h3><blockquote><p>可以配合AOP实现多个函数方法的整体化，又类似适配器模式，可以在外层包装一层函数进行装饰。值得注意的是，它并不会更改原对象</p></blockquote><p>定义： 给对象动态的增加职责(方法)</p><p>例子：AOP装饰函数</p><pre class=" language-javascript"><code class="language-javascript">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> beforefn <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> __self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 保存原函数的引用</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 返回包含了原函数和新函数的"代理"函数</span>        beforefn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 执行新函数，可在此处修改参数arguments</span>        <span class="token keyword">return</span> __self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行原函数并返回原函数的执行结果，并且保证this 不被劫持</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> afterfn <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> __self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> ret <span class="token operator">=</span> __self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>        afterfn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>值得注意的是：</p><ul><li>因为函数通过 <code>Function.prototype.before</code> 或者 <code>Function.prototype.after</code> 被装 饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失</li><li>装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一些 影响</li></ul><p>代理模式和装饰者模式的区别：<strong>在于它们的意图和设计目的</strong>。</p><ul><li><p>代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。代理模式强调一种关系(Proxy 与它的实体之间的关系)，这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而且代理模式通常只有一层代理本体的引用</p></li><li><p>装饰者模式的作用就是为对象动态加入行为，用于一开始不能确定对象的全部功能时。而且装饰者模式经常会形成一条长长的装饰链</p></li></ul><h3 id="13-状态模式"><a href="#13-状态模式" class="headerlink" title="13.状态模式"></a>13.状态模式</h3><p>定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p><p>应用关键：区别事物上下文(context)内部的状态，事物<strong>内部状态的改变</strong>往往会带来事物的<strong>行为改变</strong>，把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部</p><p>优点：</p><ul><li>状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换方法</li><li>避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过多的条件分支</li><li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然</li><li>Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响</li></ul><p>缺点：</p><ul><li>会在系统中定义许多状态类，枯燥乏味，而且系统中会因此而增加不少对象</li><li>由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑</li></ul><p><strong>状态模式和策略模式的关系</strong>：</p><p>相同点：它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行</p><p>区别：策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系， 所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法;    而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。</p><h3 id="14-适配器模式"><a href="#14-适配器模式" class="headerlink" title="14.适配器模式"></a>14.适配器模式</h3><p>应用：解决两个软件实体的接口不兼容的问题</p><p>装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。</p><h2 id="二、设计原则"><a href="#二、设计原则" class="headerlink" title="二、设计原则"></a>二、设计原则</h2><h3 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1.单一职责原则(SRP)"></a>1.单一职责原则(SRP)</h3><p>定义：一个类应该仅有一个引起它变化的原因, 既一个对象或方法只做一件事情</p><p>分离原则：</p><ul><li>如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们(比如在 ajax 请求的时候，创建 xhr 对象和发送 xhr 请求几乎总是在一起的，那么创建 xhr 对象的职责和发送 xhr 请求的职责就没有必要分开。)</li><li>另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。</li></ul><h3 id="2-最少知识原则-LKP"><a href="#2-最少知识原则-LKP" class="headerlink" title="2.最少知识原则(LKP)"></a>2.最少知识原则(LKP)</h3><p>定义：一个软件实体应当尽量少的与其他实体发生作用，既减少交互，减少耦合</p><h3 id="3-开放-封闭原则-OCP"><a href="#3-开放-封闭原则-OCP" class="headerlink" title="3.开放-封闭原则(OCP)"></a>3.开放-封闭原则(OCP)</h3><p>定义：软件实体(类，模块，函数等)应该是能扩展，但是不可修改的</p><h2 id="三、代码重构建议"><a href="#三、代码重构建议" class="headerlink" title="三、代码重构建议"></a>三、代码重构建议</h2><ol><li>提炼函数，及时添加注释，不要让函数过长</li><li>合并重复的条件片段</li><li>将条件分支语句提炼成函数</li><li>合理的使用循环，递归</li><li>使用return提前让条件退出以代替嵌套的条件分支(小技巧：即在面对一个嵌套的 if 分支时，我们可以把外层 if 表达式进行反转，就能转化为多个并级的条件判断语句)</li><li>传递对象参数以代替过长的参数列表</li><li>尽量减少参数数量</li><li>尽量不要用嵌套的三目运算符，该为if</li><li>合理使用链式调用(原理：方法结束后对象返回自身)</li><li>分解大型类为多个小类</li><li>使用return退出多重循环</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grid（网格）布局</title>
      <link href="/4-grid-wang-ge-bu-ju.html"/>
      <url>/4-grid-wang-ge-bu-ju.html</url>
      
        <content type="html"><![CDATA[<h1 id="grid（网格）布局"><a href="#grid（网格）布局" class="headerlink" title="grid（网格）布局"></a>grid（网格）布局</h1><h6 id="参考链接-http-www-ruanyifeng-com-blog-2019-03-grid-layout-tutorial-html"><a href="#参考链接-http-www-ruanyifeng-com-blog-2019-03-grid-layout-tutorial-html" class="headerlink" title="参考链接 http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html"></a>参考链接 <a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></h6><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a><code>display</code></h3><p>采用网格(grid)布局<br>==注意==: 设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p><ul><li><code>grid</code>：块级容器</li><li><code>inline-grid</code>：行内容器</li></ul><h3 id="grid-auto-columns-rows"><a href="#grid-auto-columns-rows" class="headerlink" title="grid-auto-columns / rows"></a><code>grid-auto-columns / rows</code></h3><ul><li>设置自动创建的多余网格的列宽和行高</li></ul><h3 id="grid-template-rows-columns"><a href="#grid-template-rows-columns" class="headerlink" title="grid-template-rows / columns"></a><code>grid-template-rows / columns</code></h3><ul><li><p>指定行列宽度</p><ul><li><p>用像素或百分比</p><pre><code>grid-template-rows: 100px 100px 100px;grid-template-columns: 33.3% 33.3% 33.3%;</code></pre></li><li><p>repeat()</p><pre><code>  grid-template-rows: repeat（3,100px）</code></pre></li><li><p>auto-fill</p><pre><code>grid-template-columns: repeat(auto-fill, 100px);</code></pre></li><li><p>fr单位(既fraction)</p><pre><code>grid-template-columns: 1fr 1fr;</code></pre></li><li><p>minmax(min, max)</p></li></ul></li><li><p>网格线名称</p><p>注意三行应制定四行网格线</p><ul><li>[name]</li></ul></li></ul><h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a><code>grid-template-areas</code></h3><ul><li>定义区域，名字即为网格网格名</li></ul><pre><code>    grid-template-areas: 'a b c'                               'd e f'                               'g h i';</code></pre><p>  不要利用的区域用”点”(.)表示<br>  注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><h3 id="grid-row-column-gap"><a href="#grid-row-column-gap" class="headerlink" title="grid-row / column-gap"></a><code>grid-row / column-gap</code></h3><p>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p><ul><li><p>指定行列的间距</p></li><li><p>合并写法</p><ul><li><code>grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</code></li><li><code>gap: &lt;row-gap&gt; &lt;column-gap&gt;;</code></li></ul></li></ul><h3 id="grid-auto-flow-先行后列"><a href="#grid-auto-flow-先行后列" class="headerlink" title="grid-auto-flow  先行后列"></a><code>grid-auto-flow</code>  先行后列</h3><ul><li><p>row / column</p><ul><li><p>不考虑空位，保证先后顺序</p><ul><li>链接：<a href="https://jsbin.com/wapejok/edit?css,output">https://jsbin.com/wapejok/edit?css,output</a></li></ul></li></ul></li><li><p>row dense / column dense</p><ul><li><p>尽量紧密排列</p><ul><li>链接：<a href="https://jsbin.com/xutokec/edit?css,output">https://jsbin.com/xutokec/edit?css,output</a></li></ul></li></ul></li></ul><h3 id="单元格内容的位置"><a href="#单元格内容的位置" class="headerlink" title="单元格内容的位置"></a>单元格内容的位置</h3><ul><li><code>align-items</code> 垂直方向</li><li><code>justify-items</code> 水平方向</li><li>合并写法: <code>place-items: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul><h3 id="项目整体在容器内的位置"><a href="#项目整体在容器内的位置" class="headerlink" title="项目整体在容器内的位置"></a>项目整体在容器内的位置</h3><ul><li><p><code>justify-content</code> 水平方向</p></li><li><p><code>align-content</code> 垂直方向</p></li><li><p><code>place-content</code>  前两个的合并写法</p><ul><li><code>place-content: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul></li></ul><hr><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="指定项目位置"><a href="#指定项目位置" class="headerlink" title="指定项目位置"></a>指定项目位置</h3><ul><li><p><code>grid-row / column-start / end</code></p><ul><li><p>写法</p><ul><li>网格线数字</li><li>网格线名字</li><li>span：num</li><li>重叠了用<code>z-index</code></li></ul></li><li><p>简写</p><ul><li><code>grid-row / column: &lt;start-line&gt; / &lt;end-line&gt;</code></li></ul></li></ul></li></ul><h3 id="指定项目区域名"><a href="#指定项目区域名" class="headerlink" title="指定项目区域名"></a>指定项目区域名</h3><ul><li><code>grid-area: 区域名</code></li></ul><h3 id="单元格内容的位置-优先"><a href="#单元格内容的位置-优先" class="headerlink" title="单元格内容的位置(优先)"></a>单元格内容的位置(优先)</h3><ul><li><code>align-self</code> 垂直方向</li><li><code>justify-self</code> 水平方向</li><li>合并写法: <code>place-self: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul><p><img src="/../images/4.%20%20grid%EF%BC%88%E7%BD%91%E6%A0%BC%EF%BC%89%E5%B8%83%E5%B1%80.png" alt="思维导图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> grid </tag>
            
            <tag> 布局 </tag>
            
            <tag> 网格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/3-git-chang-yong-ming-ling.html"/>
      <url>/3-git-chang-yong-ming-ling.html</url>
      
        <content type="html"><![CDATA[<h5 id="集中式和分布式版本控制系统的区别"><a href="#集中式和分布式版本控制系统的区别" class="headerlink" title="集中式和分布式版本控制系统的区别"></a>集中式和分布式版本控制系统的区别</h5><blockquote><p>分布式版本控制系统：每个开发者都有整个代码库的所有版本，在离线状态下开发者可以进行版本管理开发, 等网络恢复再push到仓库中。</p></blockquote><blockquote><p>集中式版本控制系统：每个开发者只有应用代码库的一个版本，在离线状态下开发者无法进行版本管理开发。</p></blockquote><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="Git 工作区、暂存区和版本库"></p><ol><li><h6 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h6></li></ol><p><code>git init</code>:初始化仓库<br><code>git status</code> : 查看状态：红色表示在工作区，绿色表示在暂存区，其他在版本区<br><code>git add 文件名</code>  :工作区添加到暂存区，”.”号表所有<br><code>git commit -m '注释'</code> : 暂存区到版本区<br><code>git clone URL</code> : 克隆仓库<br><code>git remote add 别名 URL</code>: 本地仓库关联远程仓库,别名一般用origin<br><code>git remote remove 别名</code>: 本地仓库移除关联</p><ol start="2"><li><h6 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h6></li></ol><p><code>git checkout 分支</code> : 切换分支<br><code>git checkout -b 分支</code> : 创建并切换<br><code>git branch 分支</code> : 创建分支但不切换<br><code>git branch</code>: 查看分支列表<br><code>git checkout -d 分支</code> : 删除分支<br><code>git push origin 分支</code> : 分支推送远程<br><code>git pull origin 分支</code> : 远程拉取到本地<br><code>git fetch origin master:tmp</code>: 新建一个tmp分支，将远程仓库的master分支上代码版本复制到tmp分支上，不会自动合并<br><code>git merge 分支</code> : 指定分支合并到当前分支</p><ol start="3"><li><h6 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h6><p><code>git log</code>: 提交日志<br><code>git reflog</code>: 每次提交的ID<br><code>git reset --hard HEAD^</code>: 版本回退到一个版本，”^“回退一个版本，”^^”回退两个版本<br><code>git reset --hard ID号</code>:回退到指定版本</p></li><li><h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><p><code>git rm 文件名</code>: 删除指定文件<br><code>git rm -r 文件名</code>: 删除指定文件夹<br><code>git rm --cached 文件</code>: 从暂存区删除 </p></li><li><h6 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h6></li></ol><p><code>git diff</code> : 比较暂存区与工作区<br><code>git diff --cached</code> : 比较版本区与暂存区<br><code>git diff master</code> : 比较版本区与工作区<br><code>git diff branch1 branch2</code>:显示出两个分支之间所有有差异的文件的详细差异<br><code>git diff branch1 branch2 --stat</code>:显示出两个分支之间所有有差异的文件列表<br><code>git diff branch1 branch2 xxx</code>:显示指定文件的详细差异</p><hr><h6 id="补充基础Linux命令"><a href="#补充基础Linux命令" class="headerlink" title="补充基础Linux命令"></a>补充基础Linux命令</h6><p><code>mkdir</code> :创建文件夹<br><code>vi</code> : 创建文件并进入<br><code>i</code> :编辑模式<br><code>ESC+:+wq</code> : 保存并退出<br><code>ESC+:+q!</code> : 不保存并退出<br><code>cd</code> : 进入文件夹<br><code>ls</code> : 当前文件夹文件列表<br><code>pwd</code> : 当前目录<br><code>cat</code> 文件 : 显示文件内容<br><code>clear</code> : 清屏</p><h6 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h6><ol><li>日常开发：feature =&gt; dev =&gt; test =&gt; master</li><li>紧急修复bug：master =&gt; hotfix =&gt; test =&gt; master</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>betterScroll踩坑记录</title>
      <link href="/1-betterscroll-cai-keng-ji-lu.html"/>
      <url>/1-betterscroll-cai-keng-ji-lu.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用BetterScroll刚<code>npm run serve</code>时无法进行滑动，需要修改BetterScroll的源码，<br>   修改<code>BetterSC/shared-utils/src/dom.ts</code> 中的常量hasTouch为true,<br>   这样就可以在初始化时对参数进行设置,把一切掌握在自己手中</p><p>   使用方法如下:</p><pre><code> new BScroll时,在参数options中加入 mouseWheel: true,   //开启鼠标滚轮 disableMouse: false,   //启用鼠标拖动 disableTouch: false    //启用手指触摸</code></pre><p>   参考博客：<a href="https://www.cnblogs.com/mldonkey/p/11421577.html">https://www.cnblogs.com/mldonkey/p/11421577.html</a></p></li></ol><ol start="2"><li>使用BetterScroll后绑定scroll, click事件后无法触发，也无报错<br> BetterScroll默认拦截了click事件可在<code>new Bscroll()</code>的配置对象中传入<code> click: true</code></li><li>使用BetterScroll的<code>scroll</code>事件必须同时在<code>new Bscroll()</code>配置对象中指定<code>probeType</code> </li></ol><p><img src="/../images/1.1.jpg" alt="what"></p><p>(后面发现官网都有说明… 链接：<a href="https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F">https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F</a>)</p><p><img src="/../images/1.2.jpg" alt="what"></p><p>. 使用better-scroll时注意$nextTick的使用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> scroll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue动态路由引入和异步组件记录</title>
      <link href="/2-vue-router-dong-tai-lu-you.html"/>
      <url>/2-vue-router-dong-tai-lu-you.html</url>
      
        <content type="html"><![CDATA[<p>动态引入的路由组件在打包时路由组件会被单独打包(代码分割 code split),<br>默认不请求加载路由组件打包文件, 当请求需要路由组件时才请求加载,当引入需要的的组件时在<code>Network</code>会增加一个打包文件(一般为<code>/^\d+.js$/</code>格式)。</p><h4 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h4><ul><li><p>component是一个执行就会<code>import()</code>的函数</p><pre><code>myComponent =  () =&gt; import(path)</code></pre></li><li><p>将组件定义对象(component definition)传递给 <code>resolve</code> 回调函数</p><pre><code>Vue.component(component, (resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve({      template: YourTemplate    })  }, 100)})</code></pre></li><li><p>使用<code>require</code>引入，这个特殊的 require 语法将指示 webpack 自动将构建后的代码，拆分到不同的 bundle 中，然后通过 Ajax 请求加载。</p><pre><code>Vue.component(component, (resolve) =&gt; {  setTimeOut(() =&gt; {    require(path, resolve);  }, 100)})</code></pre></li><li><p>使用返回的<code>promise</code>resolve前<code>import</code></p><pre><code>- Vue.component(component, (resolve) =&gt; {    setTimeOut(() =&gt; {      import(path).then(resolve);    }, 100)  })- Vue.component(component, Promise.resolve(template对象))- Vue.component(component, Promise.resolveDelay(template对象, time))</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
