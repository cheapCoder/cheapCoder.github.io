<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue3</title>
      <link href="/12-vue3.html"/>
      <url>/12-vue3.html</url>
      
        <content type="html"><![CDATA[<p>源地址：<a href="https://24kcs.github.io/vue3_study/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.html">https://24kcs.github.io/vue3_study/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.html</a></p><h1 id="1-认识Vue3"><a href="#1-认识Vue3" class="headerlink" title="1. 认识Vue3"></a>1. 认识Vue3</h1><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>打包大小减少41%,初次渲染快55%, 更新渲染快133%,内存减少54%</li><li><strong>支持vue2的大多数特性</strong></li><li><strong>更好的支持Typescript</strong></li><li><strong>使用<code>Proxy</code>代替<code>defineProperty</code>实现数据响应式</strong></li><li><strong>重写虚拟DOM的实现和Tree-Shaking</strong></li></ul><h2 id="新增特性"><a href="#新增特性" class="headerlink" title="新增特性"></a>新增特性</h2><ul><li><strong>Composition (组合) API</strong><ul><li>setup</li><li>ref 和 reactive</li><li>computed、watch、watchEffect</li><li>新的生命周期函数</li><li>provide与inject</li></ul></li><li>新组件<ul><li>Fragment - 文档碎片</li><li>Teleport - 瞬移组件的位置</li><li>Suspense - 异步加载组件的loading界面</li></ul></li><li>其它API更新<ul><li>全局API的修改</li><li>将原来的全局API转移到应用对象(App)</li><li>模板语法变化</li></ul></li></ul><h1 id="2-创建vue3项目"><a href="#2-创建vue3项目" class="headerlink" title="2. 创建vue3项目"></a>2. 创建vue3项目</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1) 使用 vue-cli 创建"></a>1) 使用 vue-cli 创建</h2><p>文档: <a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 安装或者升级</span><span class="token function">npm</span> <span class="token function">install</span> -g @vue/cli<span class="token comment" spellcheck="true">## 保证 vue cli 版本在 4.5.0 以上</span>vue --version<span class="token comment" spellcheck="true">## 创建项目</span>vue create my-project</code></pre><p>步骤：</p><pre><code>- Please pick a preset - 选择 ***Manually select features***- Check the features needed for your project - 选择上 ***TypeScript*** ，特别注意点空格是选择，点回车是下一步- Choose a version of Vue.js that you want to start the project with - 选择 ***3.x (Preview)***- Use class-style component syntax - 直接回车- Use Babel alongside TypeScript - 直接回车- Pick a linter / formatter config - 直接回车- Use history mode for router? - 直接回车- Pick a linter / formatter config - 直接回车- Pick additional lint features - 直接回车- Where do you prefer placing config for Babel, ESLint, etc.? - 直接回车- Save this as a preset for future projects? - 直接回车</code></pre><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2) 使用 vite 创建"></a>2) 使用 vite 创建</h2><p>文档: <a href="https://v3.cn.vuejs.org/guide/installation.html">https://v3.cn.vuejs.org/guide/installation.html</a></p><ul><li>vite 是一个由原生 ESM 驱动的 Web 开发构建工具。在开发环境下基于浏览器原生 ES imports 开发，</li><li>它做到了**<em>本地快速开发启动**</em>, 在生产环境下基于 Rollup 打包。<ul><li>快速的冷启动，不需要等待打包操作；</li><li>即时的热模块更新，替换性能和模块数量的解耦让更新飞起；</li><li>真正的按需编译，不再等待整个应用编译完成，这是一个巨大的改变。</li></ul></li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> init vite-app <span class="token operator">&lt;</span>project-name<span class="token operator">></span><span class="token function">cd</span> <span class="token operator">&lt;</span>project-name<span class="token operator">></span><span class="token function">npm</span> <span class="token function">install</span><span class="token function">npm</span> run dev</code></pre><h1 id="3-Vue2与Vue3的响应式原理比较-重要"><a href="#3-Vue2与Vue3的响应式原理比较-重要" class="headerlink" title="3. Vue2与Vue3的响应式原理比较(重要)"></a>3. Vue2与Vue3的响应式原理比较(重要)</h1><h3 id="1-Vue2的响应式"><a href="#1-Vue2的响应式" class="headerlink" title="1) Vue2的响应式"></a>1) Vue2的响应式</h3><ul><li>核心:<ul><li>对象: 通过<code>defineProperty</code>对对象的已有属性值的读取和修改进行劫持(监视/拦截)</li><li>数组: 通过重写数组更新数组一系列更新元素的方法来实现元素修改的劫持（push、pop、shift、unshift、splice、sort、reverse）</li></ul></li></ul><pre class=" language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'count'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ul><li>问题<ul><li>对象直接新添加的属性或删除已有属性, 界面不会自动更新</li><li>直接通过下标替换元素或更新length（arr[1] = {}）, 界面不会自动更新 </li></ul></li></ul><h3 id="2-Vue3的响应式"><a href="#2-Vue3的响应式" class="headerlink" title="2) Vue3的响应式"></a>2) Vue3的响应式</h3><ul><li>核心:<ul><li>通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy(代理)</a>: 拦截对data任意属性的任意(13种)操作, 包括属性值的读写, 添加, 删除等</li><li>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect(反射)</a>: <strong>动态</strong>对被代理对象的相应属性进行特定的操作</li></ul></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>  age<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* proxyUser是代理对象, user是被代理对象后面所有的操作都是通过代理对象来操作被代理对象内部属性*/</span><span class="token keyword">const</span> proxyUser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'劫持get()'</span><span class="token punctuation">,</span> prop<span class="token punctuation">)</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'劫持set()'</span><span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (2)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'劫持delete属性'</span><span class="token punctuation">,</span> prop<span class="token punctuation">)</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 读取属性值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxyUser <span class="token operator">===</span> user<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxyUser<span class="token punctuation">.</span>name<span class="token punctuation">,</span> proxyUser<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 设置属性值</span>proxyUser<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'bob'</span>proxyUser<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">13</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 添加属性</span>proxyUser<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'男'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 删除属性</span><span class="token keyword">delete</span> proxyUser<span class="token punctuation">.</span>sexconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span></code></pre><h1 id="4-Composition-API-常用部分"><a href="#4-Composition-API-常用部分" class="headerlink" title="4. Composition API(常用部分)"></a>4. Composition API(常用部分)</h1><p>文档: <a href="https://composition-api.vuejs.org/zh/api.html">https://composition-api.vuejs.org/zh/api.html</a></p><h2 id="1-setup"><a href="#1-setup" class="headerlink" title="1) setup"></a>1) setup</h2><ul><li>setup执行<ul><li>在<code>beforeCreate</code>之前执行(一次), 此时组件对象还没有创建</li><li>this是undefined, 不能通过this来访问data/computed/methods / props</li></ul></li><li>setup的返回值<ul><li>一般都返回一个对象为模板提供数据, 也就是模板中可以直接使用此对象中的所有属性/方法</li><li>返回对象中的属性、方法会与data函数、methods中的合并</li><li>如果<strong>有重名, setup优先</strong>，一般不要混合使用，来源混乱</li><li>methods中可以访问setup提供的属性和方法, 但在setup方法中不能访问data和methods</li><li>setup不能是一个async函数: 因为返回值不再是对象, 而是promise, 模板看不到return对象中的属性数据（可变成异步组件）</li></ul></li><li>setup的参数：(props, context) / setup(props, {attrs, slots, emit})<ul><li><code>props</code>: 包含props配置声明且传入了的所有属性的对象</li><li><code>attrs</code>: 包含没有在props配置中声明的属性的对象, 相当于 <code>this.$attrs</code></li><li><code>slots</code>: 包含所有传入的插槽内容的对象, 相当于 <code>this.$slots</code></li><li><code>emit</code>: 用来分发自定义事件的函数, 相当于 <code>this.$emit</code></li></ul></li></ul><pre class=" language-vue"><code class="language-vue">// 父组件<template>  <h2>App</h2>  <p>msg: {{msg}}</p>  <button @click="fn('--')">更新</button>  <child :msg="msg" msg2="cba" @fn="fn"/></template><script lang="ts">import {  reactive,  ref,} from 'vue'import child from './child.vue'export default {  components: {    child  },  setup () {    const msg = ref('abc')    function fn (content: string) {      msg.value += content    }    return {      msg,      fn    }  }}</script>// 子组件<template>  <div>    <h3>{{n}}</h3>    <h3>{{m}}</h3>    <h3>msg: {{msg}}</h3>    <h3>msg2: {{$attrs.msg2}}</h3>    <slot name="xxx"></slot>    <button @click="update">更新</button>  </div></template><script lang="ts">import {  ref,  defineComponent} from 'vue'export default defineComponent({  name: 'child',  props: ['msg'],  emits: ['fn'], // 可选的, 声明了更利于程序员阅读, 且可以对分发的事件数据进行校验  data () {    console.log('data', this)    return {      // n: 1    }  },  beforeCreate () {    console.log('beforeCreate', this)  },  methods: {    // update () {    //   this.n++    //   this.m++    // }  },  // setup (props, context) {  setup (props, {attrs, emit, slots}) {    console.log('setup', this)    console.log(props.msg, attrs.msg2, slots, emit)    const m = ref(2)    const n = ref(3)    function update () {      // console.log('--', this)      // this.n += 2       // this.m += 2      m.value += 2      n.value += 2      // 分发自定义事件      emit('fn', '++')    }    return {      m,      n,      update,    }  },})</script></code></pre><h2 id="2-ref"><a href="#2-ref" class="headerlink" title="2) ref"></a>2) ref</h2><ul><li>作用: 通常定义一个<strong>基本类型</strong>的响应式数据</li><li>语法： <code>const xxx = ref(initValue)</code><ul><li>创建一个包含响应式数据的引用(reference)对象</li><li>js中操作数据: xxx.value</li><li>模板中操作数据: 不需要.value</li></ul></li></ul><pre class=" language-vue"><code class="language-vue"><template>  <h2>{{count}}</h2>  <hr>  <button @click="update">更新</button></template><script>import {  ref} from 'vue'export default {  /* 在Vue3中依然可以使用data和methods配置, 但建议使用其新语法实现 */  // data () {  //   return {  //     count: 0  //   }  // },  // methods: {  //   update () {  //     this.count++  //   }  // }  /* 使用vue3的composition API */  setup () {    // 定义响应式数据 ref对象    const count = ref(1)    console.log(count)    // 更新响应式数据的函数    function update () {      // alert('update')      count.value = count.value + 1    }    return {      count,      update    }  }}</script></code></pre><p><strong>利用ref函数获取组件中的标签元素</strong></p><pre class=" language-vue"><code class="language-vue">// 功能需求: 让输入框自动获取焦点<template>  <h2>App</h2>  <input type="text">---  <input type="text" ref="inputRef"></template><script lang="ts">import { onMounted, ref } from 'vue'/* ref获取元素: 利用ref函数获取组件中的标签元素功能需求: 让输入框自动获取焦点*/export default {  setup() {    const inputRef = ref<HTMLElement|null>(null)    // 定义ref变量    onMounted(() => {      inputRef.value && inputRef.value.focus()    // 可直接使用ref变量访问    })    return {      inputRef    }  },}</script></code></pre><h2 id="3-reactive"><a href="#3-reactive" class="headerlink" title="3) reactive"></a>3) reactive</h2><ul><li>作用: 定义<strong>复杂数据类型</strong>的响应式代理</li><li>语法：<code>const proxy = reactive(obj)</code><ul><li>接收一个普通对象然后返回该普通对象的响应式代理器对象</li><li>响应式转换是“深层的”：会影响对象内部所有嵌套的属性</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的</li></ul></li></ul><pre class=" language-vue"><code class="language-vue"><template>  <h2>name: {{state.name}}</h2>  <h2>age: {{state.age}}</h2>  <h2>wife: {{state.wife}}</h2>  <hr>  <button @click="update">更新</button></template><script>import {  reactive,} from 'vue'export default {  setup () {    /*     定义响应式数据对象    */    const state = reactive({      name: 'tom',      age: 25,      wife: {        name: 'marry',        age: 22      },    })    console.log(state, state.wife)    const update = () => {      state.name += '--'      state.age += 1      state.wife.name += '++'      state.wife.age += 2    }    return {      state,      update,    }  }}</script></code></pre><h2 id="4-reactive与ref-细节"><a href="#4-reactive与ref-细节" class="headerlink" title="4) reactive与ref-细节"></a>4) reactive与ref-细节</h2><ul><li>ref用来处理<strong>基本类型</strong>数据, reactive用来处理<strong>对象</strong>(递归深度响应式)</li><li>如果用ref对象/数组, 内部会自动将xxx.value的对象/数组转换为reactive的代理对象</li><li>ref内部: 通过给<strong>value属性添加getter/setter</strong>来实现对数据的劫持</li><li>reactive内部: 通过使用Proxy来实现对对象内部所有数据的劫持, 并通过Reflect操作对象内部数据</li><li>ref的数据操作: 在js中要.value, 在模板中不需要(内部解析模板时会自动添加.value)</li></ul><pre class=" language-vue"><code class="language-vue"><template>  <h2>App</h2>  <p>m1: {{m1}}</p>  <p>m2: {{m2}}</p>  <p>m3: {{m3}}</p>  <button @click="update">更新</button></template><script lang="ts">import {  reactive,  ref} from 'vue'export default {  setup () {    const m1 = ref('abc')    const m2 = reactive({x: 1, y: {z: 'abc'}})    // 使用ref处理对象  ==> 对象会被自动reactive为proxy对象    const m3 = ref({a1: 2, a2: {a3: 'abc'}})    console.log(m1, m2, m3)    console.log(m3.value.a2) // 也是一个proxy对象    function update() {      m1.value += '--'      m2.x += 1      m2.y.z += '++'      m3.value = {a1: 3, a2: {a3: 'abc---'}}      m3.value.a2.a3 += '==' // reactive对对象进行了深度数据劫持      console.log(m3.value.a2)    }    return {      m1,      m2,      m3,      update    }  }}</script></code></pre><h2 id="5-computed和watch"><a href="#5-computed和watch" class="headerlink" title="5) computed和watch"></a>5) computed和watch</h2><ul><li>computed函数:<ul><li>与vue2的computed配置功能一致</li><li>有getter和setter</li></ul></li><li>watch函数<ul><li>监视指定的一个或多个响应式数据, 一旦数据变化, 就自动执行监视回调</li><li>默认初始时不执行回调, 但可以通过配置<code>immediate</code>为true, 来指定初始时立即执行第一次</li><li>通过配置<code>deep</code>为true, 来指定深度监视</li><li>如果是ref对象, 直接指定；是reactive对象中的属性,  必须通过函数来指定</li></ul></li><li>watchEffect函数<ul><li>不用直接指定要监视的数据, 自动监视内部响应式数据，发生变化时回调执行</li><li>默认初始时就会执行第一次, 从而可以收集需要监视的数据</li></ul></li></ul><pre class=" language-vue"><code class="language-vue"><template>  <h2>App</h2>  fistName: <input v-model="user.firstName"/><br>  lastName: <input v-model="user.lastName"/><br>  fullName1: <input v-model="fullName1"/><br>  fullName2: <input v-model="fullName2"><br>  fullName3: <input v-model="fullName3"><br></template><script lang="ts">import {  reactive,  ref,  computed,  watch,  watchEffect} from 'vue'export default {  setup () {    const user = reactive({      firstName: 'A',      lastName: 'B'    })    // 只有getter的计算属性    const fullName1 = computed(() => {      console.log('fullName1')      return user.firstName + '-' + user.lastName    })    // 有getter与setter的计算属性    const fullName2 = computed({      get () {        console.log('fullName2 get')        return user.firstName + '-' + user.lastName      },      set (value: string) {        console.log('fullName2 set')        const names = value.split('-')        user.firstName = names[0]        user.lastName = names[1]      }    })    const fullName3 = ref('')    /*     watchEffect: 监视所有回调中使用的数据    */    /*     watchEffect(() => {      console.log('watchEffect')      fullName3.value = user.firstName + '-' + user.lastName    })     */    /*     使用watch的2个特性:      深度监视      初始化立即执行    */    watch(user, () => {      fullName3.value = user.firstName + '-' + user.lastName    }, {      immediate: true,  // 是否初始化立即执行一次, 默认是false      deep: true, // 是否是深度监视, 默认是false    })    /*     watch一个数据      默认在数据发生改变时执行回调    */    watch(fullName3, (value) => {      console.log('watch')      const names = value.split('-')      user.firstName = names[0]      user.lastName = names[1]    })    /*     watch多个数据，使用数组来指定              如果是ref对象, 直接指定              如果是reactive对象中的属性,  必须通过函数来指定    */    watch([() => user.firstName, () => user.lastName, fullName3], (values) => {      console.log('监视多个数据', values)    })    return {      user,      fullName1,      fullName2,      fullName3    }  }}</script></code></pre><h2 id="6-生命周期"><a href="#6-生命周期" class="headerlink" title="6) 生命周期"></a>6) 生命周期</h2><table><thead><tr><th align="center"><strong>vue2.x的生命周期</strong>：</th><th align="center">vue3的生命周期：</th></tr></thead><tbody><tr><td align="center"><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;"></td><td align="center"><img src="https://vue3js.cn/docs/zh/images/lifecycle.png" alt="lifecycle_3" style="zoom: 33%;"></td></tr></tbody></table><p><strong>与 2.x 版本生命周期相对应的组合式 API</strong></p><ul><li><code>beforeCreate</code> -&gt; 使用 <code>setup()</code></li><li><code>created</code> -&gt; 使用 <code>setup()</code></li><li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li><li><code>mounted</code> -&gt; <code>onMounted</code></li><li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li><li><code>updated</code> -&gt; <code>onUpdated</code></li><li><code>beforeDestroy</code> -&gt; <code>onBeforeUnmount</code>    // 名称修改</li><li><code>destroyed</code> -&gt; <code>onUnmounted</code></li><li><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></li></ul><blockquote><p>而且两种生命周期函数同时存在时，3.0的onXXX函数优先执行</p></blockquote><p><strong>新增的钩子函数</strong></p><p>组合式 API 还提供了以下调试钩子函数：</p><ul><li><code>onRenderTracked</code></li><li><code>onRenderTriggered</code></li></ul><pre class=" language-vue"><code class="language-vue"><template><div class="about">  <h2>msg: {{msg}}</h2>  <hr>  <button @click="update">更新</button></div></template><script lang="ts">import {  ref,  onMounted,  onUpdated,  onUnmounted,   onBeforeMount,   onBeforeUpdate,  onBeforeUnmount} from "vue"export default {  beforeCreate () {    console.log('beforeCreate()')  },  created () {    console.log('created')  },  beforeMount () {    console.log('beforeMount')  },  mounted () {    console.log('mounted')  },  beforeUpdate () {    console.log('beforeUpdate')  },  updated () {    console.log('updated')  },  beforeUnmount () {    console.log('beforeUnmount')  },  unmounted () {     console.log('unmounted')  },    setup() {    const msg = ref('abc')    const update = () => {      msg.value += '--'    }    onBeforeMount(() => {      console.log('--onBeforeMount')    })    onMounted(() => {      console.log('--onMounted')    })    onBeforeUpdate(() => {      console.log('--onBeforeUpdate')    })    onUpdated(() => {      console.log('--onUpdated')    })    onBeforeUnmount(() => {      console.log('--onBeforeUnmount')    })    onUnmounted(() => {      console.log('--onUnmounted')    })        return {      msg,      update    }  }}</script></code></pre><h2 id="7-toRef"><a href="#7-toRef" class="headerlink" title="7) toRef"></a>7) toRef</h2><p>对比<code>ref</code></p><ul><li><code>toRef</code>为源响应式对象上的某个属性创建一个 ref对象, 二者内部操作的是同一个数据值, <strong>更新时二者是同步更新</strong></li><li>ref: 拷贝了一份新的数据值单独操作, 更新时相互不影响</li></ul><p>应用: 当要将某个prop 的 ref 传递给复合函数时，toRef 很有用</p><pre class=" language-vue"><code class="language-vue"><template>  <h2>App</h2>  <p>{{state}}</p>  <p>{{foo}}</p>  <p>{{foo2}}</p>  <button @click="update">更新</button>  <Child :foo="foo"/></template><script lang="ts">import {  reactive,  toRef,  ref,} from 'vue'import Child from './Child.vue'export default {  setup () {    const state = reactive({      foo: 1,      bar: 2    })    const foo = toRef(state, 'foo')    const foo2 = ref(state.foo)    const update = () => {      state.foo++      // foo.value++      // foo2.value++  // foo和state中的数据不会更新    }    return {      state,      foo,      foo2,      update,    }  },  components: {    Child  }}</script><template>  <h2>Child</h2>  <h3>{{foo}}</h3>  <h3>{{length}}</h3></template><script lang="ts">import { computed, defineComponent, Ref, toRef } from 'vue'const component = defineComponent({  props: {    foo: {      type: Number,      require: true    }  },  setup (props, context) {    const length = useFeatureX(toRef(props, 'foo'))    return {      length    }  }})function useFeatureX(foo: Ref) {  const lenth = computed(() => foo.value.length)  return lenth}export default component</script></code></pre><h2 id="8-toRefs"><a href="#8-toRefs" class="headerlink" title="8) toRefs"></a>8) toRefs</h2><p>把一个响应式对象转换成普通对象，但该普通对象的每个 property 都是一个 ref</p><p>应用: 当从合成函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应式的情况下对返回的对象进行分解使用</p><pre class=" language-vue"><code class="language-vue"><template>  <h2>App</h2>  <h3>foo: {{foo}}</h3>  <h3>bar: {{bar}}</h3>  <h3>foo2: {{foo2}}</h3>  <h3>bar2: {{bar2}}</h3></template><script lang="ts">import { reactive, toRefs } from 'vue'export default {  setup () {    const state = reactive({      foo: 'a',      bar: 'b',    })    const stateAsRefs = toRefs(state)    setTimeout(() => {      state.foo += '++'      state.bar += '++'    }, 2000);    const {foo2, bar2} = useReatureX()    return {      // ...state,      ...stateAsRefs,        //    利用toRefs和对象解构    进行对象属性分散      foo2,       bar2    }  },}function useReatureX() {  const state = reactive({    foo2: 'a',    bar2: 'b',  })  setTimeout(() => {    state.foo2 += '++'    state.bar2 += '++'  }, 2000);  return toRefs(state)}</script></code></pre><h2 id="9-customRef"><a href="#9-customRef" class="headerlink" title="9) customRef"></a>9) customRef</h2><p>​        作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制</p><p>需求: 使用 customRef 实现 debounce 的示例</p><pre class=" language-vue"><code class="language-vue"><template>  <h2>App</h2>  <input v-model="keyword" placeholder="搜索关键字"/>  <p>{{keyword}}</p></template><script lang="ts">import {  ref,  customRef} from 'vue'export default {  setup () {    const keyword = useDebouncedRef('', 500)    console.log(keyword)    return {      keyword    }  },}/* 实现函数防抖的自定义ref*/function useDebouncedRef<T>(value: T, delay = 200) {  let timeout: number  return customRef((track, trigger) => {    return {      get() {        // 告诉Vue追踪数据        track()        return value      },      set(newValue: T) {        clearTimeout(timeout)        timeout = setTimeout(() => {          value = newValue          // 告诉Vue去触发界面更新          trigger()        }, delay)      }    }  })}</script></code></pre><h2 id="10-shallowReactive-与-shallowRef"><a href="#10-shallowReactive-与-shallowRef" class="headerlink" title="10) shallowReactive 与 shallowRef"></a>10) shallowReactive 与 shallowRef</h2><ul><li>shallowReactive : 只处理了对象内最外层属性的响应式(也就是浅响应式)</li><li>shallowRef: 只处理了value的响应式, 不进行对象的reactive处理</li><li>什么时候用浅响应式呢?<ul><li>一般情况下使用ref和reactive即可</li><li>如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive</li><li>如果有一个对象数据, 后面会产生新的对象来替换 ===&gt; shallowRef</li></ul></li></ul><pre class=" language-vue"><code class="language-vue"><template>  <h2>App</h2>  <h3>m1: {{m1}}</h3>  <h3>m2: {{m2}}</h3>  <h3>m3: {{m3}}</h3>  <h3>m4: {{m4}}</h3>  <button @click="update">更新</button></template><script lang="ts">import { reactive, ref, shallowReactive, shallowRef } from 'vue'export default {  setup () {    const m1 = reactive({a: 1, b: {c: 2}})    const m2 = shallowReactive({a: 1, b: {c: 2}})    const m3 = ref({a: 1, b: {c: 2}})    const m4 = shallowRef({a: 1, b: {c: 2}})    const update = () => {      // m1.b.c += 1      // m2.b.c += 1      // m3.value.a += 1      m4.value.a += 1    }    return {      m1,      m2,      m3,      m4,      update,    }  }}</script></code></pre><h2 id="11-readonly-与-shallowReadonly"><a href="#11-readonly-与-shallowReadonly" class="headerlink" title="11) readonly 与 shallowReadonly"></a>11) readonly 与 shallowReadonly</h2><ul><li>readonly:<ul><li>深度只读数据</li><li>获取一个对象 (响应式或纯对象) 或 ref 并返回原始代理的只读代理。</li><li>只读代理是深层的：访问的任何嵌套 property 也是只读的。</li></ul></li><li>shallowReadonly<ul><li>浅只读数据</li><li>创建一个代理，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换</li></ul></li><li>应用场景:<ul><li>在某些特定情况下, 我们可能不希望对数据进行更新的操作, 那就可以包装生成一个只读代理对象来读取数据, 而不能修改或删除</li></ul></li></ul><pre class=" language-vue"><code class="language-vue"><template>  <h2>App</h2>  <h3>{{state}}</h3>  <button @click="update">更新</button></template><script lang="ts">import { reactive, readonly, shallowReadonly } from 'vue'export default {  setup () {    const state = reactive({      a: 1,      b: {        c: 2      }    })    // const rState1 = readonly(state)    const rState2 = shallowReadonly(state)    const update = () => {      // rState1.a++ // error      // rState1.b.c++ // error      // rState2.a++ // error      rState2.b.c++    }        return {      state,      update    }  }}</script></code></pre><h2 id="12-toRaw-与-markRaw"><a href="#12-toRaw-与-markRaw" class="headerlink" title="12) toRaw 与 markRaw"></a>12) toRaw 与 markRaw</h2><ul><li>toRaw<ul><li>返回由 <code>reactive</code> 或 <code>readonly</code> 方法转换成响应式代理的普通对象。</li><li>这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发界面更新。</li></ul></li><li>markRaw<ul><li>标记一个对象，使其永远不会转换为代理。返回对象本身</li><li>应用场景:<ul><li>有些值不应被设置为响应式的，例如复杂的第三方类实例或 Vue 组件对象。</li><li>当渲染具有不可变数据源的大列表时，跳过代理转换可以提高性能。</li></ul></li></ul></li></ul><pre class=" language-vue"><code class="language-vue"><template>  <h2>{{state}}</h2>  <button @click="testToRaw">测试toRaw</button>  <button @click="testMarkRaw">测试markRaw</button></template><script lang="ts">import {  markRaw,  reactive, toRaw,} from 'vue'export default {  setup () {    const state = reactive<any>({      name: 'tom',      age: 25,    })    const testToRaw = () => {      const user = toRaw(state)      user.age++  // 界面不会更新    }    const testMarkRaw = () => {      const likes = ['a', 'b']      // state.likes = likes      state.likes = markRaw(likes) // likes数组就不再是响应式的了      setTimeout(() => {        state.likes[0] += '--'      }, 1000)    }    return {      state,      testToRaw,      testMarkRaw,    }  }}</script></code></pre><h2 id="13-响应式数据的判断"><a href="#13-响应式数据的判断" class="headerlink" title="13) 响应式数据的判断"></a>13) 响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h2 id="14-自定义hook函数"><a href="#14-自定义hook函数" class="headerlink" title="14) 自定义hook函数"></a>14) 自定义hook函数</h2><ul><li><p>使用Vue3的组合API封装的可复用的功能函数</p></li><li><p>自定义hook的作用类似于vue2中的mixin技术</p></li><li><p>自定义Hook的优势: 很清楚复用功能代码的来源, 更清楚易懂</p></li></ul><p>  需求1: 收集用户鼠标点击的页面坐标(hooks/useMousePosition.ts)</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment" spellcheck="true">/* 收集用户鼠标点击的页面坐标*/</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> useMousePosition <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 初始化坐标数据  const x = ref(-1)  const y = ref(-1)  // 用于收集点击事件坐标的函数  const updatePosition = (e: MouseEvent) => {    x.value = e.pageX    y.value = e.pageY  }  // 挂载后绑定点击监听  onMounted(() => {    document.addEventListener('click', updatePosition)  })  // 卸载前解绑点击监听  onUnmounted(() => {    document.removeEventListener('click', updatePosition)  })  return {x, y}}&lt;template>&lt;div>  &lt;h2>x: {{x}}, y: {{y}}&lt;/h2>&lt;/div>&lt;/template>&lt;script>import { ref } from "vue"</span><span class="token comment" spellcheck="true">/* 在组件中引入并使用自定义hook自定义hook的作用类似于vue2中的mixin技术自定义Hook的优势: 很清楚复用功能代码的来源, 更清楚易懂*/</span><span class="token keyword">import</span> useMousePosition <span class="token keyword">from</span> <span class="token string">'./hooks/useMousePosition'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      x<span class="token punctuation">,</span>      y<span class="token punctuation">,</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><ul><li><p>利用TS泛型强化类型检查</p></li><li><p>需求2: 封装发ajax请求的hook函数</p><p>hooks/useRequest.ts</p></li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token comment" spellcheck="true">/* 使用axios发送异步ajax请求*/</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> useUrlLoader<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> result <span class="token operator">=</span> ref<span class="token operator">&lt;</span>T <span class="token operator">|</span> <span class="token keyword">null</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> loading <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> errorMsg <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>  axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      loading<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">false</span>      result<span class="token punctuation">.</span>value <span class="token operator">=</span> response<span class="token punctuation">.</span>data    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      loading<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">false</span>      errorMsg<span class="token punctuation">.</span>value <span class="token operator">=</span> e<span class="token punctuation">.</span>message <span class="token operator">||</span> <span class="token string">'未知错误'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    loading<span class="token punctuation">,</span>    result<span class="token punctuation">,</span>    errorMsg<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>template<span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"about"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>h2 v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"loading"</span><span class="token operator">></span>LOADING<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>  <span class="token operator">&lt;</span>h2 v<span class="token operator">-</span><span class="token keyword">else</span><span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"errorMsg"</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span>errorMsg<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token operator">&lt;</span>ul v<span class="token operator">-</span><span class="token keyword">else</span><span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>id<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>result<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>name<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>result<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>distance<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>result<span class="token punctuation">.</span>distance<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span> <span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>ul v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"p in result"</span> <span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token string">"p.id"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>id<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>p<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>title<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>p<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>price<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>p<span class="token punctuation">.</span>price<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token operator">&lt;</span>img v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"result"</span> <span class="token punctuation">:</span>src<span class="token operator">=</span><span class="token string">"result[0].url"</span> alt<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span> <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script lang<span class="token operator">=</span><span class="token string">"ts"</span><span class="token operator">></span><span class="token keyword">import</span> <span class="token punctuation">{</span>  watch<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token keyword">import</span> useRequest <span class="token keyword">from</span> <span class="token string">'./hooks/useRequest'</span><span class="token comment" spellcheck="true">// 地址数据接口interface AddressResult {  id: number;  name: string;  distance: string;}// 产品数据接口interface ProductResult {  id: string;  title: string;  price: number;}export default {  setup() {    // const {loading, result, errorMsg} = useRequest&lt;AddressResult>('/data/address.json')    const {loading, result, errorMsg} = useRequest&lt;ProductResult[]>('/data/products.json')    watch(result, () => {      if (result.value) {        console.log(result.value.length) // 有提示      }    })    return {      loading,      result,       errorMsg    }  }}&lt;/script></span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="5-Composition-API-对比Option-API"><a href="#5-Composition-API-对比Option-API" class="headerlink" title="5. Composition API 对比Option API"></a>5. Composition API 对比Option API</h1><h2 id="1-Option-API的问题"><a href="#1-Option-API的问题" class="headerlink" title="1) Option API的问题"></a>1) Option API的问题</h2><ul><li>在传统的Vue OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 ，滚动条反复上下移动</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:67%;"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom: 67%;"><h2 id="2-使用Compisition-API"><a href="#2-使用Compisition-API" class="headerlink" title="2) 使用Compisition API"></a>2) 使用Compisition API</h2><p><strong>关注点分离</strong>：我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:67%;"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:67%;"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c421e5392504ecc94c222057dba338a~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:67%;"><h1 id="6-新组件"><a href="#6-新组件" class="headerlink" title="6. 新组件"></a>6. 新组件</h1><h2 id="1-Fragment-片段"><a href="#1-Fragment-片段" class="headerlink" title="1) Fragment(片段)"></a>1) Fragment(片段)</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><pre class=" language-vue"><code class="language-vue"><template>    <h2>aaaa</h2>    <h2>aaaa</h2></template></code></pre><h2 id="2-Teleport-瞬移"><a href="#2-Teleport-瞬移" class="headerlink" title="2) Teleport(瞬移)"></a>2) Teleport(瞬移)</h2><p>Teleport 提供了一种干净的方法, 让组件的html在父组件界面外的特定标签(很可能是body)下插入显示</p><pre class=" language-vue"><code class="language-vue">// ModalButton.vue<template>  <button @click="modalOpen = true">      Open full screen modal! (With teleport!)  </button>  <teleport to="body">    <div v-if="modalOpen" class="modal">      <div>        I'm a teleported modal!         (My parent is "body")        <button @click="modalOpen = false">          Close        </button>      </div>    </div>  </teleport></template><script>import { ref } from 'vue'export default {  name: 'modal-button',  setup () {    const modalOpen = ref(false)    return {      modalOpen    }  }}</script><style>.modal {  position: absolute;  top: 0; right: 0; bottom: 0; left: 0;  background-color: rgba(0,0,0,.5);  display: flex;  flex-direction: column;  align-items: center;  justify-content: center;}.modal div {  display: flex;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: white;  width: 300px;  height: 300px;  padding: 5px;}</style></code></pre><pre class=" language-vue"><code class="language-vue">// App.vue<template>  <h2>App</h2>  <modal-button></modal-button></template><script lang="ts">import ModalButton from './ModalButton.vue'export default {  setup() {    return {    }  },  components: {    ModalButton  }}</script></code></pre><h2 id="3-Suspense-不确定的"><a href="#3-Suspense-不确定的" class="headerlink" title="3) Suspense(不确定的)"></a>3) Suspense(不确定的)</h2><p>它们允许我们的应用程序在等待异步组件时渲染一些后备内容，可以让我们创建一个平滑的用户体验，常与异步组件搭配使用</p><pre class=" language-vue"><code class="language-vue"><template>  <Suspense>    <template v-slot:default>      <AsyncComp/>      <!-- <AsyncAddress/> -->    </template>    <template v-slot:fallback>      <h1>LOADING...</h1>    </template>  </Suspense></template><script lang="ts">/* 异步组件 + Suspense组件*/// import AsyncComp from './AsyncComp.vue'import AsyncAddress from './AsyncAddress.vue'import { defineAsyncComponent } from 'vue'const AsyncComp = defineAsyncComponent(() => import('./AsyncComp.vue'))export default {  setup() {    return {         }  },  components: {    AsyncComp,    AsyncAddress  }}</script></code></pre><pre class=" language-vue"><code class="language-vue">// AsyncComp.vue<template>  <h2>AsyncComp22</h2>  <p>{{msg}}</p></template><script lang="ts">export default {  name: 'AsyncComp',  setup () {    // return new Promise((resolve, reject) => {    //   setTimeout(() => {    //     resolve({    //       msg: 'abc'    //     })    //   }, 2000)    // })    return {      msg: 'abc'    }  }}</script></code></pre><pre class=" language-vue"><code class="language-vue">// AsyncAddress.vue<template><h2>{{data}}</h2></template><script lang="ts">import axios from 'axios'export default {  async setup() {    const result = await axios.get('/data/address.json')    return {      data: result.data    }  }}</script></code></pre><h1 id="7-其他新的API"><a href="#7-其他新的API" class="headerlink" title="7. 其他新的API"></a>7. 其他新的API</h1><h2 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h2><ul><li>provide和inject提供依赖注入，功能类似 2.x 的provide/inject</li><li>实现跨多层级组件(祖孙)间通信</li></ul><pre class=" language-vue"><code class="language-vue"><template>  <h1>父组件</h1>  <p>当前颜色: {{color}}</p>  <button @click="color='red'">红</button>  <button @click="color='yellow'">黄</button>  <button @click="color='blue'">蓝</button>  <hr>  <Son /></template><script lang="ts">import { provide, ref } from 'vue'import Son from './Son.vue'export default {  name: 'ProvideInject',  components: {    Son  },  setup() {    const color = ref('red')    provide('color', color)    return {      color    }  }}</script><template>  <div>    <h2>子组件</h2>    <hr>    <GrandSon />  </div></template><script lang="ts">import GrandSon from './GrandSon.vue'export default {  components: {    GrandSon  },}</script><template>  <h3 :style="{color}">孙子组件: {{color}}</h3></template><script lang="ts">import { inject } from 'vue'export default {  setup() {    const color = inject('color')    return {      color    }  }}</script></code></pre><h2 id="全新的全局API"><a href="#全新的全局API" class="headerlink" title="全新的全局API"></a>全新的全局API</h2><ul><li>createApp()</li><li>defineProperty()</li><li>defineAsyncComponent()</li><li>nextTick()</li></ul><h2 id="将原来的全局API转移到应用对象"><a href="#将原来的全局API转移到应用对象" class="headerlink" title="将原来的全局API转移到应用对象"></a>将原来的全局API转移到应用对象</h2><ul><li>app.component()</li><li>app.config()</li><li>app.directive()</li><li>app.mount()</li><li>app.unmount()</li><li>app.use()</li></ul><h2 id="模板语法变化"><a href="#模板语法变化" class="headerlink" title="模板语法变化"></a>模板语法变化</h2><ul><li>v-model的本质变化<ul><li>prop：value -&gt; modelValue；</li><li>event：input -&gt; update:modelValue；</li></ul></li><li>.sync修改符已移除, 由v-model代替</li><li>v-if优先v-for解析</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux笔记</title>
      <link href="/13-linux-bi-ji.html"/>
      <url>/13-linux-bi-ji.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门</h1><h2 id="1-Linux介绍"><a href="#1-Linux介绍" class="headerlink" title="1. Linux介绍"></a>1. Linux介绍</h2><ul><li>Linux 是一款免费，开源，安全，高效，稳定，处理高斌发很强悍的操作系统</li><li>Linux创始人——linux（林纳斯）</li><li>Linux主要发行版本</li></ul><p><img src="/archives/13-linux-bi-ji.htm/%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC.jpg" alt="发行版本"></p><h2 id="2-Unix与Linux的关系"><a href="#2-Unix与Linux的关系" class="headerlink" title="2. Unix与Linux的关系"></a>2. Unix与Linux的关系</h2><h3 id="2-1-Unix来源"><a href="#2-1-Unix来源" class="headerlink" title="2.1 Unix来源"></a>2.1 Unix来源</h3><p><img src="/archives/13-linux-bi-ji.htm/unix%E6%9D%A5%E6%BA%90.jpg" alt="unix来源"></p><h3 id="2-2-Linux来源"><a href="#2-2-Linux来源" class="headerlink" title="2.2 Linux来源"></a>2.2 Linux来源</h3><p><img src="/archives/13-linux-bi-ji.htm/Linux%E6%9D%A5%E6%BA%90.jpg" alt="Linux来源"></p><h3 id="2-3-Linux与Unix关系"><a href="#2-3-Linux与Unix关系" class="headerlink" title="2.3 Linux与Unix关系"></a>2.3 Linux与Unix关系</h3><p><img src="/archives/13-linux-bi-ji.htm/Linux%E4%B8%8EUnix%E5%85%B3%E7%B3%BB.jpg" alt="Linux与Unix关系"></p><h3 id="2-4-Linux与Windows关系"><a href="#2-4-Linux与Windows关系" class="headerlink" title="2.4 Linux与Windows关系"></a>2.4 Linux与Windows关系</h3><p><img src="/archives/13-linux-bi-ji.htm/Linux%E4%B8%8EWindows%E5%85%B3%E7%B3%BB.jpg" alt="Linux与Windows关系"></p><h1 id="Linux基本目录机构"><a href="#Linux基本目录机构" class="headerlink" title="Linux基本目录机构"></a>Linux基本目录机构</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li>Linux的文件系统采用级层式子的树状目录结构，</li><li>最上层是根目录“/”</li><li><strong>Linux世界里，一切皆文件。</strong><br><img src="/archives/13-linux-bi-ji.htm/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="目录结构"></li></ul><h2 id="2-目录用途"><a href="#2-目录用途" class="headerlink" title="2. 目录用途"></a>2. 目录用途</h2><ul><li><code>/bin：</code> 是Binary的缩写，最经常<strong>使用的命令</strong>。</li><li><code>/sbin</code>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li><code>/home：</code>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li><code>/root：</code>该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><code>/lib</code>：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li><li><code>/lost+found</code>：这个目录一般情况下是空的，当系统<strong>非法关机</strong>后，这里就存放了一些文件。</li><li><code>/etc</code>：所有的系统管理所需要的配置文件和子目录</li><li>**<code>/usr</code>**：Unix System Resource这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</li><li><code>/boot：</code>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><code>/proc</code>：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</li><li><code>/srv</code>：service的缩写，该目录存放一些服务启动之后需要提供的数据。</li><li><code>/sys</code>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。</li><li><code>/tmp</code>：这个目录是用来存放一些临时文件的。</li><li><code>/dev</code>：类似windows的设备管理器，把所有的硬件用文件的形式存储。</li><li><code>/media：</code>linux系统会自动识别一些设备，例如U盘光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li><code>/mnt：</code>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。</li><li><code>/opt：</code>这是给主机额外安装软件所摆放的目录，如安装ORACLE数据库就可放到该目录下。默认为空。</li><li><code>/usr/local</code>：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。</li><li><code>/var：</code>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</li><li><code>/selinux</code>：SELinux是一种安全子系统(Security Enhance Linux)，它能控制程序只能访问特定文件。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ol><li>Linux的目录中有且只有一个根目录。</li><li>Linux的各个目录存放的内容是规划好，不要乱放文件。</li><li>Linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。</li><li>Linux的各个文件目录下存放什么内容，目录结构必须有一个认识。</li></ol><h1 id="3-1远程登录Linux系统"><a href="#3-1远程登录Linux系统" class="headerlink" title="3.1远程登录Linux系统"></a>3.1远程登录Linux系统</h1><h2 id="1-远程登录方法"><a href="#1-远程登录方法" class="headerlink" title="1. 远程登录方法"></a>1. 远程登录方法</h2><h3 id="1-1Xshell"><a href="#1-1Xshell" class="headerlink" title="1.1Xshell"></a>1.1Xshell</h3><ul><li>可用Xshell等软件输入主机的IP地址，登录名链接</li></ul><h3 id="1-2ssh"><a href="#1-2ssh" class="headerlink" title="1.2ssh"></a>1.2ssh</h3><ul><li>链接指令 ssh -p 22 [登录用户]@[地址]</li></ul><h2 id="2-Xftp文件传输"><a href="#2-Xftp文件传输" class="headerlink" title="2. Xftp文件传输"></a>2. Xftp文件传输</h2><ul><li>主要用于向服务上传或下载文件</li></ul><p>ip地址查询： <code>ifconfig</code></p><h1 id="vi和vim编辑器"><a href="#vi和vim编辑器" class="headerlink" title="vi和vim编辑器"></a>vi和vim编辑器</h1><h2 id="1-vi和vim的基本介绍"><a href="#1-vi和vim的基本介绍" class="headerlink" title="1. vi和vim的基本介绍"></a>1. vi和vim的基本介绍</h2><ul><li>所有Linux系统都会内置vi文本编辑器</li><li>vim是vi的升级版，可以主动以字体颜色分辨语法的正确性，代码补完和编译，错误跳转等功能。</li></ul><h2 id="2-vi和vim的三种模式"><a href="#2-vi和vim的三种模式" class="headerlink" title="2. vi和vim的三种模式"></a>2. vi和vim的三种模式</h2><h3 id="2-1-正常模式"><a href="#2-1-正常模式" class="headerlink" title="2.1 正常模式"></a>2.1 正常模式</h3><ul><li>在正常模式下，我们<strong>可以使用快捷键</strong>。</li><li>用vim打开一个文件就直接进入一般模式</li><li>可以使用【删除字符】或【删除整行】来处理文档内容，也可以使用【复制黏贴按钮】</li></ul><h3 id="2-2-插入-编辑模式"><a href="#2-2-插入-编辑模式" class="headerlink" title="2.2 插入/编辑模式"></a>2.2 插入/编辑模式</h3><ul><li>在这个模式下，可以编辑文件内容。</li><li>按下i,I,o,O,a,A,r,R等字母就可进入编辑模式</li></ul><h3 id="2-3-命令行模式"><a href="#2-3-命令行模式" class="headerlink" title="2.3 命令行模式"></a>2.3 命令行模式</h3><ul><li>在这个模式中，可以利用指令完成读取，存盘，替换，离开，显示行号的等动作。</li><li>wq保存退出</li><li>q无修改直接退出</li><li>q!不保存修改直接退出</li></ul><h3 id="2-4-三种模式转换示意图"><a href="#2-4-三种模式转换示意图" class="headerlink" title="2.4 三种模式转换示意图"></a>2.4 三种模式转换示意图</h3><p><img src="/archives/13-linux-bi-ji.htm/3.2vim%E6%A8%A1%E5%BC%8F%E8%BD%AC%E6%8D%A2.jpg" alt="3.2vim模式转换.jpg"></p><h2 id="3-Vim-的常见指令案例"><a href="#3-Vim-的常见指令案例" class="headerlink" title="3. Vim 的常见指令案例"></a>3. Vim 的常见指令案例</h2><ol><li>yy：拷贝当前行</li><li>5yy：拷贝当前5行</li><li>p: 粘贴</li><li>dd：删除当前行</li><li>5dd：删除当前行向下的5行</li><li>在文件中查找某个单词：命令行输入 <code>/（查找内容）</code>，按n查找下一个</li><li>设置文件行号：:set nu，取消文件行号：:set nonu</li><li>光标移动到某行：shift+g</li><li>编辑文件，正常模式下使用快捷键到达文档最末行：G，最首行：gg</li><li>撤销输入：在正常模式下输入u</li></ol><h2 id="4-vim其他常见指令补充"><a href="#4-vim其他常见指令补充" class="headerlink" title="4. vim其他常见指令补充"></a>4. vim其他常见指令补充</h2><h3 id="4-1-文件命令"><a href="#4-1-文件命令" class="headerlink" title="4.1 文件命令"></a>4.1 文件命令</h3><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>vim [file1 file2 file3 …]</td><td>打开单个或多个文件</td></tr><tr><td>:open file</td><td>在vim窗口中打开一个新文件</td></tr><tr><td>:split file</td><td>在新窗口中打开文件（split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。）</td></tr><tr><td>Ctrl+ww</td><td>移动到下一个窗口</td></tr><tr><td>Ctrl+wj</td><td>移动到下方的窗口</td></tr><tr><td>Ctrl+wk</td><td>移动到上方的窗口</td></tr><tr><td>:close</td><td>最后一个窗口不能使用此命令，可以防止意外退出vim。</td></tr><tr><td>:only</td><td>关闭所有窗口，只保留当前窗口</td></tr><tr><td>:bn</td><td>切换到下一个文件</td></tr><tr><td>:bp</td><td>切换到上一个文件</td></tr><tr><td>:args</td><td>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来</td></tr><tr><td>:e <a href="ftp://192.168.10.76/abc.txt">ftp://192.168.10.76/abc.txt</a></td><td>打开远程文件，比如ftp或者share folder</td></tr></tbody></table><h3 id="4-2-普通模式"><a href="#4-2-普通模式" class="headerlink" title="4.2 普通模式"></a>4.2 普通模式</h3><h4 id="4-2-1-插入命令"><a href="#4-2-1-插入命令" class="headerlink" title="4.2.1 插入命令"></a>4.2.1 插入命令</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>在当前位置生前插入</td></tr><tr><td>I</td><td>在当前行首插入</td></tr><tr><td>a</td><td>在当前位置后插入</td></tr><tr><td>A</td><td>在当前行尾插入</td></tr><tr><td>o</td><td>在当前行之后插入一行</td></tr><tr><td>O</td><td>在当前行之前插入一行</td></tr></tbody></table><h4 id="4-2-2-游标移动"><a href="#4-2-2-游标移动" class="headerlink" title="4.2.2 游标移动"></a>4.2.2 游标移动</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>gg</td><td>移动到文件头。 = [[</td></tr><tr><td>G（shift + g）</td><td>移动到文件尾。 = ]]</td></tr><tr><td>行数 → G</td><td>移动到第 n 行</td></tr><tr><td>冒号+行号，回车</td><td>比如跳到240行就是 :240回车</td></tr><tr><td>h</td><td>左移一个字符</td></tr><tr><td>l</td><td>右移一个字符，这个命令很少用，一般用w代替。</td></tr><tr><td>k</td><td>上移一个字符</td></tr><tr><td>j</td><td>下移一个字符</td></tr><tr><td>w</td><td>向前移动一个单词（光标停在单词首部）</td></tr><tr><td>b</td><td>向后移动一个单词 2b 向后移动2个单词</td></tr><tr><td>e</td><td>同w，只不过是光标停在单词尾部</td></tr><tr><td>ge</td><td>同b，光标停在单词尾部。</td></tr><tr><td>^</td><td>移动到本行第一个非空白字符上。</td></tr><tr><td>0</td><td>移动到本行第一个字符上</td></tr><tr><td>HOME</td><td>移动到本行第一个字符。同0健。</td></tr><tr><td>$</td><td>移动到行尾 3$ 移动到下面3行的行尾</td></tr><tr><td>f（find）</td><td>fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</td></tr><tr><td>F</td><td>同f，反向查找</td></tr></tbody></table><h4 id="4-2-3-撤销和重做"><a href="#4-2-3-撤销和重做" class="headerlink" title="4.2.3 撤销和重做"></a>4.2.3 撤销和重做</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>u</td><td>撤销（Undo）</td></tr><tr><td>U</td><td>撤销对整行的操作</td></tr><tr><td>Ctrl + r</td><td>重做（Redo），即撤销的撤销。</td></tr></tbody></table><h4 id="4-2-4-删除命令"><a href="#4-2-4-删除命令" class="headerlink" title="4.2.4 删除命令"></a>4.2.4 删除命令</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除当前字符</td></tr><tr><td>3x</td><td>删除当前光标开始向后三个字符</td></tr><tr><td>X</td><td>删除当前字符的前一个字符。X=dh</td></tr><tr><td>dl</td><td>删除当前字符， dl=x</td></tr><tr><td>dh</td><td>删除前一个字符</td></tr><tr><td>dd</td><td>删除当前行</td></tr><tr><td>dj</td><td>删除上一行</td></tr><tr><td>dk</td><td>删除下一行</td></tr><tr><td>10d</td><td>删除当前行开始的10行。</td></tr><tr><td>D</td><td>删除当前字符至行尾。D=d$</td></tr><tr><td>d$</td><td>删除当前字符之后的所有字符（本行）</td></tr><tr><td>kdgg</td><td>删除当前行之前所有行（不包括当前行）</td></tr><tr><td>jdG（jd shift + g）</td><td>删除当前行之后所有行（不包括当前行）</td></tr><tr><td>:1,10d</td><td>删除1-10行</td></tr><tr><td>:11,$d</td><td>删除11行及以后所有的行</td></tr><tr><td>:1,$d</td><td>删除所有行</td></tr><tr><td>J(shift + j)</td><td>删除两行之间的空行，实际上是合并两行。</td></tr></tbody></table><h4 id="4-2-5-拷贝，剪贴和粘贴"><a href="#4-2-5-拷贝，剪贴和粘贴" class="headerlink" title="4.2.5 拷贝，剪贴和粘贴"></a>4.2.5 拷贝，剪贴和粘贴</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>yy</td><td>拷贝当前行</td></tr><tr><td>nyy</td><td>拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</td></tr><tr><td>p</td><td>在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</td></tr><tr><td>shift+p</td><td>在当前行前粘贴</td></tr><tr><td>:1,10 co 20</td><td>将1-10行插入到第20行之后。</td></tr><tr><td>:1,$ co $</td><td>将整个文件复制一份并添加到文件尾部。</td></tr><tr><td>ddp</td><td>交换当前行和其下一行</td></tr><tr><td>xp</td><td>交换当前字符和其后一个字符</td></tr><tr><td>ndd</td><td>剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</td></tr><tr><td>:1,10d</td><td>将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</td></tr><tr><td>:1, 10 m 20</td><td>将第1-10行移动到第20行之后。</td></tr></tbody></table><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</p><h4 id="4-2-6-退出命令"><a href="#4-2-6-退出命令" class="headerlink" title="4.2.6 退出命令"></a>4.2.6 退出命令</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>:wq</td><td>保存并退出</td></tr><tr><td>ZZ</td><td>保存并退出</td></tr><tr><td>:q!</td><td>强制退出并忽略所有更改</td></tr><tr><td>:e!</td><td>放弃所有修改，并打开原来文件。</td></tr><tr><td>:q</td><td>未修改直接退出</td></tr></tbody></table><h4 id="4-2-7-注释命令"><a href="#4-2-7-注释命令" class="headerlink" title="4.2.7 注释命令"></a>4.2.7 注释命令</h4><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>3,5 s/^/#/g</td><td>注释第3-5行</td></tr><tr><td>3,5 s/^#//g</td><td>解除3-5行的注释</td></tr><tr><td>1,$ s/^/#/g</td><td>注释整个文档。</td></tr><tr><td>:%s/^/#/g</td><td>注释整个文档，此法更快。</td></tr></tbody></table><h3 id="4-3-执行shell命令"><a href="#4-3-执行shell命令" class="headerlink" title="4.3 执行shell命令"></a>4.3 执行shell命令</h3><ul><li>:! command</li></ul><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>:!ls</td><td>列出当前目录下文件</td></tr><tr><td>:!perl -c script.pl</td><td>检查perl脚本语法，可以不用退出vim，非常方便。</td></tr><tr><td>:!perl script.pl</td><td>执行perl脚本，可以不用退出vim，非常方便。</td></tr><tr><td>:suspend或Ctrl - Z</td><td>挂起vim，回到shell，按fg可以返回vim。</td></tr></tbody></table><h3 id="4-4-帮助命令"><a href="#4-4-帮助命令" class="headerlink" title="4.4 帮助命令"></a>4.4 帮助命令</h3><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>:help or F1</td><td>显示整个帮助</td></tr><tr><td>:help xxx</td><td>显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。</td></tr><tr><td>:help ‘number’</td><td>Vim选项的帮助用单引号括起</td></tr><tr><td>:help &lt;Esc&gt;</td><td>特殊键的帮助用&lt;&gt;扩起</td></tr><tr><td>:help -t</td><td>Vim启动参数的帮助用-</td></tr><tr><td>：help i_&lt;Esc&gt;</td><td>插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式</td></tr></tbody></table><p>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</p><h3 id="4-5-其他非编辑命令"><a href="#4-5-其他非编辑命令" class="headerlink" title="4.5 其他非编辑命令"></a>4.5 其他非编辑命令</h3><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>重复前一次命令</td></tr><tr><td>:set ruler?</td><td>查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</td></tr><tr><td>:scriptnames</td><td>查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</td></tr><tr><td>:set list</td><td>显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了 expandtab，那么tab将被扩展为空格。</td></tr></tbody></table><ul><li><p>Vim教程</p><ul><li>在Unix系统上 $ vimtutor</li><li>在Windows系统上 :help tutor</li></ul></li><li><p>录制宏:</p><ul><li>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</li></ul></li><li><p>:syntax 列出已经定义的语法项</p></li><li><p>:syntax clear 清除已定义的语法规则</p></li><li><p>:syntax case match 大小写敏感，int和Int将视为不同的语法元素</p></li><li><p>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p></li></ul><h2 id="5-Vim拓展教程"><a href="#5-Vim拓展教程" class="headerlink" title="5. Vim拓展教程"></a>5. Vim拓展教程</h2><p><a href="https://www.runoob.com/linux/linux-vim.html">菜鸟教程vim链接</a></p><h1 id="关机、重启和用户登录注销"><a href="#关机、重启和用户登录注销" class="headerlink" title="关机、重启和用户登录注销"></a>关机、重启和用户登录注销</h1><h2 id="1-关机-amp-重启命令"><a href="#1-关机-amp-重启命令" class="headerlink" title="1. 关机&amp;重启命令"></a>1. 关机&amp;重启命令</h2><h3 id="1-1-shutdown"><a href="#1-1-shutdown" class="headerlink" title="1.1 shutdown"></a>1.1 shutdown</h3><ul><li>shutdown -h now：表示立即关机</li><li>shutdown -h 1：表示1分钟后关机</li><li>shutdown -r now：立即重启</li></ul><h3 id="1-2-halt"><a href="#1-2-halt" class="headerlink" title="1.2 halt"></a>1.2 halt</h3><ul><li>halt：直接使用，关机</li></ul><h3 id="1-3-reboot"><a href="#1-3-reboot" class="headerlink" title="1.3 reboot"></a>1.3 reboot</h3><ul><li>reboot 重启系统</li></ul><h3 id="1-4-sync"><a href="#1-4-sync" class="headerlink" title="1.4 sync"></a>1.4 sync</h3><ul><li>sync：把内存的数据同步到磁盘上</li></ul><blockquote><p>当我们关机或者重启时，都应该先执行一下sync，防止数据丢失。</p></blockquote><h2 id="2-用户登录注销"><a href="#2-用户登录注销" class="headerlink" title="2. 用户登录注销"></a>2. 用户登录注销</h2><ul><li>登录时少用root账号登录，以避免操作失误的损失</li><li>平时可登录普通账户，再用“<strong>su - 用户名</strong>”切换成管理员登录</li></ul><h3 id="2-1-logout"><a href="#2-1-logout" class="headerlink" title="2.1 logout"></a>2.1 logout</h3><ul><li>logout：注销用户</li></ul><blockquote><p>在图形运行级别无效，在运行级别3有效。</p></blockquote><h2 id="1-基本用户管理"><a href="#1-基本用户管理" class="headerlink" title="1. 基本用户管理"></a>1. 基本用户管理</h2><blockquote><ul><li>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</li><li>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</li><li>每个用户账号都拥有一个唯一的用户名和各自的口令。</li><li>要完成的工作主要有如下几个方面：<ul><li>用户账号的添加、删除与修改。</li><li>用户口令的管理。</li><li>用户组的管理。</li></ul></li></ul></blockquote><h3 id="1-1-添加用户"><a href="#1-1-添加用户" class="headerlink" title="1.1 添加用户"></a>1.1 添加用户</h3><blockquote><p>添加用户：<code>useradd [选项] 用户名</code>。</p></blockquote><h4 id="1-1-1-参数说明"><a href="#1-1-1-参数说明" class="headerlink" title="1.1.1 参数说明"></a>1.1.1 参数说明</h4><ul><li>选项:<ul><li>-c comment 指定一段注释性描述。</li><li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，指定用户所属的附加组。</li><li>-s Shell文件 指定用户的登录Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li><li>-f 缓冲天数 指定在密码过期后多少天即关闭该帐号。</li><li>-e 有效期限 指定帐号的有效期限；</li><li>-M：不要自动建立用户的登入目录；</li></ul></li></ul><h3 id="1-2-用户口令的管理"><a href="#1-2-用户口令的管理" class="headerlink" title="1.2 用户口令的管理"></a>1.2 用户口令的管理</h3><blockquote><p>指定和修改用户口令: <code>passwd 选项 用户名</code></p></blockquote><h4 id="1-2-1-参数说明"><a href="#1-2-1-参数说明" class="headerlink" title="1.2.1 参数说明"></a>1.2.1 参数说明</h4><ul><li>选项：<ul><li>-l 锁定口令，即禁用账号。</li><li>-u 口令解锁。</li><li>-d 使账号无口令(密码)。</li><li>-f 强迫用户下次登录时修改口令。</li></ul></li></ul><h4 id="1-2-2-注意事项"><a href="#1-2-2-注意事项" class="headerlink" title="1.2.2 注意事项"></a>1.2.2 注意事项</h4><ul><li>如果默认用户名，则修改当前用户的口令。<ul><li>假设当前用户是sam，则下面的命令修改该用户自己的口令：passwd sam</li></ul></li><li>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；</li><li>超级用户为用户指定口令时，就不需要知道原口令。</li></ul><h3 id="1-3-删除帐号"><a href="#1-3-删除帐号" class="headerlink" title="1.3 删除帐号"></a>1.3 删除帐号</h3><blockquote><p>删除帐号: <code>userdel 选项 用户名</code></p></blockquote><h4 id="1-3-1-注意事项"><a href="#1-3-1-注意事项" class="headerlink" title="1.3.1 注意事项"></a>1.3.1 注意事项</h4><ul><li>常用的选项是 -r，它的作用是把用户的主目录一起删除。<ul><li>userdel -r sam</li></ul></li></ul><h3 id="1-4-修改帐号"><a href="#1-4-修改帐号" class="headerlink" title="1.4 修改帐号"></a>1.4 修改帐号</h3><blockquote><p>修改已有用户的信息: <code>usermod 选项 用户名</code></p></blockquote><h4 id="1-4-1-注意事项"><a href="#1-4-1-注意事项" class="headerlink" title="1.4.1 注意事项"></a>1.4.1 注意事项</h4><ul><li>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</li></ul><h3 id="1-5-查询用户信息"><a href="#1-5-查询用户信息" class="headerlink" title="1.5 查询用户信息"></a>1.5 查询用户信息</h3><ul><li>查询用户信息: <code>id 用户名</code><ul><li>用户不存在是返回“无此用户”</li></ul></li><li>查看当前用户/登录用户：who am i</li></ul><h3 id="1-6-切换用户"><a href="#1-6-切换用户" class="headerlink" title="1.6 切换用户"></a>1.6 切换用户</h3><ul><li>切换用户：<code>su 用户名</code><ul><li>从权限高切换到权限低的用户不需要输密码。</li><li>返回切换前的用户：<code>exit</code></li><li>查看原来的用户：<code>who am i</code></li></ul></li></ul><h2 id="2-用户组的管理"><a href="#2-用户组的管理" class="headerlink" title="2. 用户组的管理"></a>2. 用户组的管理</h2><blockquote><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。<br>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p></blockquote><h3 id="2-1-增加一个新的用户组"><a href="#2-1-增加一个新的用户组" class="headerlink" title="2.1 增加一个新的用户组"></a>2.1 增加一个新的用户组</h3><blockquote><p>增加一个新的用户组: <code>groupadd 选项 用户组</code></p></blockquote><h4 id="2-1-1-说明"><a href="#2-1-1-说明" class="headerlink" title="2.1.1 说明"></a>2.1.1 说明</h4><ul><li>选项有：<ul><li>-g GID 指定新用户组的组标识号（GID）。</li><li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li></ul></li></ul><h4 id="2-1-2-案例"><a href="#2-1-2-案例" class="headerlink" title="2.1.2 案例"></a>2.1.2 案例</h4><p>groupadd -g 101 group2</p><ul><li>向系统中增加了一个新组group2，同时指定新组的组标识号是101。</li></ul><h3 id="2-2-修改用户组"><a href="#2-2-修改用户组" class="headerlink" title="2.2 修改用户组"></a>2.2 修改用户组</h3><blockquote><p>修改用户组: groupmod 选项 用户组</p></blockquote><h4 id="2-1-2-说明"><a href="#2-1-2-说明" class="headerlink" title="2.1.2 说明"></a>2.1.2 说明</h4><ul><li>选项有：<ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul></li></ul><h4 id="2-1-3-案例"><a href="#2-1-3-案例" class="headerlink" title="2.1.3 案例"></a>2.1.3 案例</h4><ol><li>groupmod -g 102 group2<ul><li>将组group2的组标识号修改为102。</li></ul></li><li>groupmod –g 10000 -n group3 group2<ul><li>将组group2的标识号改为10000，组名修改为group3。</li></ul></li></ol><h3 id="2-3-组的切换"><a href="#2-3-组的切换" class="headerlink" title="2.3 组的切换"></a>2.3 组的切换</h3><blockquote><p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p><p><code>newgrp root</code></p><ul><li>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</li></ul></blockquote><h2 id="3-与用户账号有关的系统文件"><a href="#3-与用户账号有关的系统文件" class="headerlink" title="3. 与用户账号有关的系统文件"></a>3. 与用户账号有关的系统文件</h2><h3 id="3-1-etc-passwd-文件"><a href="#3-1-etc-passwd-文件" class="headerlink" title="3.1 /etc/passwd 文件"></a>3.1 /etc/<strong>passwd 文件</strong></h3><blockquote><p>用户（user）的配置文件，记录用户的各种信息。</p></blockquote><ul><li><p>每行的含义：</p><ol><li><p>“用户名”是代表用户账号的字符串。</p><ul><li>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</li><li>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</li></ul></li><li><p>“口令”一些系统中，存放着加密后的用户口令字。</p><ul><li>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</li></ul></li><li><p>“用户标识号”是一个整数，系统内部用它来标识用户。</p><ul><li>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</li><li>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</li></ul></li><li><p>“组标识号”字段记录的是用户所属的用户组。</p><ul><li>它对应着/etc/group文件中的一条记录。</li></ul></li><li><p>“注释性描述”字段记录着用户的一些个人情况。</p><ul><li>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</li></ul></li><li><p>“主目录”，也就是用户的起始工作目录。</p><ul><li>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</li></ul></li><li><p>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p><ul><li>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</li><li>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</li><li>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。<ul><li>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</li></ul></li></ul></li><li><p>系统中有一类用户称为伪用户（pseudo users）。</p><ul><li>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</li></ul><p><img src="/archives/13-linux-bi-ji.htm/3.4etcpasswd%E6%96%87%E4%BB%B6.jpg" alt="3.4etcpasswd文件.jpg"></p></li></ol></li></ul><h3 id="3-2-etc-shadow-文件"><a href="#3-2-etc-shadow-文件" class="headerlink" title="3.2 /etc/shadow 文件"></a>3.2 /etc/<strong>shadow 文件</strong></h3><blockquote><p>口令配置文件                                                      </p></blockquote><ul><li><p>每行的含义：</p><ol><li><p>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</p></li><li><p>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</p></li><li><p>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</p></li><li><p>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</p></li><li><p>“最大时间间隔”指的是口令保持有效的最大天数。</p></li><li><p>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</p></li><li><p>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</p></li><li><p>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</p><p><img src="/archives/13-linux-bi-ji.htm/3.4etcshadow.jpg" alt="3.4etcshadow.jpg"></p></li></ol></li></ul><h3 id="3-3-etc-group-文件"><a href="#3-3-etc-group-文件" class="headerlink" title="3.3 /etc/group 文件"></a>3.3 /etc/<strong>group 文件</strong></h3><blockquote><p>组（group）的配置文件，用户组的所有信息都存放在/etc/group文件中。</p></blockquote><ul><li><p>每行含义：</p><ol><li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li><li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li><li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li><li>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li></ol><p><img src="/archives/13-linux-bi-ji.htm/3.4etcgroup.jpg" alt="3.4etcgroup.jpg"></p></li></ul><h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h2 id="1-指定运行级别（7个级别）"><a href="#1-指定运行级别（7个级别）" class="headerlink" title="1. 指定运行级别（7个级别）"></a>1. 指定运行级别（7个级别）</h2><ul><li>0.关机</li><li>1.单用户【找回丢失密码】</li><li>2.多用户状态没有网络服务(少用)</li><li>3.<strong>多用户状态有网络服务(最常用)</strong></li><li>4.系统未使用保留给用户</li><li>5.图形界面</li><li>6.系统重启</li></ul><img src="/archives/13-linux-bi-ji.htm/%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB.PNG" alt="运行级别" style="zoom:50%;"><p>系统的运行级别配置文件：/etc/inittab<br><img src="/archives/13-linux-bi-ji.htm/3.5%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB%E6%8C%87%E4%BB%A4.jpg" alt="3.5运行级别指令.jpg"></p><p>切换到指定运行级别的指令：<code>init 级别</code></p><p>或在开机显示<code>press any ...</code> 的时候按<code>e</code>以修改</p><h2 id="2-帮助指令"><a href="#2-帮助指令" class="headerlink" title="2. 帮助指令"></a>2. 帮助指令</h2><h3 id="2-1-man获得帮助信息"><a href="#2-1-man获得帮助信息" class="headerlink" title="2.1 man获得帮助信息"></a>2.1 man获得帮助信息</h3><p>​        <code>man [命令或配置文件]</code></p><ul><li>例如:man ls</li></ul><h3 id="2-2-help指令"><a href="#2-2-help指令" class="headerlink" title="2.2 help指令"></a>2.2 help指令</h3><p>​        <code>help [命令或配置文件]</code></p><h2 id="3-文件目录类指令"><a href="#3-文件目录类指令" class="headerlink" title="3. 文件目录类指令"></a>3. 文件目录类指令</h2><h3 id="3-1-文件剪贴删除复制重名等"><a href="#3-1-文件剪贴删除复制重名等" class="headerlink" title="3.1 文件剪贴删除复制重名等"></a>3.1 文件剪贴删除复制重名等</h3><ul><li><p><code>pwd</code>：Print Working Directory，显示当前工作目录的绝对路径。</p></li><li><p><code>ls</code>：-a：显示当前目录所有的文件和目录，包括隐藏的；</p><ul><li>-l：以列表的方式显示详细信息(简写<code>ll</code>)。</li></ul></li><li><p><code>cd</code>：cd ：回到自己的家目录；cd …：回到当前目录的上一级目录。</p></li><li><p><code>mkdir</code>：创建目录；<code>-p</code>：创建多级目录</p></li><li><p><code>rmdir</code>：删除空目录。rmdir不能删除非空的目录。如果<strong>需要删除非空的目录，需要使用<code>rm -rf</code></strong></p></li><li><p><code>cp [选项] source dest</code>：拷贝文件到指定目录；</p><ul><li><p><code>-r</code>：recursive递归<strong>复制整个文件夹</strong>。</p></li><li><p>强制覆盖所有文件：cp命令改为<code>\cp</code></p></li></ul></li></ul><ul><li><p><code>rm</code>：移除文件或目录；</p><ul><li><code>-r</code>：递归删除整个文件夹；</li><li><code>-f</code>：强制删除不提示。</li></ul></li><li><p><code>mv</code>：<strong>移动</strong>文件与目录或<strong>重命名</strong>，两种功能！</p></li><li><p><code>touch</code>：创建空文件。<strong>可以一次性创建多个文件</strong></p></li><li><p><code>ln -s[源文件或目录][软连接名]</code>： 给文件创建一个软连接</p><p>​            注意：使用<code>pwd</code>查看软连接时，仍然是软连接创建所在的目录</p></li></ul><h3 id="3-2-文件查看"><a href="#3-2-文件查看" class="headerlink" title="3.2 文件查看"></a>3.2 文件查看</h3><ul><li><code>cat</code>：查看文件内容, <strong>只读</strong><ul><li><code>-n</code>：显示行号。</li><li>结尾加上 <code>| more</code>：分页显示，不会全部一下显示完。</li></ul></li><li><code>more</code>：是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more还内置了很多快捷键：<ul><li><code>空白键（Space）</code>：向下翻一页</li><li><code>Enter</code>：向下翻一行</li><li><code>q</code>：立刻离开more，不再显示该文件内容</li><li><code>Ctrl + F</code>：(forward)向下滚动一屏</li><li><code>Ctrl + B</code>：(backward返回上一屏</li><li><code>=</code> :输出当前行的行号</li><li><code>:f</code> 输出文件名和当前行的行号</li></ul></li><li><code>less</code>：<strong>懒加载</strong>，用来分屏查看文件内容，与more相似，但是更强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容。对于显示大型文件具有较高的效率。</li><li><code>head</code>：显示文件的开头部分。-n 5：看前面5行内容。</li><li><code>tail</code>：输出文件中尾部的内容。<ul><li>-n 5：看后面5行内容。</li><li><code>-f</code>：时事追踪该文档的所有更新(常用)</li></ul></li><li><code>&gt;</code>指令：输出重定向。如果不存在会创建文件，否则会将原来的文件内容覆盖。</li><li><code>&gt;&gt;</code>指令：追加。如果不存在会创建文件，否则不会覆盖原来的文件内容，而是追加到文件的尾部。</li><li><code>echo</code>：输出内容到控制台。</li><li><code>history</code>：查看历史指令</li></ul><h3 id="3-3-时间和日期"><a href="#3-3-时间和日期" class="headerlink" title="3.3 时间和日期"></a>3.3 时间和日期</h3><ul><li><code>date</code>：显示当前日期和时间<ul><li><code>date “+%Y”</code>：显示当前年份</li><li><code>date “+%d”</code>：显示当前月份</li><li><code>date “+%Y-%m-%d %H:%M:%S”</code>：显示年-月-日 时：分：秒</li><li>设置日期：<code>date -s 字符串时间</code></li></ul></li><li><code>cal [月] [年份]</code>：显示某一年或月的日历</li></ul><h3 id="3-4-搜索查找类"><a href="#3-4-搜索查找类" class="headerlink" title="3.4 搜索查找类"></a>3.4 搜索查找类</h3><ul><li><code>find</code>：从指定目录向下递归的遍历其各个子目录，将满足条件的文件或者目录显示在终端。<ul><li><code>find (搜索范围) -name [文件名/*]</code>：按照指定的文件名查找模式查找文件。</li><li><code>find (搜索范围) -user[用户名]</code>：按照指定的用户名查找模式查找文件。</li><li><code>find (搜索范围) -size [+多少/-多少/多少]</code>：按照指定的文件大小查找模式查找文件（大于多少/小于多少/等于多少）</li><li>查询 /目录下所有.txt的文件：find / -name *.txt</li></ul></li><li><code>locate [搜索文件]</code><ul><li>可以快速定位文件路径。lococate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。</li><li>locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</li><li>在第一次运行之前，必须使用<code>updatedb</code>指令创建locate数据库。</li></ul></li><li>grep：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理。经常跟管道 <code>|</code> 一起使用。<ul><li><code>grep [选项] 查找内容 源文件</code></li><li><code>-n</code>：显示匹配行及行号。</li><li><code>-i</code>：忽略大小写字母。</li><li>cat hello.txt | grep yes</li></ul></li></ul><h3 id="3-5-压缩和解压类"><a href="#3-5-压缩和解压类" class="headerlink" title="3.5 压缩和解压类"></a>3.5 压缩和解压类</h3><ul><li>gzip/gunzip：压缩文件/解压<ul><li><code>gzip [文件]</code>：压缩为.gz文件，原来文件不保留。</li><li><code>gunzip [文件]</code>：解压缩，同样也不保留源文件。</li></ul></li><li>zip/unzip：压缩文件/解压<ul><li><code>zip [选项] [压缩后文件xxx.zip] [将要压缩的文件]</code></li><li><code>unzip [选项] [要解压的文件xxx.zip]</code></li><li><code>zip -r</code>：递归压缩，即<strong>压缩目录</strong></li><li><code>unzip -d (目录)</code>：指定解压后的文件的存放目录</li></ul></li><li>tar：打包指令，最后打包后的文件是.tar.gz的文件<ul><li><code>tar [选项] xxx.tar.gz (打包的内容)</code></li><li><code>-c</code>：产生.tar打包文件</li><li>-x：解压.tar文件</li><li><code>-v</code>：显示详细信息</li><li><code>-f</code>：指定压缩后的文件名</li><li><code>-z</code>：打包同时压缩</li><li>压缩：<code>tar -zcvf (压缩后文件名) (要压缩的文件)</code></li><li>解压：<code>tar -zxvf (要解压的文件)</code></li><li>解压到指定目录：<code>tar -zxvf (要解压的文件) -C (指定目录)</code>，指定解压到的目录要存在。</li></ul></li></ul><h2 id="4-更多命令"><a href="#4-更多命令" class="headerlink" title="4. 更多命令+"></a>4. 更多命令+</h2><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux命令大全</a></p><h1 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h1><h2 id="1-Linux组基本介绍"><a href="#1-Linux组基本介绍" class="headerlink" title="1. Linux组基本介绍"></a>1. Linux组基本介绍</h2><ul><li>Linux中每个用户属于一个组，不能独立于组以外。所以在Linux中每个文件存在组的概念：<ol><li>所有者</li><li>所在组</li><li>其他组</li><li>改变用户所在组</li></ol></li></ul><h2 id="2-文件-目录所有者"><a href="#2-文件-目录所有者" class="headerlink" title="2. 文件/目录所有者"></a>2. 文件/目录所有者</h2><blockquote><p>一般为文件的创建者，谁创建了该文件，就自然的称为该文件的所有者。</p></blockquote><ul><li>查看文件所有者：<code>ls -ahl</code></li><li>修改文件所有者：<code>chown (用户名) (文件名)</code></li></ul><h2 id="3-文件-目录所在组"><a href="#3-文件-目录所在组" class="headerlink" title="3. 文件/目录所在组"></a>3. 文件/目录所在组</h2><blockquote><p>当某个用户创建了一个文件之后，默认之歌文件所在组就是该用户所在的组</p></blockquote><p>​        修改文件所在组：<code>chgrp (组名) (文件名)</code></p><h2 id="4-其他组"><a href="#4-其他组" class="headerlink" title="4. 其他组"></a>4. 其他组</h2><p>​        除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组</p><h2 id="5-文件属性"><a href="#5-文件属性" class="headerlink" title="5. 文件属性"></a>5. 文件属性</h2><ul><li>ls -l中显示的内容如图所示<br><img src="/archives/13-linux-bi-ji.htm/3.6%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.jpg" alt="3.6文件属性.jpg"></li></ul><ol><li>在Linux中第一个字符代表这个文件的类型。<ul><li>当为[ d ]则是目录</li><li>当为[ - ]则是文件；</li><li>若是[ l ]则表示为链接文档(link file)；</li><li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul></li><li>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。**[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)**。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。<br>每个文件的属性由左边第一部分的10个字符来确定（如下图）。<br> <img src="/archives/13-linux-bi-ji.htm/3.6%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png" alt="文件权限"></li></ol><h3 id="5-1-rwx权限详解"><a href="#5-1-rwx权限详解" class="headerlink" title="5.1 rwx权限详解"></a>5.1 rwx权限详解</h3><ul><li>rwx作用到文件：<ul><li>r：read，可读。读取查看。</li><li>w：write，可以修改。但不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。</li><li>x：execute，可执行。可以被执行。</li></ul></li><li>rwx作用到目录：<ul><li>r：可以读取，ls查看目录内容。</li><li>w：可以修改，目录内创建+删除+重命名目录。</li><li>x：可执行，可以进入该目录。</li></ul></li></ul><h3 id="5-2-修改权限"><a href="#5-2-修改权限" class="headerlink" title="5.2 修改权限"></a>5.2 修改权限</h3><h4 id="5-2-1-chgrp：更改文件属组"><a href="#5-2-1-chgrp：更改文件属组" class="headerlink" title="5.2.1 chgrp：更改文件属组"></a>5.2.1 chgrp：更改文件属组</h4><ul><li>chgrp [-R] 属组名 文件名<ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul></li></ul><h4 id="5-2-2-chown：更改文件属主，也可以同时更改文件属组"><a href="#5-2-2-chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="5.2.2 chown：更改文件属主，也可以同时更改文件属组"></a>5.2.2 chown：更改文件属主，也可以同时更改文件属组</h4><blockquote><p>语法:</p><ul><li>chown [–R] 属主名 文件名</li><li>chown [-R] 属主名：属组名 文件名</li></ul></blockquote><h4 id="5-2-3-chmod：更改文件9个属性"><a href="#5-2-3-chmod：更改文件9个属性" class="headerlink" title="5.2.3 chmod：更改文件9个属性"></a>5.2.3 chmod：更改文件9个属性</h4><ul><li>Linux文件属性有两种设置方法，一种是数字，一种是符号。</li><li>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</li><li>我们可以使用数字来代表各个权限，各权限的分数对照表如下：<ul><li><strong>r:4</strong></li><li><strong>w:2</strong></li><li><strong>x:1</strong></li></ul></li><li>每种身份(owner/group/others, 中间用<code>,</code>隔开)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：<ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul></li></ul><h5 id="5-2-3-1-使用数字修改权限"><a href="#5-2-3-1-使用数字修改权限" class="headerlink" title="5.2.3.1 使用数字修改权限"></a>5.2.3.1 使用数字修改权限</h5><ul><li><code>chmod [-R] xyz 文件或目录</code><ul><li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li><li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li><li>举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下：<br><img src="/archives/13-linux-bi-ji.htm/3.6%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.jpg" alt="3.6更改文件属性.jpg"></li></ul></li></ul><h5 id="5-2-3-1-使用符号修改权限"><a href="#5-2-3-1-使用符号修改权限" class="headerlink" title="5.2.3.1 使用符号修改权限"></a>5.2.3.1 使用符号修改权限</h5><ul><li>我们就可以使用 u(user), g(group), o(others) 来代表三种身份的权限！</li><li>此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看<br><img src="/archives/13-linux-bi-ji.htm/3.6%E7%AC%A6%E5%8F%B7%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90.jpg" alt="3.6符号修改权限.jpg"></li><li>举例说明<br><img src="/archives/13-linux-bi-ji.htm/3.6%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E4%B8%BE%E4%BE%8B.jpg" alt="3.6权限修改举例"></li></ul><h1 id="3-7定时任务调度"><a href="#3-7定时任务调度" class="headerlink" title="3.7定时任务调度"></a>3.7定时任务调度</h1><h2 id="1-任务调度原理"><a href="#1-任务调度原理" class="headerlink" title="1. 任务调度原理"></a>1. 任务调度原理</h2><blockquote><p>crond任务调度：crontab进行定时任务调度<br><img src="/archives/13-linux-bi-ji.htm/3.7%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86.jpg" alt="3.7定时调度原理"></p></blockquote><ul><li>使用方法：<code>crontab [选项]</code><ul><li><code>-e</code>：编辑crontab定时任务</li><li><code>-i</code>：查询crontab任务</li><li><code>-r</code>：删除当前用户所有的crontab任务</li><li><code>-l</code>：列出当前有哪些任务调度</li><li>service crond restart：重启任务调度</li><li>当保存退出后就生效了</li><li>参数细节说明</li></ul></li></ul><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个“*”</td><td>一小时当中的第几分钟</td><td>0-59</td></tr><tr><td>第二个“*”</td><td>一天当中的第几小时</td><td>0-23</td></tr><tr><td>第三个“*”</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td>第四个“*”</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td>第五个“*”</td><td>一周当中的星期几</td><td>0-7（0和7都代表星期日）</td></tr></tbody></table><ul><li>特殊符号说明<ul><li><code>\*：</code>代表任何时间。比如第一个*就代表一小时中每分钟都执行一次的意思。</li><li><code>,：</code>代表不连续的时间。比如“0 8,12,16 * * *命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。</li><li><code>-：</code>代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令。</li><li><code>/n：</code>代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一遍命令。</li></ul></li></ul><h1 id="Linux磁盘分区、挂载度"><a href="#Linux磁盘分区、挂载度" class="headerlink" title="Linux磁盘分区、挂载度"></a>Linux磁盘分区、挂载度</h1><h2 id="1-分区方式"><a href="#1-分区方式" class="headerlink" title="1. 分区方式"></a>1. 分区方式</h2><ul><li><p>mbr分区</p><ul><li>最多支持四个主分区</li><li>系统只能安装在主分区</li><li>扩展分区要占一个主分区</li><li>MBR最大只支持2TB，但拥有最好的兼容性</li></ul></li><li><p>gpt分区</p><ul><li>支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区）</li><li>最大支持18EB的大容量（1EB=1024PB，PB=1024TB）</li><li>windows7 64位以后支持gpt</li></ul></li></ul><h2 id="2-Linux分区"><a href="#2-Linux分区" class="headerlink" title="2. Linux分区"></a>2. Linux分区</h2><h3 id="2-1-分区原理"><a href="#2-1-分区原理" class="headerlink" title="2.1 分区原理"></a>2.1 分区原理</h3><ul><li>Linux来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。</li><li>Linux采用了一种叫做“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。<br><img src="/archives/13-linux-bi-ji.htm/3.8Linux%E5%88%86%E5%8C%BA%E5%8E%9F%E7%90%86.jpg" alt="3.8Linux分区原理"></li></ul><h3 id="2-2-硬盘说明"><a href="#2-2-硬盘说明" class="headerlink" title="2.2 硬盘说明"></a>2.2 硬盘说明</h3><ul><li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</li><li><code>lsblk -f</code>：查看当前系统的分区和挂载情况。（list block）</li></ul><h3 id="3-挂载硬盘"><a href="#3-挂载硬盘" class="headerlink" title="3. 挂载硬盘"></a>3. 挂载硬盘</h3><blockquote><p>需求是给我们的Linux系统增加一个新的硬盘，并且挂载到/home/newdisk</p></blockquote><ol><li>添加硬盘</li><li>分区：fdsk /dev/sdb</li><li>格式化：mkfs -t ext4 /dev/sdb1</li><li>挂载：新建目录：mkdir /home/newdisk；挂载：mount /dev/sdb1 /home/newdisk</li><li>设置可以自动挂载（永久挂载）：重启系统后，仍然可以挂载。vim etc/fstab 增加挂载信息。mount -a：生效</li></ol><h3 id="3-1-具体步骤"><a href="#3-1-具体步骤" class="headerlink" title="3.1 具体步骤"></a>3.1 具体步骤</h3><h4 id="3-1-1-增加硬盘"><a href="#3-1-1-增加硬盘" class="headerlink" title="3.1.1 增加硬盘"></a>3.1.1 增加硬盘</h4><p><img src="/archives/13-linux-bi-ji.htm/3.8%E5%A2%9E%E5%8A%A0%E7%A1%AC%E7%9B%98.jpg" alt="3.8增加硬盘.jpg"></p><h4 id="3-1-2-硬盘分区"><a href="#3-1-2-硬盘分区" class="headerlink" title="3.1.2 硬盘分区"></a>3.1.2 硬盘分区</h4><p><img src="/archives/13-linux-bi-ji.htm/3.8%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA.jpg" alt="3.8硬盘分区.jpg"></p><h4 id="3-1-3-格式化磁盘"><a href="#3-1-3-格式化磁盘" class="headerlink" title="3.1.3 格式化磁盘"></a>3.1.3 格式化磁盘</h4><p><img src="/archives/13-linux-bi-ji.htm/3.8%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%A3%81%E7%9B%98.jpg" alt="3.8格式化磁盘.jpg"></p><h4 id="3-1-4-挂载硬盘"><a href="#3-1-4-挂载硬盘" class="headerlink" title="3.1.4 挂载硬盘"></a>3.1.4 挂载硬盘</h4><p><img src="/archives/13-linux-bi-ji.htm/3.8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98.jpg" alt="3.8格式化磁盘.jpg"></p><h4 id="3-1-5-永久挂载"><a href="#3-1-5-永久挂载" class="headerlink" title="3.1.5 永久挂载"></a>3.1.5 永久挂载</h4><p><img src="/archives/13-linux-bi-ji.htm/3.8%E6%B0%B8%E4%B9%85%E6%8C%82%E8%BD%BD.jpg" alt="3.8格式化磁盘.jpg"></p><h3 id="3-2-取消挂载"><a href="#3-2-取消挂载" class="headerlink" title="3.2 取消挂载"></a>3.2 取消挂载</h3><ul><li>取消挂载：<code>unmount /dev/sdb1</code></li></ul><h2 id="4-磁盘状况查询"><a href="#4-磁盘状况查询" class="headerlink" title="4. 磁盘状况查询"></a>4. 磁盘状况查询</h2><ul><li><p>磁盘情况查询：<code>df -h</code> / <code>df -l</code></p></li><li><p>查询指定目录的磁盘占用情况：<code>du -h /目录</code>，默认为当前目录</p><ul><li><code>-s</code>：指定目录占用大小汇总</li><li><code>-h</code>：带计量单位</li><li><code>-a</code>：含文件</li><li><code>–-max-depth=1</code>：子目录深度</li><li><code>-c</code>：列出明细的同时，增加汇总值</li></ul></li><li><p>磁盘情况-工作实用指令</p><ul><li>统计/home文件夹下文件的个数：<code>ls -l /home | grep "^-" | wc -l</code></li><li>统计/y文件夹下目录的个数：<code>ls -l /home | grep "^d" | wc -l</code></li><li>统计/home文件夹下文件的个数，包括子文件夹里的：<code>ls -lR /home | grep "^-" | wc -l</code></li><li>统计文件夹下目录的个数，包括子文件夹里的：<code>ls -lR /home | grep "^d" | wc -l</code></li><li>以树状显示目录结构：首先安装tree指令：<code>yum install tree，tree</code></li></ul></li></ul><blockquote><p>实例</p></blockquote><p><img src="/archives/13-linux-bi-ji.htm/Users/10615/Desktop/Linux%25E7%25AC%2594%25E8%25AE%25B0.assets/3.8%25E5%25B7%25A5%25E4%25BD%259C%25E5%25AE%259E%25E7%2594%25A8%25E6%258C%2587%25E4%25BB%25A41.jpg" alt="3.8工作实用指令1"><br><img src="/archives/13-linux-bi-ji.htm/3.8%E5%B7%A5%E4%BD%9C%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A42.jpg" alt="3.8工作实用指令1.jpg"></p><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><h2 id="1-Linux网络配置原理"><a href="#1-Linux网络配置原理" class="headerlink" title="1 Linux网络配置原理"></a>1 Linux网络配置原理</h2><blockquote><p>虚拟机NAT网络配置原理</p></blockquote><p><img src="/archives/13-linux-bi-ji.htm/3.9%E8%99%9A%E6%8B%9F%E6%9C%BANAT%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86.jpg" alt="虚拟机NAT网络配置原理"></p><h2 id="2-查看网络IP和网关"><a href="#2-查看网络IP和网关" class="headerlink" title="2 查看网络IP和网关"></a>2 查看网络IP和网关</h2><h3 id="2-1-虚拟机网络编辑器"><a href="#2-1-虚拟机网络编辑器" class="headerlink" title="2.1 虚拟机网络编辑器"></a>2.1 虚拟机网络编辑器</h3><p><img src="/archives/13-linux-bi-ji.htm/3.9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E8%BE%91%E5%99%A8.jpg" alt="3.9虚拟机网络编辑器.jpg"></p><h3 id="2-2-修改IP地址"><a href="#2-2-修改IP地址" class="headerlink" title="2.2 修改IP地址"></a>2.2 修改IP地址</h3><p><img src="/archives/13-linux-bi-ji.htm/3.9%E4%BF%AE%E6%94%B9IP%E5%9C%B0%E5%9D%80.jpg" alt="修改IP地址"></p><h3 id="2-3-查看网关"><a href="#2-3-查看网关" class="headerlink" title="2.3 查看网关"></a>2.3 查看网关</h3><p><img src="/archives/13-linux-bi-ji.htm/3.9%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%85%B3.jpg" alt="查看网关"></p><h3 id="2-4-查看windows中的虚拟网卡的ip地址"><a href="#2-4-查看windows中的虚拟网卡的ip地址" class="headerlink" title="2.4 查看windows中的虚拟网卡的ip地址"></a>2.4 查看windows中的虚拟网卡的ip地址</h3><ul><li>windows中使用<code>ipconfig</code>查看ip配置</li></ul><h2 id="3-ping测试"><a href="#3-ping测试" class="headerlink" title="3. ping测试"></a>3. ping测试</h2><blockquote><p>基本语法: ping [主机地址]</p></blockquote><ul><li>例如： ping <a href="http://www.baidu.com/">www.baidu.com</a></li></ul><h2 id="4-Linux网络环境配置"><a href="#4-Linux网络环境配置" class="headerlink" title="4. Linux网络环境配置"></a>4. Linux网络环境配置</h2><h3 id="4-1-自动抓取"><a href="#4-1-自动抓取" class="headerlink" title="4.1 自动抓取"></a>4.1 自动抓取</h3><p><img src="/archives/13-linux-bi-ji.htm/3.9%E8%87%AA%E5%8A%A8%E6%8A%93%E5%8F%96.jpg" alt="自动抓取自动抓取"></p><p><strong><code>缺点：</code></strong> 每次自动获取的ip地址可能不一样，不适用于做服务器</p><h3 id="4-2-指定ip地址"><a href="#4-2-指定ip地址" class="headerlink" title="4.2 指定ip地址"></a>4.2 指定ip地址</h3><ol><li>直接修改配置文件来指定IP，并可以连接到外网，编辑：vim /etc/sysconfig/network-scripts/ifcfg-eth0<br><img src="/archives/13-linux-bi-ji.htm/3.9%E6%8C%87%E5%AE%9Aip%E5%9C%B0%E5%9D%80.jpg" alt="指定ip地址"></li><li>重启网络服务：service network restart</li><li>重启系统：reboot<br><img src="/archives/13-linux-bi-ji.htm/3.9ifcfg-eth0%E8%AF%B4%E6%98%8E.jpg" alt="3.9ifcfg-eth0说明"></li></ol><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="1-进程管理基础"><a href="#1-进程管理基础" class="headerlink" title="1. 进程管理基础"></a>1. 进程管理基础</h2><ul><li>在Linux中，每个执行的<strong>程序（代码）</strong>都称为一个进程。每个进程都分配一个ID号</li><li>每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。</li><li>每个进程都可能以两种方式存在。前台和后台。<ul><li>前台进程：用户目前的屏幕上可以进行操作的。</li><li>后台进程：实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li></ul></li><li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。</li></ul><h2 id="2-显示系统执行的进程"><a href="#2-显示系统执行的进程" class="headerlink" title="2. 显示系统执行的进程"></a>2. 显示系统执行的进程</h2><h3 id="2-1-ps指令详细介绍"><a href="#2-1-ps指令详细介绍" class="headerlink" title="2.1 ps指令详细介绍"></a>2.1 ps指令详细介绍</h3><blockquote><p>ps [选项]：查看目前系统中，有哪些正在执行，以及它们执行的状况</p></blockquote><ul><li><code>ps -a</code>：显示当前终端的所有进程信息。</li><li><code>ps -u</code>：以用户的格式显示进程信息。</li><li><code>ps -x</code>：显示后台进程运行的参数。</li><li><code>ps -axu | grep xxx</code>：过滤得到xxx的信息。</li><li><code>ps -ef</code>：以全格式显示当前所有的进程，查看进程的父进程。</li><li><code>-e</code>：显示所有进程。</li><li><code>-f</code>：全格式。</li></ul><blockquote><p>ps -axu显示信息选项</p></blockquote><p><img src="/archives/13-linux-bi-ji.htm/3.10ps%E6%98%BE%E7%A4%BA%E4%BF%A1%E6%81%AF%E8%AF%B4%E6%98%8E.jpg" alt="3.10ps显示信息说明.jpg"></p><blockquote><p>System V 展示风格</p></blockquote><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>USER</td><td>用户说明</td></tr><tr><td>PID</td><td>进程识别号</td></tr><tr><td>%CPU</td><td>进程占用cpu百分比</td></tr><tr><td>%MEM</td><td>进程占用物理内存百分比</td></tr><tr><td>VSZ</td><td>进程占用虚拟内存大小(KB)</td></tr><tr><td>RSS</td><td>进程占用物理内存大小(KB)</td></tr><tr><td>TTY</td><td>终端机号</td></tr><tr><td>STAT</td><td>进程状态，S睡眠，s代表是会话的先导进程，N代表进程拥有比普通进程更高的优先级，R正在运行，D短期等待，Z僵死进程，T被跟踪或被停止</td></tr><tr><td>STARTED</td><td>进程启动的时间</td></tr><tr><td>TIME</td><td>此进程所消耗的CPU时间</td></tr><tr><td>COMMAND</td><td>正在执行的命令或进程名</td></tr></tbody></table><blockquote><p>ps -ef显示信息解释</p></blockquote><p><img src="/archives/13-linux-bi-ji.htm/3.9psef.png" alt="3.9psef.png"></p><blockquote><p>BSD展示风格</p></blockquote><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>UID</td><td>用户id</td></tr><tr><td>PID</td><td>进程id</td></tr><tr><td>PPID</td><td>父进程</td></tr><tr><td>C</td><td>CPU用于执行优先级的因子，数值越大，表明cpu密集型运算，执行优先级会降低，数值越小，表明是I/O密集运算，执行优先级会提高</td></tr><tr><td>STIME</td><td>进程启动时间</td></tr><tr><td>TTY</td><td>终端机号</td></tr><tr><td>TIME</td><td>此进程所消耗的CPU时间</td></tr><tr><td>CMD</td><td>启动所用的命令和参数</td></tr></tbody></table><h2 id="3-终止进程"><a href="#3-终止进程" class="headerlink" title="3. 终止进程"></a>3. 终止进程</h2><blockquote><p>若是某个进程执行一半需要停止时，或是消耗了很大的系统资源时，此时可以考虑停止该进程，使用kill命令来完成此任务</p></blockquote><ul><li><code>kill [选项] 进程号</code>：通过进程号杀死进程<ul><li><code>-9</code>：表示强迫进程立刻停止(比如终端)</li></ul></li><li><code>killall 进程名称</code>：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用</li></ul><h2 id="4-查看进程树"><a href="#4-查看进程树" class="headerlink" title="4. 查看进程树"></a>4. 查看进程树</h2><ul><li>查看进程树：<code>pstree [选项]</code><ul><li><code>-p</code>：显示进程的PID</li><li><code>-u</code>：显示进程的所属用户</li></ul></li></ul><h2 id="5-服务-Service-管理"><a href="#5-服务-Service-管理" class="headerlink" title="5. 服务(Service)管理"></a>5. 服务(Service)管理</h2><blockquote><p>服务(Service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql,sshd 防火墙等),因此我们又称为守护进程。</p></blockquote><p><img src="/archives/13-linux-bi-ji.htm/3.10%E6%9C%8D%E5%8A%A1%E8%AF%B4%E6%98%8E.jpg" alt="3.10服务说明"></p><h3 id="5-1-service管理指令"><a href="#5-1-service管理指令" class="headerlink" title="5.1 service管理指令"></a>5.1 service管理指令</h3><blockquote><p>service管理指令：<code>service 服务名 [start | stop | restart | reload | status]</code><br>在CentOS7.0之后，不再使用service，而是<code>systemctl</code></p></blockquote><ul><li><p>查看防火墙情况：</p><ul><li>service iptables status</li><li>systemctl status firewall（7.0之后的版本）<br><img src="/archives/13-linux-bi-ji.htm/3.10%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99.jpg" alt="3.10打开关闭防火墙.jpg"></li></ul></li><li><p>测试某个端口是否在监听：<code>telnet</code></p></li></ul><h3 id="5-2-服务查看方式"><a href="#5-2-服务查看方式" class="headerlink" title="5.2 服务查看方式"></a>5.2 服务查看方式</h3><ul><li>方式1：<code>setup</code>指令<br><img src="/archives/13-linux-bi-ji.htm/3.10%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1.jpg" alt="3.10查看系统服务.jpg"></li><li>方式2：<code>ls -l /etc/init.d/</code></li></ul><h3 id="5-3-服务的运行级别（runlevel）"><a href="#5-3-服务的运行级别（runlevel）" class="headerlink" title="5.3 服务的运行级别（runlevel）"></a>5.3 服务的运行级别（runlevel）</h3><ul><li>查看或修改默认级别：vim  /etc/inittab</li><li>每个服务对应的每个运行级别都可以设置<br><a href="3.5%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4.md">详细见3.5实用指令第一部分</a></li></ul><h3 id="5-4-开机流程"><a href="#5-4-开机流程" class="headerlink" title="5.4 开机流程"></a>5.4 开机流程</h3><p><img src="/archives/13-linux-bi-ji.htm/3.10%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B.png" alt="3.10开机流程"></p><h3 id="5-5-chkconfig指令"><a href="#5-5-chkconfig指令" class="headerlink" title="5.5 chkconfig指令"></a>5.5 <code>chkconfig</code>指令</h3><p>​     可以给每个服务的各个运行级别设置自启动/关闭</p><h4 id="5-5-1-基本语法"><a href="#5-5-1-基本语法" class="headerlink" title="5.5.1 基本语法"></a>5.5.1 基本语法</h4><ul><li>查看服务：<code>chkconfig –list</code></li><li>查看服务的状态：<code>chkconfig 服务名 --list</code></li><li>给服务的运行级别设置自启动：<code> --level 5 服务名 on/off</code></li><li>要所有运行级别关闭或开启：<code>chkconfig 服务名 on/off</code></li><li><strong>chkconfig重新设置后需要重新启动才能生效</strong></li></ul><h2 id="6-动态监控进程"><a href="#6-动态监控进程" class="headerlink" title="6. 动态监控进程"></a>6. 动态监控进程</h2><blockquote><p>top与ps相似，都是用来显示正在执行的进程，top的不同之处在于top执行一段时间可以更新正在运行的进程</p></blockquote><h3 id="6-1-基本语法"><a href="#6-1-基本语法" class="headerlink" title="6.1 基本语法"></a>6.1 基本语法</h3><blockquote><p><code>top [选项]</code></p><ul><li><code>-d</code> 秒数：指定top命令每隔几秒更新。默认是3秒。</li><li><code>-i</code>：使top不显示任何闲置或者僵死进程。</li><li><code>-p</code>：通过指定监控进程ID来仅仅监控某个进程的状态。</li></ul></blockquote><ul><li>交互操作说明：</li></ul><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以CPU使用率排序，默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出top</td></tr></tbody></table><blockquote><p>动态进程监控图例</p></blockquote><p><img src="/archives/13-linux-bi-ji.htm/3.10%E5%8A%A8%E6%80%81%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7%E5%9B%BE%E4%BE%8B.jpg" alt="3.10动态进程监控图例"></p><h3 id="6-2-应用案例"><a href="#6-2-应用案例" class="headerlink" title="6.2 应用案例"></a>6.2 应用案例</h3><h4 id="6-2-1-监控特定用户"><a href="#6-2-1-监控特定用户" class="headerlink" title="6.2.1  监控特定用户"></a>6.2.1  监控特定用户</h4><ol><li>top查看进程；</li><li>u</li><li>输入用户名。</li></ol><h4 id="6-2-2-终止指定的进程"><a href="#6-2-2-终止指定的进程" class="headerlink" title="6.2.2 终止指定的进程"></a>6.2.2 终止指定的进程</h4><ol><li>top查看进程；</li><li>k输入要结束的进程。</li></ol><h2 id="7-查看网络情况"><a href="#7-查看网络情况" class="headerlink" title="7. 查看网络情况"></a>7. 查看网络情况</h2><h3 id="7-1-基本语法"><a href="#7-1-基本语法" class="headerlink" title="7.1 基本语法"></a>7.1 基本语法</h3><blockquote><p><code>netstat [选项]</code></p><ul><li><code>-an</code>：按一定顺序排列输出</li><li><code>-p</code>：显示哪个进程在调用</li></ul></blockquote><h1 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h1><h2 id="1-RPM包"><a href="#1-RPM包" class="headerlink" title="1. RPM包"></a>1. RPM包</h2><blockquote><p>RPM：RedHat Package Manager，红帽软件包管理工具。<br>Linuxd分发版本都有采用（suse,redhat，centos等）</p></blockquote><h3 id="1-1-rpm指令"><a href="#1-1-rpm指令" class="headerlink" title="1.1 rpm指令"></a>1.1 rpm指令</h3><h4 id="1-1-1-查看指令"><a href="#1-1-1-查看指令" class="headerlink" title="1.1.1 查看指令"></a>1.1.1 查看指令</h4><ul><li>RPM查询已安装的rpm列表：rpm -qa | grep xx<ul><li>查看是否安装firefox：rpm -qa |grep firefox<br><img src="/archives/13-linux-bi-ji.htm/3.11rpm%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C.jpg" alt="3.11rpm查询结果.jpg"></li><li>如果是i686,i386表示32位系统，noarch表示通用</li></ul></li><li><code>rpm -qa</code>：查询所安装的所有rpm软件包</li><li><code>rpm -qa | grep xx</code></li><li><code>rpm -q xx</code>：查询xx软件包是否安装</li><li><code>rpm -qi xx</code>：查询软件包信息</li><li><code>rpm -ql xx</code>：查询软件包中的文件</li><li><code>rpm -qf</code> 文件全路径名：查询文件所属的软件包</li></ul><h4 id="1-1-2-卸载指令"><a href="#1-1-2-卸载指令" class="headerlink" title="1.1.2 卸载指令"></a>1.1.2 卸载指令</h4><ul><li>卸载rpm包：rpm -e 软件包名称</li><li>如果其他软件依赖于要卸载的包，删除时可能会发生依赖错误</li><li>忽视依赖强制删除的方法：rpm -e –nodeps 软件包名称 可以强制删除，但不建议这样做，否则会导致程序无法运行</li></ul><h4 id="1-1-3安装指令"><a href="#1-1-3安装指令" class="headerlink" title="1.1.3安装指令"></a>1.1.3安装指令</h4><ul><li>安装rpm包：rpm -hiv 软件包全路径名称<ul><li>i=install：安装</li><li>v=verbose：提示</li><li>h=hash：进度条</li></ul></li></ul><h2 id="2-YUM"><a href="#2-YUM" class="headerlink" title="2. YUM"></a>2. YUM</h2><blockquote><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。<br>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p></blockquote><ul><li>yum list | grep xx：查询yum服务器是否有需要安装的软件</li><li>yum install xx：安装指定的yum包</li><li>yum -y remove xx：卸载指定的yum包</li></ul><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h2 id="Shell简介"><a href="#Shell简介" class="headerlink" title="Shell简介"></a>Shell简介</h2><h4 id="1-Shell基础"><a href="#1-Shell基础" class="headerlink" title="1. Shell基础"></a>1. Shell基础</h4><ul><li>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</li><li>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</li><li>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</li></ul><h4 id="1-1-什么是shell"><a href="#1-1-什么是shell" class="headerlink" title="1.1 什么是shell"></a>1.1 什么是shell</h4><blockquote><p>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便裕兴程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。</p></blockquote><p><img src="/archives/13-linux-bi-ji.htm/5.1shell%E5%8E%9F%E7%90%86.jpg" alt="5.1shell原理.jpg"></p><h6 id="1-2-shell脚本"><a href="#1-2-shell脚本" class="headerlink" title="1.2 shell脚本"></a>1.2 shell脚本</h6><blockquote><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。<br>业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。</p></blockquote><h6 id="1-3-Shell-环境"><a href="#1-3-Shell-环境" class="headerlink" title="1.3 Shell 环境"></a>1.3 Shell 环境</h6><blockquote><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p></blockquote><ul><li>Linux 的 Shell 种类众多，常见的有：<ul><li>Bourne Shell（/usr/bin/sh或/bin/sh）</li><li>Bourne Again Shell（/bin/bash）</li><li>C Shell（/usr/bin/csh）</li><li>K Shell（/usr/bin/ksh）</li><li>Shell for Root（/sbin/sh）</li></ul></li><li>本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</li><li>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 ##!/bin/sh，它同样也可以改为 ##!/bin/bash。</li></ul><h4 id="2-Shell脚本的运行"><a href="#2-Shell脚本的运行" class="headerlink" title="2. Shell脚本的运行"></a>2. Shell脚本的运行</h4><h6 id="2-1-脚本的格式"><a href="#2-1-脚本的格式" class="headerlink" title="2.1 脚本的格式"></a>2.1 脚本的格式</h6><ul><li>脚本以##!/bin/bash 开头<br><img src="/archives/13-linux-bi-ji.htm/5.1shell%E8%84%9A%E6%9C%AC%E6%A0%BC%E5%BC%8F.jpg" alt="5.1shell脚本格式"></li></ul><h6 id="2-2-脚本的执行"><a href="#2-2-脚本的执行" class="headerlink" title="2.2 脚本的执行"></a>2.2 脚本的执行</h6><ol><li><p>赋予用户脚本执行权限</p><ul><li>chmod +x ./test.sh  ##使脚本具有执行权限</li><li>./demo.sh</li><li>注意，一定要写成 ./demo.sh，而不是 demo.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 demo.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 demo.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</li></ul></li><li><p>作为解释器参数</p><ul><li>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：<ul><li>/bin/sh test.sh</li><li>/bin/php test.php</li><li>sh demo.sh</li></ul></li><li>一般不这么用</li></ul></li></ol><h2 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h2><h4 id="1-shell变量简介"><a href="#1-shell变量简介" class="headerlink" title="1. shell变量简介"></a>1. shell变量简介</h4><ul><li>Linux Shell的变量分为，系统变量和用户自定义变量</li><li>系统变量：$HOME、$PWD、$SHELL、$USER等等</li><li>显示当前shell中所有变量：set</li></ul><h6 id="1-1-变量规则"><a href="#1-1-变量规则" class="headerlink" title="1.1 变量规则"></a>1.1 变量规则</h6><ul><li>变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</li><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li><li>变量名称一般习惯为大写</li></ul><h6 id="1-2-shell变量的定义"><a href="#1-2-shell变量的定义" class="headerlink" title="1.2 shell变量的定义"></a>1.2 shell变量的定义</h6><p>######## 1.2.1 基本语法</p><ul><li>定义变量：变量=值，=两边不能有空格</li><li>撤销变量：unset 变量</li><li>声明静态变量：readonly 变量，注意：<code>不能unset</code></li></ul><p>######## 1.2.2 将命令的返回值赋给变量</p><ul><li>A=ls -la这里有反引号（ESC下面），运行里面的命令，并把结果返回给变量A</li><li>A=$(ls -la)等价于上面</li></ul><h6 id="1-3-使用变量"><a href="#1-3-使用变量" class="headerlink" title="1.3 使用变量"></a>1.3 使用变量</h6><ul><li>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</li></ul><pre class=" language-sh"><code class="language-sh">your_name="qinjx"echo $your_nameecho ${your_name}</code></pre><ul><li>量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</li></ul><pre class=" language-sh"><code class="language-sh">for skill in Ada Coffe Action Java; do    echo "I am good at ${skill}Script"done</code></pre><h6 id="1-4-静态变量"><a href="#1-4-静态变量" class="headerlink" title="1.4 静态变量"></a>1.4 静态变量</h6><ul><li>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</li><li>下面的例子尝试更改只读变量，结果报错：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashmyUrl="http://www.google.com"readonly myUrlmyUrl="http://www.runoob.com"################ $/bin/sh: NAME: This variable is read only.</code></pre><h6 id="1-5-删除变量"><a href="#1-5-删除变量" class="headerlink" title="1.5 删除变量"></a>1.5 删除变量</h6><ul><li>使用 unset 命令可以删除变量。语法：unset variable_name</li><li>变量被删除后不能再次使用。unset 命令不能删除只读变量。</li></ul><h6 id="1-6-变量类型"><a href="#1-6-变量类型" class="headerlink" title="1.6 变量类型"></a>1.6 变量类型</h6><ol><li><code>局部变量</code> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><code>环境变量</code> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><code>shell变量</code> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ol><h4 id="2-环境变量"><a href="#2-环境变量" class="headerlink" title="2. 环境变量"></a>2. 环境变量</h4><blockquote><p>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</p></blockquote><ul><li>基本语法</li><li>export 变量名=变量值：将shell变量输出为环境变量</li><li>source 配置文件：让修改后的配置文件信息立即生效</li><li>echo $变量名：查询环境变量的值</li></ul><h4 id="3-Shell-注释"><a href="#3-Shell-注释" class="headerlink" title="3. Shell 注释"></a>3. Shell 注释</h4><ul><li>以 ## 开头的行就是注释，会被解释器忽略。</li><li>通过每一行加一个 ## 号设置多行注释，像这样：</li></ul><pre class=" language-sh"><code class="language-sh">##--------------------------------------------## 这是一个注释## author：菜鸟教程## site：www.runoob.com## slogan：学的不仅是技术，更是梦想！##--------------------------------------------########## 用户配置区 开始 ################ 这里可以添加脚本描述信息############## 用户配置区 结束  ##########</code></pre><blockquote><p>多行注释</p></blockquote><ul><li>多行注释还可以使用以下格式：</li></ul><pre class=" language-sh"><code class="language-sh">:<<EOF注释内容...注释内容...注释内容...EOF</code></pre><ul><li>EOF 也可以使用其他符号:</li></ul><pre class=" language-sh"><code class="language-sh">:<<'注释内容...注释内容...注释内容...':<<!注释内容...注释内容...注释内容...!</code></pre><h4 id="4-位置参数-预定义变量"><a href="#4-位置参数-预定义变量" class="headerlink" title="4. 位置参数,预定义变量"></a>4. 位置参数,预定义变量</h4><ul><li>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashecho "Shell 传递参数实例！";echo "执行的文件名：$0";echo "第一个参数为：$1";echo "第二个参数为：$2";echo "第三个参数为：$3";:<<!chmod +x test.sh$ ./test.sh 1 2 3Shell 传递参数实例！执行的文件名：./test.sh第一个参数为：1第二个参数为：2第三个参数为：3!</code></pre><ul><li>另外，还有几个特殊字符用来处理参数：</li></ul><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$##</td><td>传递到脚本的参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><pre class=" language-sh"><code class="language-sh">##!/bin/bashecho "Shell 传递参数实例！";echo "第一个参数为：$1";echo "参数个数为：$##";echo "传递的参数作为一个字符串显示：$*";:<<!$chmod +x test.sh$./test.sh 1 2 3Shell 传递参数实例！第一个参数为：1参数个数为：3传递的参数作为一个字符串显示：1 2 3!</code></pre><ul><li>预定义变量实例<br><img src="/archives/13-linux-bi-ji.htm/5.3%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F.jpg" alt="5.3预定义变量.jpg"><br><img src="/archives/13-linux-bi-ji.htm/Users/10615/Desktop/Linux%25E7%25AC%2594%25E8%25AE%25B0.assets/5.3%25E9%25A2%2584%25E5%25AE%259A%25E4%25B9%2589%25E5%258F%2598%25E9%2587%258F%25E7%25BB%2593%25E6%259E%259C.jpg" alt="5.3预定义变量结果.jpg"></li></ul><h2 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h2><blockquote><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p></blockquote><h4 id="1-单引号"><a href="#1-单引号" class="headerlink" title="1. 单引号"></a>1. 单引号</h4><pre class=" language-sh"><code class="language-sh">str='this is a string'</code></pre><ul><li>单引号字符串的限制：<ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul></li></ul><h4 id="2-双引号"><a href="#2-双引号" class="headerlink" title="2. 双引号"></a>2. 双引号</h4><pre class=" language-sh"><code class="language-sh">your_name='runoob'str="Hello, I know you are \"$your_name\"! \n"echo -e $str## 输出结果为：## Hello, I know you are "runoob"!</code></pre><ul><li>双引号的优点：<ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul></li></ul><h4 id="3-拼接字符串"><a href="#3-拼接字符串" class="headerlink" title="3. 拼接字符串"></a>3. 拼接字符串</h4><pre class=" language-sh"><code class="language-sh">your_name="runoob"## 使用双引号拼接greeting="hello, "$your_name" !"greeting_1="hello, ${your_name} !"echo $greeting  $greeting_1## 使用单引号拼接greeting_2='hello, '$your_name' !'greeting_3='hello, ${your_name} !'echo $greeting_2  $greeting_3##输出结果为：##hello, runoob ! hello, runoob !##hello, runoob ! hello, ${your_name} !</code></pre><h4 id="4-获取字符串长度"><a href="#4-获取字符串长度" class="headerlink" title="4. 获取字符串长度"></a>4. 获取字符串长度</h4><pre class=" language-sh"><code class="language-sh">string="abcd"echo ${##string} ##输出 4</code></pre><h4 id="5-提取子字符串"><a href="#5-提取子字符串" class="headerlink" title="5. 提取子字符串"></a>5. 提取子字符串</h4><p>以下实例从字符串第 2 个字符开始截取 4 个字符：</p><pre class=" language-sh"><code class="language-sh">string="runoob is a great site"echo ${string:1:4} ## 输出 unoo</code></pre><h4 id="6-查找子字符串"><a href="#6-查找子字符串" class="headerlink" title="6. 查找子字符串"></a>6. 查找子字符串</h4><p>查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：</p><pre class=" language-sh"><code class="language-sh">string="runoob is a great site"echo `expr index "$string" io`  ## 输出 4注意： 以上脚本中 ` 是反引号，而不是单引号 '，不要看错了哦。</code></pre><h2 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a>Shell数组</h2><ul><li>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。</li></ul><h4 id="1-数组赋值"><a href="#1-数组赋值" class="headerlink" title="1. 数组赋值"></a>1. 数组赋值</h4><ul><li>与大部分编程语言类似，数组元素的下标由0开始。</li><li>Shell 数组用括号来表示，元素用”空格”符号分割开，语法格式如下：<ul><li>array_name=(value1 … valuen)</li></ul></li><li>我们也可以使用下标来定义数组:</li></ul><pre class=" language-sh"><code class="language-sh">array_name[0]=value0array_name[1]=value1array_name[2]=value2</code></pre><h4 id="2-读取数组"><a href="#2-读取数组" class="headerlink" title="2. 读取数组"></a>2. 读取数组</h4><ul><li>读取数组元素值的一般格式是：${array_name[index]}</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashmy_array=(A B "C" D)echo "第一个元素为: ${my_array[0]}"echo "第二个元素为: ${my_array[1]}"echo "第三个元素为: ${my_array[2]}"echo "第四个元素为: ${my_array[3]}"##第一个元素为: A##第二个元素为: B##第三个元素为: C##第四个元素为: D</code></pre><ul><li>获取数组中的所有元素,使用@ 或 * 可以获取数组中的所有元素，例如：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashmy_array[0]=Amy_array[1]=Bmy_array[2]=Cmy_array[3]=Decho "数组的元素为: ${my_array[*]}"echo "数组的元素为: ${my_array[@]}"</code></pre><ul><li>获取数组长度的方法与获取字符串长度的方法相同，例如：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashmy_array[0]=Amy_array[1]=Bmy_array[2]=Cmy_array[3]=Decho "数组元素个数为: ${##my_array[*]}"echo "数组元素个数为: ${##my_array[@]}"</code></pre><h2 id="Shell运算符"><a href="#Shell运算符" class="headerlink" title="Shell运算符"></a>Shell运算符</h2><ul><li>Shell 和其他编程语言一样，支持多种运算符，包括：<ul><li>算数运算符</li><li>关系运算符</li><li>布尔运算符</li><li>字符串运算符</li><li>文件测试运算符</li></ul></li><li>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</li><li>例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘)：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashval=`expr 2 + 2`echo "两数之和为 : $val" ##两数之和为 : 4</code></pre><ul><li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li><li>完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li><li>centos中可用“$((运算式))”或“$[运算式]”</li></ul><h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h4><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td>`expr $a + $b` 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td>`expr $a - $b` 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td>`expr $a * $b` 结果为  200。</td></tr><tr><td>/</td><td>除法</td><td>`expr $b / $a` 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td>`expr $b % $a` 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td>a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回 true。</td><td>[ $a == $b ] 返回 false。</td></tr><tr><td>!=</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td>[ $a != $b ] 返回 true。</td></tr></tbody></table><blockquote><p>注意：</p><ul><li>乘号(*)前边必须加反斜杠()才能实现乘法运算；</li><li>if…then…fi 是条件语句，后续将会讲解。</li><li>在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*” 不需要转义符号 “" 。</li></ul></blockquote><h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h4><ul><li>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</li><li>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-eq</td><td>检测两个数是否相等，相等返回 true。</td><td>[ $a -eq $b ] 返回 false。</td></tr><tr><td>-ne</td><td>检测两个数是否不相等，不相等返回 true。</td><td>[ $a -ne $b ] 返回 true。</td></tr><tr><td>-gt</td><td>检测左边的数是否大于右边的，如果是，则返回 true。</td><td>[ $a -gt $b ] 返回 false。</td></tr><tr><td>-lt</td><td>检测左边的数是否小于右边的，如果是，则返回 true。</td><td>[ $a -lt $b ] 返回 true。</td></tr><tr><td>-ge</td><td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td>[$a -ge $b ] 返回 false。</td></tr><tr><td>-le</td><td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td>[ $a -le $b ] 返回 true。</td></tr></tbody></table><ul><li>关系运算符实例如下：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/basha=10b=20if [ $a -eq $b ]then   echo "$a -eq $b : a 等于 b"else   echo "$a -eq $b: a 不等于 b"fiif [ $a -ne $b ]then   echo "$a -ne $b: a 不等于 b"else   echo "$a -ne $b : a 等于 b"fiif [ $a -gt $b ]then   echo "$a -gt $b: a 大于 b"else   echo "$a -gt $b: a 不大于 b"fiif [ $a -lt $b ]then   echo "$a -lt $b: a 小于 b"else   echo "$a -lt $b: a 不小于 b"fiif [ $a -ge $b ]then   echo "$a -ge $b: a 大于或等于 b"else   echo "$a -ge $b: a 小于 b"fiif [ $a -le $b ]then   echo "$a -le $b: a 小于或等于 b"else   echo "$a -le $b: a 大于 b"fi##10 -eq 20: a 不等于 b##10 -ne 20: a 不等于 b##10 -gt 20: a 不大于 b##10 -lt 20: a 小于 b##10 -ge 20: a 小于 b##10 -le 20: a 小于或等于 b</code></pre><h4 id="3-布尔运算符"><a href="#3-布尔运算符" class="headerlink" title="3. 布尔运算符"></a>3. 布尔运算符</h4><ul><li>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>!</td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td><td>[ ! false ] 返回 true。</td></tr><tr><td>-o</td><td>或运算，有一个表达式为 true 则返回 true。</td><td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td>-a</td><td>与运算，两个表达式都为 true 才返回 true。</td><td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr></tbody></table><ul><li>布尔运算符实例如下：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/basha=10b=20if [ $a != $b ]then   echo "$a != $b : a 不等于 b"else   echo "$a == $b: a 等于 b"fiif [ $a -lt 100 -a $b -gt 15 ]then   echo "$a 小于 100 且 $b 大于 15 : 返回 true"else   echo "$a 小于 100 且 $b 大于 15 : 返回 false"fiif [ $a -lt 100 -o $b -gt 100 ]then   echo "$a 小于 100 或 $b 大于 100 : 返回 true"else   echo "$a 小于 100 或 $b 大于 100 : 返回 false"fiif [ $a -lt 5 -o $b -gt 100 ]then   echo "$a 小于 5 或 $b 大于 100 : 返回 true"else   echo "$a 小于 5 或 $b 大于 100 : 返回 false"fi##10 != 20 : a 不等于 b##10 小于 100 且 20 大于 15 : 返回 true##10 小于 100 或 20 大于 100 : 返回 true##10 小于 5 或 20 大于 100 : 返回 false</code></pre><h4 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h4><ul><li>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑的 AND</td><td>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td></tr><tr><td>||</td><td>逻辑的 OR</td><td>[[ $a -lt 100</td></tr></tbody></table><ul><li>逻辑运算符实例如下：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/basha=10b=20if [[ $a -lt 100 && $b -gt 100 ]]then   echo "返回 true"else   echo "返回 false"fiif [[ $a -lt 100 || $b -gt 100 ]]then   echo "返回 true"else   echo "返回 false"fi## 返回 false## 返回 true</code></pre><h4 id="5-字符串运算符"><a href="#5-字符串运算符" class="headerlink" title="5. 字符串运算符"></a>5. 字符串运算符</h4><ul><li>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</li></ul><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>=</td><td>检测两个字符串是否相等，相等返回 true。</td><td>[ $a = $b ] 返回 false。</td></tr><tr><td>!=</td><td>检测两个字符串是否相等，不相等返回 true。</td><td>[ $a != $b ] 返回 true。</td></tr><tr><td>-z</td><td>检测字符串长度是否为0，为0返回 true。</td><td>[ -z $a ] 返回 false。</td></tr><tr><td>-n</td><td>检测字符串长度是否为0，不为0返回 true。</td><td>[ -n “$a” ] 返回 true。</td></tr><tr><td>$</td><td>检测字符串是否为空，不为空返回 true。</td><td>[ $a ] 返回 true。</td></tr></tbody></table><ul><li>字符串运算符实例如下：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/basha="abc"b="efg"if [ $a = $b ]then   echo "$a = $b : a 等于 b"else   echo "$a = $b: a 不等于 b"fiif [ $a != $b ]then   echo "$a != $b : a 不等于 b"else   echo "$a != $b: a 等于 b"fiif [ -z $a ]then   echo "-z $a : 字符串长度为 0"else   echo "-z $a : 字符串长度不为 0"fiif [ -n "$a" ]then   echo "-n $a : 字符串长度不为 0"else   echo "-n $a : 字符串长度为 0"fiif [ $a ]then   echo "$a : 字符串不为空"else   echo "$a : 字符串为空"fi## abc = efg: a 不等于 b## abc != efg : a 不等于 b## -z abc : 字符串长度不为 0## -n abc : 字符串长度不为 0## abc : 字符串不为空</code></pre><h4 id="6-文件测试运算符"><a href="#6-文件测试运算符" class="headerlink" title="6. 文件测试运算符"></a>6. 文件测试运算符</h4><ul><li>文件测试运算符用于检测 Unix 文件的各种属性。</li><li>属性检测描述如下：</li></ul><table><thead><tr><th>操作符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td><td>[ -b $file ] 返回 false。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td><td>[ -c $file ] 返回 false。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td><td>[ -d $file ] 返回 false。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td>[ -f $file ] 返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td>[ -g $file ] 返回 false。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td>[ -k $file ] 返回 false。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td><td>[ -p $file ] 返回 false。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td>[ -u $file ] 返回 false。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td><td>[ -r $file ] 返回 true。</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true。</td><td>[ -w $file ] 返回 true。</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true。</td><td>[ -x $file ] 返回 true。</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td>[ -s $file ] 返回 true。</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true。</td><td>[ -e $file ] 返回 true。</td></tr></tbody></table><p>其他检查符：</p><p>-S: 判断某文件是否 socket。<br>-L: 检测文件是否存在并且是一个符号链接。<br>实例</p><ul><li>变量 file 表示文件 /var/www/runoob/test.sh，它的大小为 100 字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashfile="/var/www/runoob/test.sh"if [ -r $file ]then   echo "文件可读"else   echo "文件不可读"fiif [ -w $file ]then   echo "文件可写"else   echo "文件不可写"fiif [ -x $file ]then   echo "文件可执行"else   echo "文件不可执行"fiif [ -f $file ]then   echo "文件为普通文件"else   echo "文件为特殊文件"fiif [ -d $file ]then   echo "文件是个目录"else   echo "文件不是个目录"fiif [ -s $file ]then   echo "文件不为空"else   echo "文件为空"fiif [ -e $file ]then   echo "文件存在"else   echo "文件不存在"fi##文件可读##文件可写##文件可执行##文件为普通文件##文件不是个目录##文件不为空##文件存在</code></pre><h2 id="Shell打印输出命令"><a href="#Shell打印输出命令" class="headerlink" title="Shell打印输出命令"></a>Shell打印输出命令</h2><h4 id="1-echo命令"><a href="#1-echo命令" class="headerlink" title="1. echo命令"></a>1. echo命令</h4><ul><li>Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：<code>echo string</code></li><li>您可以使用echo实现更复杂的输出格式控制。</li></ul><h6 id="1-1-显示普通字符串"><a href="#1-1-显示普通字符串" class="headerlink" title="1.1 显示普通字符串"></a>1.1 显示普通字符串</h6><pre class=" language-sh"><code class="language-sh">echo "It is a test"</code></pre><p>这里的双引号完全可以省略，以下命令与上面实例效果一致：</p><pre class=" language-sh"><code class="language-sh">echo It is a test</code></pre><h6 id="1-2-显示转义字符"><a href="#1-2-显示转义字符" class="headerlink" title="1.2 显示转义字符"></a>1.2 显示转义字符</h6><pre class=" language-sh"><code class="language-sh">echo "\"It is a test\""##结果将是:##"It is a test"</code></pre><h6 id="1-3-显示变量"><a href="#1-3-显示变量" class="headerlink" title="1.3 显示变量"></a>1.3 显示变量</h6><ul><li>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/shread nameecho "$name It is a test"</code></pre><ul><li>以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:</li></ul><pre class=" language-sh"><code class="language-sh">[root@www ~]## sh test.shOK                     ##标准输入OK It is a test        ##输出</code></pre><h6 id="1-4-显示换行"><a href="#1-4-显示换行" class="headerlink" title="1.4 显示换行"></a>1.4 显示换行</h6><pre class=" language-sh"><code class="language-sh">echo -e "OK! \n" ## -e 开启转义echo "It is a test"## 输出结果：## OK!#### It is a test</code></pre><h6 id="1-5-显示不换行"><a href="#1-5-显示不换行" class="headerlink" title="1.5 显示不换行"></a>1.5 显示不换行</h6><pre class=" language-sh"><code class="language-sh">##!/bin/shecho -e "OK! \c" ## -e 开启转义 \c 不换行echo "It is a test"## 输出结果：#### OK! It is a test</code></pre><h6 id="1-6-显示结果定向至文件"><a href="#1-6-显示结果定向至文件" class="headerlink" title="1.6 显示结果定向至文件"></a>1.6 显示结果定向至文件</h6><pre class=" language-sh"><code class="language-sh">echo "It is a test" > myfile</code></pre><h6 id="1-7-原样输出字符串，不进行转义或取变量-用单引号"><a href="#1-7-原样输出字符串，不进行转义或取变量-用单引号" class="headerlink" title="1.7 原样输出字符串，不进行转义或取变量(用单引号)"></a>1.7 原样输出字符串，不进行转义或取变量(用单引号)</h6><pre class=" language-sh"><code class="language-sh">echo '$name\"'##输出结果：##$name\"</code></pre><h6 id="1-8-显示命令执行结果"><a href="#1-8-显示命令执行结果" class="headerlink" title="1.8 显示命令执行结果"></a>1.8 显示命令执行结果</h6><pre class=" language-sh"><code class="language-sh">echo `date`##注意： 这里使用的是反引号 `, 而不是单引号 '。##结果将显示当前日期##Thu Jul 24 10:08:46 CST 2014</code></pre><h4 id="2-printf-命令"><a href="#2-printf-命令" class="headerlink" title="2. printf 命令"></a>2. printf 命令</h4><ul><li>printf 命令模仿 C 程序库（library）里的 printf() 程序。</li><li>printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</li><li>printf 使用引用文本或空格分隔的参数，外面可以在 * printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。</li></ul><blockquote><p><code>printf</code> 命令的语法：printf  format-string  [arguments…]</p></blockquote><ul><li>参数说明：<ul><li>format-string: 为格式控制字符串</li><li>arguments: 为参数列表。</li></ul></li><li>实例如下：</li></ul><pre class=" language-sh"><code class="language-sh">$ echo "Hello, Shell"Hello, Shell$ printf "Hello, Shell\n"Hello, Shell</code></pre><h6 id="2-1-printf实例"><a href="#2-1-printf实例" class="headerlink" title="2.1 printf实例"></a>2.1 printf实例</h6><pre class=" language-sh"><code class="language-sh">##!/bin/bashprintf "%-10s %-8s %-4s\n" 姓名 性别 体重kg  printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876</code></pre><ul><li>执行脚本，输出结果如下所示：</li></ul><pre class=" language-txt"><code class="language-txt">姓名     性别   体重kg郭靖     男      66.12杨过     男      48.65郭芙     女      47.99</code></pre><ul><li>%s %c %d %f都是格式替代符<ul><li>%-10s 指一个宽度为10个字符</li><li>-表示左对齐，没有则表示右对齐，任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</li><li>%-4.2f 指格式化为小数，其中.2指保留2位小数。</li></ul></li></ul><p>更多实例：</p><pre class=" language-sh"><code class="language-sh">##!/bin/bash## format-string为双引号printf "%d %s\n" 1 "abc"## 单引号与双引号效果一样printf '%d %s\n' 1 "abc"## 没有引号也可以输出printf %s abcdef## 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用printf %s abc defprintf "%s\n" abc defprintf "%s %s %s\n" a b c d e f g h i j## 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替printf "%s and %d \n"</code></pre><p>执行脚本，输出结果如下所示：</p><pre class=" language-txt"><code class="language-txt">1 abc1 abcabcdefabcdefabcdefa b cd e fg h ij   and 0</code></pre><h4 id="2-2-printf的转义序列"><a href="#2-2-printf的转义序列" class="headerlink" title="2.2 printf的转义序列"></a>2.2 printf的转义序列</h4><table><thead><tr><th>序列</th><th>说明</th></tr></thead><tbody><tr><td>\a</td><td>警告字符，通常为ASCII的BEL字符</td></tr><tr><td>\b</td><td>后退</td></tr><tr><td>\c</td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td>\f</td><td>换页（formfeed）</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车（Carriage return）</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\\</td><td>一个字面上的反斜杠字符</td></tr><tr><td>\ddd</td><td>表示1到3位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td>\0ddd</td><td>表示1到3位的八进制值字符</td></tr></tbody></table><pre class=" language-sh"><code class="language-sh">$ printf "a string, no processing:<%s>\n" "A\nB"a string, no processing:<A\nB>$ printf "a string, no processing:<%b>\n" "A\nB"a string, no processing:<AB>$ printf "www.runoob.com \a"www.runoob.com $                  ##不换行</code></pre><h4 id="3-read读取控制台的输入"><a href="#3-read读取控制台的输入" class="headerlink" title="3.read读取控制台的输入"></a>3.read读取控制台的输入</h4><ul><li>read [选项] (参数)<ul><li>-p：指定读取值时的提示符</li><li>-t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了。</li></ul></li><li>参数：变量：指定读取值的变量名</li></ul><h2 id="Shell-test-命令"><a href="#Shell-test-命令" class="headerlink" title="Shell test 命令"></a>Shell test 命令</h2><blockquote><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p></blockquote><h4 id="1-数值测试"><a href="#1-数值测试" class="headerlink" title="1. 数值测试"></a>1. 数值测试</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于则为真</td></tr><tr><td>-ge</td><td>大于等于则为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table><pre class=" language-sh"><code class="language-sh">num1=100num2=100if test $[num1] -eq $[num2]then    echo '两个数相等！'else    echo '两个数不相等！'fi##输出结果：##两个数相等！</code></pre><h4 id="2-字符串测试"><a href="#2-字符串测试" class="headerlink" title="2. 字符串测试"></a>2. 字符串测试</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于则为真</td></tr><tr><td>!=</td><td>不相等则为真</td></tr><tr><td>-z 字符串</td><td>字符串的长度为零则为真</td></tr><tr><td>-n 字符串</td><td>字符串的长度不为零则为真</td></tr></tbody></table><pre class=" language-sh"><code class="language-sh">num1="ru1noob"num2="runoob"if test $num1 = $num2then    echo '两个字符串相等!'else    echo '两个字符串不相等!'fi##输出结果：##两个字符串不相等!</code></pre><h4 id="3-文件测试"><a href="#3-文件测试" class="headerlink" title="3. 文件测试"></a>3. 文件测试</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e 文件名</td><td>如果文件存在则为真</td></tr><tr><td>-r 文件名</td><td>如果文件存在且可读则为真</td></tr><tr><td>-w 文件名</td><td>如果文件存在且可写则为真</td></tr><tr><td>-x 文件名</td><td>如果文件存在且可执行则为真</td></tr><tr><td>-s 文件名</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td>-d 文件名</td><td>如果文件存在且为目录则为真</td></tr><tr><td>-f 文件名</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td>-c 文件名</td><td>如果文件存在且为字符型特殊文件则为真</td></tr><tr><td>-b 文件名</td><td>如果文件存在且为块特殊文件则为真</td></tr></tbody></table><p>实例演示：</p><pre class=" language-sh"><code class="language-sh">cd /binif test -e ./bashthen    echo '文件已存在!'else    echo '文件不存在!'fi## 输出结果：## 文件已存在!</code></pre><ul><li>另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：”!”最高，”-a”次之，”-o”最低。例如：</li></ul><pre class=" language-sh"><code class="language-sh">cd sh/binif test -e ./notFile -o -e ./bashthen    echo '至少有一个文件存在!'else    echo '两个文件都不存在'fi##输出结果：##至少有一个文件存在!</code></pre><h2 id="Shell-流程控制"><a href="#Shell-流程控制" class="headerlink" title="Shell 流程控制"></a>Shell 流程控制</h2><h4 id="1-判断语句"><a href="#1-判断语句" class="headerlink" title="1. 判断语句"></a>1. 判断语句</h4><h6 id="1-1-if判断"><a href="#1-1-if判断" class="headerlink" title="1.1 if判断"></a>1.1 if判断</h6><ul><li>if else-if else 语法格式：</li></ul><pre class=" language-sh"><code class="language-sh">if condition1then    command1elif condition2then    command2else    commandNfi</code></pre><ul><li>或者：</li></ul><pre class=" language-sh"><code class="language-sh">if [ 条件判断式 ];then程序fi</code></pre><ul><li>以下实例判断两个变量是否相等:</li></ul><pre class=" language-sh"><code class="language-sh">a=10b=20if [ $a == $b ]then   echo "a 等于 b"elif [ $a -gt $b ]then   echo "a 大于 b"elif [ $a -lt $b ]then   echo "a 小于 b"else   echo "没有符合的条件"fi## a 小于 b</code></pre><ul><li><strong><code>注意：</code></strong> 和Java、PHP等语言不一样，sh的流程控制不可为空。如果else分支没有语句执行，就不要写这个else。</li></ul><h6 id="1-2-case语句"><a href="#1-2-case语句" class="headerlink" title="1.2 case语句"></a>1.2 case语句</h6><ul><li>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：</li></ul><pre class=" language-sh"><code class="language-sh">case 值 in模式1)    command1    command2    commandN    ;;模式2）    command1    command2    commandN    ;;esac</code></pre><ul><li>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。</li><li>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</li><li>下面的脚本提示输入1到4，与每一种模式进行匹配：</li></ul><pre class=" language-sh"><code class="language-sh">echo '输入 1 到 4 之间的数字:'echo '你输入的数字为:'read aNumcase $aNum in    1)  echo '你选择了 1'    ;;    2)  echo '你选择了 2'    ;;    3)  echo '你选择了 3'    ;;    4)  echo '你选择了 4'    ;;    *)  echo '你没有输入 1 到 4 之间的数字'    ;;esac</code></pre><ul><li>输入不同的内容，会有不同的结果，例如：</li></ul><pre class=" language-sh"><code class="language-sh">##输入 1 到 4 之间的数字:##你输入的数字为:##3##你选择了 3</code></pre><h4 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h4><h6 id="2-1-for循环"><a href="#2-1-for循环" class="headerlink" title="2.1 for循环"></a>2.1 for循环</h6><ul><li>for循环一般格式为：</li></ul><pre class=" language-sh"><code class="language-sh">for var in item1 item2 ... itemNdo    command1    command2    ...    commandNdone</code></pre><ul><li>写成一行：</li></ul><pre class=" language-sh"><code class="language-sh">for var in item1 item2 ... itemN; do command1; command2… done;</code></pre><ul><li>当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。</li><li>in列表是可选的，如果不用它，for循环使用命令行的位置参数。</li><li>例如，顺序输出当前列表中的数字：</li></ul><pre class=" language-sh"><code class="language-sh">for loop in 1 2 3 4 5do    echo "The value is: $loop"done## The value is: 1## The value is: 2## The value is: 3## The value is: 4## The value is: 5</code></pre><h6 id="2-2-while-语句"><a href="#2-2-while-语句" class="headerlink" title="2.2 while 语句"></a>2.2 while 语句</h6><ul><li>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</li></ul><pre class=" language-sh"><code class="language-sh">while conditiondo    commanddone</code></pre><ul><li>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashint=1while(( $int<=5 ))do    echo $int    let "int++"done##运行脚本，输出：## 1## 2## 3## 4## 5</code></pre><ul><li>以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：<a href="https://www.runoob.com/linux/linux-comm-let.html">Bash let 命令</a></li></ul><h6 id="2-3-until循环"><a href="#2-3-until循环" class="headerlink" title="2.3 until循环"></a>2.3 until循环</h6><ul><li>until 循环执行一系列命令直至条件为 true 时停止。</li><li>until 循环与 while 循环在处理方式上刚好相反。</li><li>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</li><li>until 语法格式:</li></ul><pre class=" language-sh"><code class="language-sh">until conditiondo    commanddone</code></pre><ul><li>condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</li><li>以下实例我们使用 until 命令来输出 0 ~ 9 的数字：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/basha=0until [ ! $a -lt 10 ]do   echo $a   a=`expr $a + 1`done</code></pre><h6 id="2-4-跳出循环"><a href="#2-4-跳出循环" class="headerlink" title="2.4 跳出循环"></a>2.4 跳出循环</h6><ul><li>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</li></ul><p>######## 2.4.1 break命令</p><ul><li>break命令允许跳出所有循环（终止执行后面的所有循环）。</li><li>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashwhile :do    echo -n "输入 1 到 5 之间的数字:"    read aNum    case $aNum in        1|2|3|4|5) echo "你输入的数字为 $aNum!"        ;;        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"            break        ;;    esacdone##执行以上代码，输出结果为：####输入 1 到 5 之间的数字:3##你输入的数字为 3!##输入 1 到 5 之间的数字:7##你输入的数字不是 1 到 5 之间的! 游戏结束</code></pre><p>######## 2.4.2 continue</p><ul><li>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。<br>对上面的例子进行修改：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashwhile :do    echo -n "输入 1 到 5 之间的数字: "    read aNum    case $aNum in        1|2|3|4|5) echo "你输入的数字为 $aNum!"        ;;        *) echo "你输入的数字不是 1 到 5 之间的!"            continue            echo "游戏结束"        ;;    esacdone##运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo "游戏结束" 永远不会被执行。</code></pre><h2 id="Shell-函数"><a href="#Shell-函数" class="headerlink" title="Shell 函数"></a>Shell 函数</h2><h4 id="1-自定义函数"><a href="#1-自定义函数" class="headerlink" title="1. 自定义函数"></a>1. 自定义函数</h4><blockquote><p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p></blockquote><ul><li>shell中函数的定义格式如下：</li></ul><pre class=" language-sh"><code class="language-sh">[ function ] funname [()]{    action;    [return int;]}</code></pre><ul><li><p>说明：</p><ol><li>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li></ol></li><li><p>下面的例子定义了一个函数并进行调用：</p></li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashdemoFun(){    echo "这是我的第一个 shell 函数!"}echo "-----函数开始执行-----"demoFunecho "-----函数执行完毕-----"## 输出结果：## -----函数开始执行-----## 这是我的第一个 shell 函数!## -----函数执行完毕-----</code></pre><ul><li>定义一个带有return语句的函数：</li></ul><pre class=" language-sh"><code class="language-sh">##!/bin/bashfunWithReturn(){    echo "这个函数会对输入的两个数字进行相加运算..."    echo "输入第一个数字: "    read aNum    echo "输入第二个数字: "    read anotherNum    echo "两个数字分别为 $aNum 和 $anotherNum !"    return $(($aNum+$anotherNum))}funWithReturnecho "输入的两个数字之和为 $? !"##输出类似下面：##这个函数会对输入的两个数字进行相加运算...##输入第一个数字:##1##输入第二个数字:##2##两个数字分别为 1 和 2 !##输入的两个数字之和为 3 !</code></pre><ul><li>函数返回值在调用该函数后通过 $? 来获得。</li><li>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</li></ul><h4 id="2-函数参数"><a href="#2-函数参数" class="headerlink" title="2. 函数参数"></a>2. 函数参数</h4><ul><li>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</li></ul><p>带参数的函数示例：</p><pre class=" language-sh"><code class="language-sh">##!/bin/bash## author:菜鸟教程## url:www.runoob.comfunWithParam(){    echo "第一个参数为 $1 !"    echo "第二个参数为 $2 !"    echo "第十个参数为 $10 !"    echo "第十个参数为 ${10} !"    echo "第十一个参数为 ${11} !"    echo "参数总数有 $## 个!"    echo "作为一个字符串输出所有参数 $* !"}funWithParam 1 2 3 4 5 6 7 8 9 34 73## 输出结果：## 第一个参数为 1 !## 第二个参数为 2 !## 第十个参数为 10 !## 第十个参数为 34 !## 第十一个参数为 73 !## 参数总数有 11 个!## 作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</code></pre><ul><li>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</li><li>另外，还有几个特殊字符用来处理参数：</li></ul><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$##</td><td>传递到脚本的参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><h4 id="3-系统函数"><a href="#3-系统函数" class="headerlink" title="3. 系统函数"></a>3. 系统函数</h4><h6 id="3-1-basename"><a href="#3-1-basename" class="headerlink" title="3.1 basename"></a>3.1 basename</h6><ul><li>basename：返回完整路径最后/的部分，常用于获取文件名</li><li>basename [pathname] [suffix]</li><li>basename [string] [suffix]</li><li>basename命令会删掉所有的前缀包括最后一个/<br>选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</li><li>dirname：返回完整路径最后/的前面的部分，常用于返回路径部分</li><li>dirname 文件绝对路径：从给定的包含绝对路径的文件名中出去文件名（非目录部分），然后返回剩下的路径（目录部分</li><li>反正两个系统函数都不要最后一个/</li></ul><h2 id="Shell-输入-输出重定向"><a href="#Shell-输入-输出重定向" class="headerlink" title="Shell 输入/输出重定向"></a>Shell 输入/输出重定向</h2><blockquote><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p></blockquote><p>重定向命令列表如下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>command &gt; file</td><td>将输出重定向到 file。</td></tr><tr><td>command &lt; file</td><td>将输入重定向到 file。</td></tr><tr><td>command &gt;&gt; file</td><td>将输出以追加的方式重定向到 file。</td></tr><tr><td>n &gt; file</td><td>将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td>n &gt;&gt; file</td><td>将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td>n &gt;&amp; m</td><td>将输出文件 m 和 n 合并。</td></tr><tr><td>n &lt;&amp; m</td><td>将输入文件 m 和 n 合并。</td></tr><tr><td>&lt;&lt; tag</td><td>将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><blockquote><p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p></blockquote><h4 id="1-输出重定向"><a href="#1-输出重定向" class="headerlink" title="1. 输出重定向"></a>1. 输出重定向</h4><ul><li>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:</li></ul><pre class=" language-sh"><code class="language-sh">command1 > file1</code></pre><ul><li>上面这个命令执行command1然后将输出的内容存入file1。</li><li>注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符。</li></ul><p><strong>实例</strong><br>执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):</p><pre class=" language-sh"><code class="language-sh">$who > users</code></pre><ul><li>执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。</li><li>你可以使用 cat 命令查看文件内容：</li></ul><pre class=" language-sh"><code class="language-sh">$ cat users_mbsetupuser console  Oct 31 17:35tianqixin    console  Oct 31 17:35tianqixin    ttys000  Dec  1 11:33</code></pre><ul><li>输出重定向会覆盖文件内容，请看下面的例子：</li></ul><pre class=" language-sh"><code class="language-sh">echo "菜鸟教程：www.runoob.com" > userscat users菜鸟教程：www.runoob.com</code></pre><ul><li>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</li></ul><pre class=" language-sh"><code class="language-sh">$echo "菜鸟教程：www.runoob.com" >> users$cat users菜鸟教程：www.runoob.com菜鸟教程：www.runoob.com</code></pre><h4 id="2-输入重定向"><a href="#2-输入重定向" class="headerlink" title="2. 输入重定向"></a>2. 输入重定向</h4><blockquote><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p></blockquote><pre class=" language-sh"><code class="language-sh">command1 < file1</code></pre><ul><li>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</li><li>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。<br><strong>实例</strong></li><li>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：</li></ul><pre class=" language-sh"><code class="language-sh">$ wc -l users       2 users</code></pre><ul><li>也可以将输入重定向到 users 文件：</li></ul><pre class=" language-sh"><code class="language-sh">$  wc -l < users       2</code></pre><ul><li>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</li></ul><pre class=" language-sh"><code class="language-sh">command1 < infile > outfile</code></pre><ul><li>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</li></ul><h4 id="3-重定向深入讲解"><a href="#3-重定向深入讲解" class="headerlink" title="3. 重定向深入讲解"></a>3. 重定向深入讲解</h4><ul><li><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ol><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ol></li><li><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p></li><li><p>如果希望 stderr 重定向到 file，可以这样写：</p></li></ul><pre class=" language-sh"><code class="language-sh">$command 2 > file</code></pre><ul><li>如果希望 stderr 追加到 file 文件末尾，可以这样写：</li></ul><pre class=" language-sh"><code class="language-sh">command 2 >> file</code></pre><p>2 表示标准错误文件(stderr)。</p><ul><li>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</li></ul><pre class=" language-sh"><code class="language-sh">command > file 2>&1或者$command >> file 2>&1</code></pre><ul><li>如果希望对 stdin 和 stdout 都重定向，可以这样写：</li></ul><pre class=" language-sh"><code class="language-sh">$ command < file1 >file2command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</code></pre><h4 id="4-Here-Document"><a href="#4-Here-Document" class="headerlink" title="4. Here Document"></a>4. Here Document</h4><ul><li><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</p></li><li><p>它的基本的形式如下：</p></li></ul><pre class=" language-sh"><code class="language-sh">command << delimiter    documentdelimiter</code></pre><ul><li>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</li></ul><p><strong>注意：</strong></p><ul><li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li><li>开始的delimiter前后的空格会被忽略掉。<br><strong>实例</strong></li><li>在命令行中通过 wc -l 命令计算 Here Document 的行数：</li></ul><pre class=" language-sh"><code class="language-sh">$ wc -l << EOF    欢迎来到    菜鸟教程    www.runoob.comEOF3          ## 输出结果为 3 行</code></pre><p>我们也可以将 Here Document 用在脚本中，例如：</p><pre class=" language-sh"><code class="language-sh">##!/bin/bashcat << EOF欢迎来到菜鸟教程www.runoob.comEOF</code></pre><ul><li>执行以上脚本，输出结果：</li></ul><pre class=" language-txt"><code class="language-txt">欢迎来到菜鸟教程www.runoob.com/dev/null 文件</code></pre><ul><li>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</li></ul><pre class=" language-sh"><code class="language-sh">$command > /dev/null</code></pre><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><pre class=" language-sh"><code class="language-sh">$command > /dev/null 2>&1</code></pre><p>注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p><h2 id="Shell-文件包含"><a href="#Shell-文件包含" class="headerlink" title="Shell 文件包含"></a>Shell 文件包含</h2><p>？和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p><p>Shell 文件包含的语法格式如下：</p><pre class=" language-sh"><code class="language-sh">. filename   ## 注意点号(.)和文件名中间有一空格或source filename</code></pre><p><strong>实例</strong><br>创建两个 shell 脚本文件。<br>test1.sh 代码如下：</p><pre class=" language-sh"><code class="language-sh">##!/bin/bashurl="http://www.runoob.com"</code></pre><p>test2.sh 代码如下：</p><pre class=" language-sh"><code class="language-sh">##!/bin/bash##使用 . 号来引用test1.sh 文件. ./test1.sh## 或者使用以下包含文件代码## source ./test1.shecho "菜鸟教程官网地址：$url"</code></pre><ul><li>接下来，我们为 test2.sh 添加可执行权限并执行：</li></ul><pre class=" language-sh"><code class="language-sh">chmod +x test2.sh./test2.sh菜鸟教程官网地址：http://www.runoob.com</code></pre><blockquote><p><strong>注：</strong> 被包含的文件 test1.sh 不需要可执行权限.</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 服务端 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS笔记</title>
      <link href="/11-ts-bi-ji.html"/>
      <url>/11-ts-bi-ji.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是TypeScript"><a href="#1-什么是TypeScript" class="headerlink" title="1. 什么是TypeScript"></a>1. 什么是TypeScript</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ca61cc160c417c8497a00defdca5f0~tplv-k3u1fbpfcp-watermark.image" alt="TS与JS.png"></p><p><strong>TypeScript 是 JavaScript 的一个超集</strong>，主要提供了<strong>类型系统</strong>和<strong>对 ES6+ 的支持</strong>，它由 Microsoft 开发，代码<a href="https://github.com/Microsoft/TypeScript">开源于 GitHub (opens new window)</a>上</p><p>TypeScript 的特点：</p><ul><li><p><strong>可编译成纯净、简洁的js代码以运行在多个平台上</strong></p></li><li><p><strong>强大的静态类型和代码完成</strong></p></li><li><p><strong>提供js的ES6特性</strong></p></li></ul><h1 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="2.基本类型"></a>2.基本类型</h1><h2 id="类型特性"><a href="#类型特性" class="headerlink" title="类型特性"></a>类型特性</h2><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><ul><li><p>通过<code>:</code>指定TS中变量（参数、形参）的类型；</p></li><li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错；</p></li><li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值；</p><p>语法：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> 变量<span class="token punctuation">:</span> 类型<span class="token punctuation">;</span><span class="token keyword">let</span> 变量<span class="token punctuation">:</span> 类型 <span class="token operator">=</span> 值<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>参数<span class="token punctuation">:</span> 类型<span class="token punctuation">,</span> 参数<span class="token punctuation">:</span> 类型<span class="token punctuation">)</span><span class="token punctuation">:</span> 返回值类型<span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p><ul><li><p>第一种   <code>as</code></p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> someValue<span class="token punctuation">:</span> unknown <span class="token operator">=</span> <span class="token string">"this is a string"</span><span class="token punctuation">;</span><span class="token keyword">let</span> strLength<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token punctuation">(</span>someValue as <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span></code></pre></li><li><p>第二种   <code>尖括号</code></p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> someValue<span class="token punctuation">:</span> unknown <span class="token operator">=</span> <span class="token string">"this is a string"</span><span class="token punctuation">;</span><span class="token keyword">let</span> strLength<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span>someValue<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span></code></pre></li></ul><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>如果你的变量的声明和赋值同时进行，可以省略掉类型声明，TS编译器会自动判断变量的类型</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">/* 定义变量时赋值了, 推断为对应的类型 */</span><span class="token keyword">let</span> b9 <span class="token operator">=</span> <span class="token number">123</span> <span class="token comment" spellcheck="true">// number</span><span class="token comment" spellcheck="true">// b9 = 'abc' // error</span><span class="token comment" spellcheck="true">/* 定义变量时没有赋值, 推断为any类型（隐式推断，tsconfig中可关闭） */</span><span class="token keyword">let</span> b10  <span class="token comment" spellcheck="true">// any类型</span>b10 <span class="token operator">=</span> <span class="token number">123</span>b10 <span class="token operator">=</span> <span class="token string">'abc'</span></code></pre><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><blockquote><p>类似接口，但类型别名不能重复命名，接口可以</p></blockquote><pre class=" language-typescript"><code class="language-typescript">type MyType <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span><span class="token punctuation">;</span></code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种，使用<code>|</code></p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">toString2</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">|</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> x<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型表示取值同时属于多种类型，使用<code>&amp;</code></p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> a5<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> age<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>a5 <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'haha'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="具体类型："><a href="#具体类型：" class="headerlink" title="具体类型："></a>具体类型：</h2><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>例子</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">number</td><td align="center">1, -33, 2.5</td><td align="center">任意数字</td></tr><tr><td align="center">string</td><td align="center">‘hi’, “hi”, <code>hi</code></td><td align="center">任意字符串</td></tr><tr><td align="center">boolean</td><td align="center">true、false</td><td align="center">布尔值true或false</td></tr><tr><td align="center">字面量</td><td align="center">其本身</td><td align="center">限制变量的值就是该字面量的值</td></tr><tr><td align="center">any</td><td align="center">*</td><td align="center">任意类型（不安全）</td></tr><tr><td align="center">unknown</td><td align="center">*</td><td align="center">类型安全的any</td></tr><tr><td align="center">void</td><td align="center">空值（undefined）</td><td align="center">没有值（或undefined）</td></tr><tr><td align="center">never</td><td align="center">没有值</td><td align="center">不能是任何值</td></tr><tr><td align="center">object</td><td align="center">{name:’孙悟空’}</td><td align="center">任意的JS对象</td></tr><tr><td align="center">array</td><td align="center">[1,2,3]</td><td align="center">任意JS数组</td></tr><tr><td align="center">tuple</td><td align="center">[4,5]</td><td align="center">元素，TS新增类型，固定长度数组</td></tr><tr><td align="center">enum</td><td align="center">enum{A, B}</td><td align="center">枚举，TS中新增类型</td></tr><tr><td align="center">null和undefined</td><td align="center">空</td><td align="center">所有类型的子类型</td></tr></tbody></table><ul><li><p>number</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> decimal<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 十进制</span><span class="token keyword">let</span> hex<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">0xf00d</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 十六进制</span><span class="token keyword">let</span> binary<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">0b1010</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 二进制</span><span class="token keyword">let</span> octal<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">0o744</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 八进制</span><span class="token keyword">let</span> big<span class="token punctuation">:</span> bigint <span class="token operator">=</span> 100n<span class="token punctuation">;</span></code></pre></li><li><p>boolean</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> isDone<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span></code></pre></li><li><p>string</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> color<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">=</span> <span class="token string">"blue"</span><span class="token punctuation">;</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span><span class="token keyword">let</span> fullName<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Bob Bobbington`</span></span><span class="token punctuation">;</span><span class="token keyword">let</span> age<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">37</span><span class="token punctuation">;</span><span class="token keyword">let</span> sentence<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Hello, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>fullName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.I'll be </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> years old next month.`</span></span><span class="token punctuation">;</span></code></pre></li><li><p>null和undefined</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> u<span class="token punctuation">:</span> undefined <span class="token operator">=</span> undefined<span class="token keyword">let</span> n<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span></code></pre><p><strong>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code>赋值给任何类型的变量。</strong>（需要在tsconfig.json中关闭严格模式<code>"strict": false</code> ）</p></li><li><p>字面量</p><blockquote><p>作用：确定变量的具体取值范围</p></blockquote><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> color<span class="token punctuation">:</span> <span class="token string">'red'</span> <span class="token operator">|</span> <span class="token string">'blue'</span> <span class="token operator">|</span> <span class="token string">'black'</span><span class="token punctuation">;</span><span class="token keyword">let</span> num<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 可以限定num的范围只在1~5</span></code></pre></li><li><p>any</p><p>any类型可赋给任意类型的变量，因此可能造成错误，不安全</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> d<span class="token punctuation">:</span> <span class="token keyword">any</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">let</span> n<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>n <span class="token operator">=</span> d<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 编译通过，但有安全隐患</span></code></pre></li><li><p>unknown</p><p>unknown类型变量不能随意赋值，安全</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> what3<span class="token punctuation">:</span> unknown<span class="token punctuation">;</span><span class="token keyword">let</span> what4<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">;</span><span class="token keyword">let</span> what2<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> what4<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//    正常</span>what2 <span class="token operator">=</span> what3<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 报错，不能将类型“unknown”分配给类型“number”。</span></code></pre></li><li><p>void</p><p>void常用于函数返回类型</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> unusable<span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token operator">=</span> undefined<span class="token punctuation">;</span></code></pre></li><li><p>never</p><p>never可用于函数报错</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">error</span><span class="token punctuation">(</span>message<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> never <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre></li><li><p>object</p><p>没啥用，一般会更具体的声明类型</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> obj<span class="token punctuation">:</span> object <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li><li><p>array</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 两种方式</span><span class="token keyword">let</span> list<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// type[] 方式</span><span class="token keyword">let</span> list<span class="token punctuation">:</span> <span class="token keyword">Array</span><span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 泛型方式</span></code></pre></li><li><p>tuple</p><p>适用于已知元素数量和类型的数组，而各元素的类型有不相同的情况</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </code></pre></li><li><p>enum</p><blockquote><p>个人认为与数据相反，数据：数字索引映射data；枚举：data映射数字</p></blockquote><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 为一组数值赋予友好的名字</span>  Red<span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">// 默认情况下，从0开始为元素编号</span>  Green<span class="token punctuation">,</span>  Blue<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">let</span> c<span class="token punctuation">:</span> Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>  Red <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 可以手动的指定成员的数值</span>  Green<span class="token punctuation">,</span>  Blue<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">let</span> c<span class="token punctuation">:</span> Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>  Red <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>  Green <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>  Blue <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">let</span> c<span class="token punctuation">:</span> Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Color<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 由枚举的值得到它的名字 > Red</span></code></pre></li></ul><h1 id="3-编译选项"><a href="#3-编译选项" class="headerlink" title="3.编译选项"></a>3.编译选项</h1><h3 id="自动编译单个文件"><a href="#自动编译单个文件" class="headerlink" title="自动编译单个文件"></a>自动编译单个文件</h3><p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p><pre class=" language-powershell"><code class="language-powershell">  tsc xxx<span class="token punctuation">.</span>ts <span class="token operator">-</span>w</code></pre><h3 id="自动编译整个项目"><a href="#自动编译整个项目" class="headerlink" title="自动编译整个项目"></a>自动编译整个项目</h3><pre class=" language-powershell"><code class="language-powershell">tsc <span class="token operator">-</span>w</code></pre><p><strong>前提是项目根目录下有ts的配置文件 tsconfig.json</strong></p><pre class=" language-powershell"><code class="language-powershell">tsc <span class="token operator">--</span>init</code></pre><p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 <code>tsc</code> 命令即可完成对整个项目的编译</p><h3 id="配置选项："><a href="#配置选项：" class="headerlink" title="配置选项："></a>配置选项：</h3><blockquote><p><code>**</code>  =&gt;所有文件夹；<code>*</code>  =&gt; 所有文件</p></blockquote><h4 id="include"><a href="#include" class="headerlink" title="include"></a><strong>include</strong></h4><ul><li>定义希望被编译文件所在的目录</li><li>默认值：[“**/*“]</li></ul><pre class=" language-json"><code class="language-json">  <span class="token property">"include"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"src/**/*"</span><span class="token punctuation">,</span> <span class="token string">"tests/**/*"</span><span class="token punctuation">]</span></code></pre><h4 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a><strong>exclude</strong></h4><ul><li>定义需要排除在外的目录</li><li>默认值：[“node_modules”, “bower_components”, “jspm_packages”]</li></ul><pre class=" language-json"><code class="language-json">  <span class="token property">"exclude"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./src/hello/**/*"</span><span class="token punctuation">]</span></code></pre><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a><strong>extends</strong></h4><ul><li>定义要扩展的配置文件</li></ul><pre class=" language-json"><code class="language-json"><span class="token property">"extends"</span><span class="token operator">:</span> <span class="token string">"./configs/base"</span></code></pre><p>上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</p><h4 id="files"><a href="#files" class="headerlink" title="files"></a><strong>files</strong></h4><ul><li>指定被编译文件的列表，<strong>只有需要编译的文件少时才会用到</strong></li></ul><pre class=" language-json"><code class="language-json"><span class="token property">"files"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"core.ts"</span><span class="token punctuation">,</span>    <span class="token string">"sys.ts"</span><span class="token punctuation">,</span>    <span class="token string">"types.ts"</span><span class="token punctuation">,</span>    <span class="token string">"scanner.ts"</span><span class="token punctuation">,</span>    <span class="token string">"parser.ts"</span><span class="token punctuation">,</span>    <span class="token string">"utilities.ts"</span><span class="token punctuation">,</span>    <span class="token string">"binder.ts"</span><span class="token punctuation">,</span>    <span class="token string">"checker.ts"</span><span class="token punctuation">,</span>    <span class="token string">"tsc.ts"</span>  <span class="token punctuation">]</span></code></pre><h4 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a><strong>compilerOptions</strong></h4><ul><li><p>target</p><ul><li><p>设置ts代码编译的目标版本</p></li><li><p>可选值：ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</p><pre class=" language-json"><code class="language-json"><span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"ES6"</span>        // 编译为ES6<span class="token punctuation">}</span></code></pre></li></ul></li><li><p>lib</p><ul><li><p>指定代码运行时所包含的库（宿主环境）</p></li><li><p>可选值：DOM、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、WebWorker、ScriptHost ……</p><pre class=" language-json"><code class="language-json"><span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"ES6"</span><span class="token punctuation">,</span>    <span class="token property">"lib"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"ES6"</span><span class="token punctuation">,</span> <span class="token string">"DOM"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"outDir"</span><span class="token operator">:</span> <span class="token string">"dist"</span><span class="token punctuation">,</span>    <span class="token property">"outFile"</span><span class="token operator">:</span> <span class="token string">"dist/aa.js"</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>module</p><ul><li><p>设置编译后代码使用的模块化系统</p></li><li><p>可选值：CommonJS、UMD、AMD、System、ES2020、ESNext、None</p><pre class=" language-typescript"><code class="language-typescript"><span class="token string">"compilerOptions"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"module"</span><span class="token punctuation">:</span> <span class="token string">"CommonJS"</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>outDir</p><ul><li><p>编译后文件的所在目录</p></li><li><p>默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</p><pre class=" language-json"><code class="language-json"><span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"outDir"</span><span class="token operator">:</span> <span class="token string">"dist"</span>    //    设置后编译后的js文件将会生成到dist目录<span class="token punctuation">}</span></code></pre></li></ul></li><li><p>outFile</p><ul><li><p>将所有的文件编译为一个js文件</p></li><li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中，为其他模块化规范则不起作用</p><pre class=" language-json"><code class="language-json"><span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"outFile"</span><span class="token operator">:</span> <span class="token string">"dist/app.js"</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>rootDir</p><ul><li><p>指定代码的根目录</p></li><li><p>默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</p></li></ul></li></ul><pre><code>  ```json  "compilerOptions": {      "rootDir": "./src"  }  ```</code></pre><ul><li><p>allowJs</p><ul><li>是否对js文件编译</li></ul></li><li><p>checkJs</p><ul><li><p>是否对js文件进行检查</p><pre class=" language-json"><code class="language-json"><span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"allowJs"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"checkJs"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>removeComments</p><ul><li>是否删除注释</li><li>默认值：false</li></ul></li><li><p>noEmit</p><ul><li>不对代码进行编译，只检查语法</li><li>默认值：false</li></ul></li></ul><ul><li><p>noEmitOnError</p><ul><li><p>有错误的情况下不进行编译</p></li><li><p>默认值：false</p></li><li><p>sourceMap</p><ul><li>是否生成sourceMap</li></ul></li><li><p>默认值：false</p></li></ul></li></ul><p>严格检查</p><ul><li><p>strict ：启用<strong>所有</strong>的严格检查，默认值为true，设置后相当于开启了后面所有的严格检查</p></li><li><p>alwaysStrict ：总是以严格模式对代码进行编译</p></li><li><p>noImplicitAny ：禁止隐式的any类型</p></li><li><p>noImplicitThis ：禁止类型不明确的this</p></li><li><p>strictBindCallApply ：严格检查bind、call和apply的参数列表</p></li><li><p>strictFunctionTypes ：严格检查函数的类型</p></li><li><p>strictNullChecks ：严格的空值检查</p></li><li><p>strictPropertyInitialization ：严格检查属性是否初始化</p></li></ul><p>额外检查</p><ul><li><p>noFallthroughCasesInSwitch：检查switch语句包含正确的break</p></li><li><p>noImplicitReturns：检查函数没有隐式的返回值</p></li><li><p>noUnusedLocals：检查未使用的局部变量</p></li><li><p>noUnusedParameters：检查未使用的参数</p></li><li><p>allowUnreachableCode：检查不可达代码</p></li></ul><h1 id="TypeScript打包"><a href="#TypeScript打包" class="headerlink" title="TypeScript打包"></a>TypeScript打包</h1><h3 id="webpack整合"><a href="#webpack整合" class="headerlink" title="webpack整合"></a>webpack整合</h3><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>进入项目根目录，执行命令 <code> npm init -y</code>，创建package.json文件</p><h4 id="下载构建工具"><a href="#下载构建工具" class="headerlink" title="下载构建工具"></a>下载构建工具</h4><pre><code>npm install -D webpack                             //    构建工具webpackwebpack-cli                     //    webpack的命令行工具webpack-dev-server         //    webpack的开发服务器typescript                         //    ts编译器ts-loader                         //    ts加载器，用于在webpack中编译ts文件clean-webpack-plugin  //    用来自动创建html文件html-webpack-plugin      //    每次构建都会先清除目录cross-env                            //    统一环境变量</code></pre><h4 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h4><p>根目录下创建webpack的配置文件<code>webpack.config.js</code>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">{</span>CleanWebpackPlugin<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">const</span> isProd <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">===</span> <span class="token string">'production'</span> <span class="token comment" spellcheck="true">// 是否生产环境</span><span class="token keyword">function</span> resolve <span class="token punctuation">(</span>dir<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'..'</span><span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span> mode<span class="token punctuation">:</span> isProd <span class="token operator">?</span> <span class="token string">'production'</span> <span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span> entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>   app<span class="token punctuation">:</span> <span class="token string">'./src/main.ts'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> output<span class="token punctuation">:</span> <span class="token punctuation">{</span>   path<span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   filename<span class="token punctuation">:</span> <span class="token string">'[name].[contenthash:8].js'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> module<span class="token punctuation">:</span> <span class="token punctuation">{</span>   rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>     <span class="token punctuation">{</span>       test<span class="token punctuation">:</span> <span class="token regex">/\.tsx?$/</span><span class="token punctuation">,</span>       use<span class="token punctuation">:</span> <span class="token string">'ts-loader'</span><span class="token punctuation">,</span>       include<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>     <span class="token punctuation">}</span>   <span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>   <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>     template<span class="token punctuation">:</span> <span class="token string">'./public/index.html'</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">:</span> <span class="token punctuation">{</span>   extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'.ts'</span><span class="token punctuation">,</span> <span class="token string">'.tsx'</span><span class="token punctuation">,</span> <span class="token string">'.js'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> devtool<span class="token punctuation">:</span> isProd <span class="token operator">?</span> <span class="token string">'cheap-module-source-map'</span> <span class="token punctuation">:</span> <span class="token string">'cheap-module-eval-source-map'</span><span class="token punctuation">,</span> devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>   host<span class="token punctuation">:</span> <span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 主机名</span>   stats<span class="token punctuation">:</span> <span class="token string">'errors-only'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 打包日志输出输出错误信息</span>   port<span class="token punctuation">:</span> <span class="token number">8081</span><span class="token punctuation">,</span>   open<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><h4 id="配置TS编译选项"><a href="#配置TS编译选项" class="headerlink" title="配置TS编译选项"></a>配置TS编译选项</h4><p>根目录下创建tsconfig.json，配置可以根据自己需要</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>   <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"ES2015"</span><span class="token punctuation">,</span>       <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"ES2015"</span><span class="token punctuation">,</span>       <span class="token property">"strict"</span><span class="token operator">:</span> <span class="token boolean">true</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="修改package-json配置"><a href="#修改package-json配置" class="headerlink" title="修改package.json配置"></a>修改package.json配置</h4><p>修改package.json添加如下配置</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>   ...   <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       <span class="token property">"test"</span><span class="token operator">:</span> <span class="token string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span class="token punctuation">,</span>      <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js"</span><span class="token punctuation">,</span>            <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"cross-env NODE_ENV=production webpack --config build/webpack.config.js"</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   ...<span class="token punctuation">}</span></code></pre><h4 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h4><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译；</p><p>或者执行<code>npm run dev</code>来启动开发服务器；</p><br><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>除了webpack，开发中还经常需要结合babel来对代码进行转换；</p><p>以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中；</p><blockquote><p>  虽然TS在编译时也支持代码转换，但是只支持简单的代码转换；</p><p>  对于例如：Promise等ES6特性，TS无法直接转换，这时还要用到babel来做转换；</p></blockquote><h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><pre><code>npm install @babel/core                 //    babel的核心工具@babel/preset-env     //    babel的预定义环境babel-loader                 //    babel在webpack中的加载器core-js                          //    core-js用来使老版本的浏览器支持新版ES语法</code></pre><h4 id="修改webpack-config-js配置文件"><a href="#修改webpack-config-js配置文件" class="headerlink" title="修改webpack.config.js配置文件"></a>修改webpack.config.js配置文件</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">...</span>module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            test<span class="token punctuation">:</span> <span class="token regex">/\.ts$/</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                    loader<span class="token punctuation">:</span> <span class="token string">"babel-loader"</span><span class="token punctuation">,</span>                    options<span class="token punctuation">:</span><span class="token punctuation">{</span>                        presets<span class="token punctuation">:</span> <span class="token punctuation">[</span>                            <span class="token punctuation">[</span>                                <span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span>                                <span class="token punctuation">{</span>                                    <span class="token string">"targets"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                                        <span class="token string">"chrome"</span><span class="token punctuation">:</span> <span class="token string">"58"</span><span class="token punctuation">,</span>                                        <span class="token string">"ie"</span><span class="token punctuation">:</span> <span class="token string">"11"</span>                                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                                    <span class="token string">"corejs"</span><span class="token punctuation">:</span><span class="token string">"3"</span><span class="token punctuation">,</span>                                    <span class="token string">"useBuiltIns"</span><span class="token punctuation">:</span> <span class="token string">"usage"</span>                                <span class="token punctuation">}</span>                            <span class="token punctuation">]</span>                        <span class="token punctuation">]</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>                    loader<span class="token punctuation">:</span> <span class="token string">"ts-loader"</span><span class="token punctuation">,</span>                <span class="token punctuation">}</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">...</span></code></pre><p>如此一来，使用ts编译后的文件将会再次被babel处理；</p><p>使得代码可以在大部分浏览器中直接使用；</p><p>同时可以在配置选项的targets中指定要兼容的浏览器版本；</p><h1 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h1><p>函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> myAdd2<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">}</span><span class="token keyword">let</span> myAdd <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 能自动推断myAdd类型</span>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">}</span></code></pre><p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。</p><h2 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h2><p>TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数类型和个数必须与函数期望的一致。</p><p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 <code>undefined</code>。 在TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能。 比如，我们想让 <code>lastName</code> 是可选的：</p><p>在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 <code>undefined</code> 时。 它们叫做有默认初始化值的参数。比如，把<code>firstName</code> 的默认值设置为 <code>"A"</code>。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span>firstName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token operator">=</span><span class="token string">'A'</span><span class="token punctuation">,</span> lastName<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> lastName  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> firstName  <span class="token punctuation">}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">buildName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。</p><p>在 TypeScript 里，你可以把所有参数收集到一个变量里：<br>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ <code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">info</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span></code></pre><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote><p>自我思考：typescript和java的重载不同。出发点不同：ts从js出发，js本身传值就是任意类型的，ts重载就是为了限制函数传值类型的范围，而java传值有类型，java重载是为了扩充函数传值类型的范围。</p></blockquote><p>函数重载: 函数名相同, 而形参不同的多个函数</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">/* 需求: 我们有一个add函数，它可以接收2个string类型的参数进行拼接，也可以接收2个number类型的参数进行相加 */</span><span class="token comment" spellcheck="true">// 重载函数声明</span><span class="token keyword">function</span> add <span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token keyword">function</span> add <span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token comment" spellcheck="true">// 定义函数实现</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">|</span> <span class="token keyword">number</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">|</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">|</span> <span class="token keyword">number</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 x + y</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> y <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> y <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y  <span class="token punctuation">}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// console.log(add(1, 'a')) // error</span></code></pre><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> 类名 <span class="token punctuation">{</span>    属性名<span class="token punctuation">:</span> 类型<span class="token punctuation">;</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>参数<span class="token punctuation">:</span> 类型<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//    可以使用`constructor`定义一个构造器方法；</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>属性名 <span class="token operator">=</span> 参数<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">方法名</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token operator">...</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'孙悟空'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>  <strong>注1：TS中只能有一个构造器方法！</strong></p></blockquote><p><strong>属性可位于花括号内</strong></p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>    age<span class="token punctuation">:</span> <span class="token keyword">number</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>也可以直接将属性定义在构造函数中：</strong></p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">public</span> age<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面两种定义方法是完全相同的！</p><blockquote></blockquote><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> num<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>num<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>num<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//    如果在X类中不调用super将会报错！</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="属性修饰"><a href="#属性修饰" class="headerlink" title="属性修饰"></a>属性修饰</h3><p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p><ul><li>public(默认值)： 公开的外部也可以访问</li></ul><ul><li><p>protected ：类内部和子类可以访问</p></li><li><p>private ：只能类内部可以访问</p></li></ul><ul><li><p>静态属性（static）：声明为static的属性或方法不再属于实例，而是属于类的属性；</p></li><li><p>可选属性（?）：</p><ul><li>是可以对可能存在的属性进行预定义</li><li>是可以捕获引用了不存在的属性时的错误。</li></ul></li><li><p>只读属性（readonly）：</p><ul><li><p>将属性设置为只读的， 只读属性必须在<strong>默认声明</strong>时或<strong>构造函数</strong>里被初始化。</p></li><li><p>readonly与const：作为变量使用的话用 <code>const</code>，若作为属性则使用 <code>readonly</code></p></li></ul></li></ul><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>TypeScript 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p><p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>      <span class="token keyword">private</span> _name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>      <span class="token keyword">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                      <span class="token comment" spellcheck="true">// 取</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//    存</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> name<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'孙悟空'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际通过调用getter方法读取name属性</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 实际通过调用setter方法修改name属性 p1.name = '猪八戒'; </span></code></pre><h3 id="修饰参数属性（语法糖）"><a href="#修饰参数属性（语法糖）" class="headerlink" title="修饰参数属性（语法糖）"></a>修饰参数属性（语法糖）</h3><p>参数属性可以方便地让我们在constructor的参数列表里定义并初始化属性</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Person2</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> readonly name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//不再需要声明name属性并赋值，自动对应赋值</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person2</span><span class="token punctuation">(</span><span class="token string">'jack'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span></code></pre><p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用<code>public</code>、<code>protected</code>、<code>private</code>、<code>readonly</code>都会在类中添加一个属性，但不包括<code>static</code></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承时面向对象中的又一个特性方法</p><p>通过继承可以将其他类中的属性和方法引入到当前类中，通过<code>super</code>访问父类的属性</p><p>经典示例：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span>  <span class="token keyword">constructor</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token punctuation">}</span>  run <span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> run </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>distance<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">m`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Snake</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 必须调用父类型构造方法</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 重写父类型的方法</span>  run <span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sliding...'</span><span class="token punctuation">)</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>distance<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Horse</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用父类型构造方法</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 重写父类型的方法</span>  run <span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'dashing...'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 子类中可以使用super来完成对父类的引用</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>distance<span class="token punctuation">)</span>      <span class="token punctuation">}</span>  xxx <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'xxx()'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> snake <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Snake</span><span class="token punctuation">(</span><span class="token string">'sn'</span><span class="token punctuation">)</span>snake<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> horse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Horse</span><span class="token punctuation">(</span><span class="token string">'ho'</span><span class="token punctuation">)</span>horse<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 父类型引用指向子类型的实例 ==> 多态</span><span class="token keyword">const</span> tom<span class="token punctuation">:</span> Animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Horse</span><span class="token punctuation">(</span><span class="token string">'ho22'</span><span class="token punctuation">)</span>tom<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/* 如果子类型没有扩展的方法, 可以让子类型引用指向父类型的实例 */</span><span class="token keyword">const</span> tom3<span class="token punctuation">:</span> Snake <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">'tom3'</span><span class="token punctuation">)</span>tom3<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/* 如果子类型有扩展的方法, 不能让子类型引用指向父类型的实例 */</span><span class="token comment" spellcheck="true">// const tom2: Horse = new Animal('tom2')</span><span class="token comment" spellcheck="true">// tom2.run()</span></code></pre><p><strong>注2：子类继承父类时，必须调用父类的构造方法(super)！</strong></p><p>通过继承可以在不修改类的情况下完成对类的扩展</p><p> <em>子类</em>  -&gt;派生类</p><p><em>超类</em>  -&gt; 基类</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类（abstract class）是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</p><pre class=" language-typescript"><code class="language-typescript">abstract <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>   abstract <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>    <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'动物在叫~'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animals</span><span class="token punctuation">{</span>   <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'狗在跑~'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，</p></li><li><p>继承抽象类时抽象方法必须要实现;</p></li><li><p>不能创建实例对象, 只有实现类才能创建实例</p></li></ul><h1 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h1><ul><li>接口的作用类似于抽象类，不同点在于：接口中的所有方法和属性都是没有实值的，都是抽象属性方法；而接口可以有实值</li><li>接口是类的结构规范：对象只有<strong>包含</strong>(&gt;=)接口中定义的所有属性和方法时才能匹配接口；</li><li>可以让一个类去实现接口，实现接口时类中要实现接口中的所有属性方法；</li><li>类似类型别名（type），但类型别名不能重复命名，接口可以</li><li>一个类可以实现多个接口，用逗号隔开</li><li>接口可以继承（extends）接口</li></ul><p>用处：</p><ul><li>作为类类型检查对象类型：</li></ul><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">void</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>per<span class="token punctuation">:</span> Person<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// here</span>    per<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'孙悟空'</span><span class="token punctuation">,</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Hello, 我是 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>作为类类型表示需实现的规范：</li></ul><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>   name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>   <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">void</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>   <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">}</span>   <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'大家好，我是'</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>作为函数类型</li></ul><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 接口可以描述函数类型(参数的类型与返回的类型)</span><span class="token keyword">interface</span> <span class="token class-name">SearchFunc</span> <span class="token punctuation">{</span>  <span class="token punctuation">(</span>source<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> subString<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">boolean</span><span class="token punctuation">}</span></code></pre><p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> mySearch<span class="token punctuation">:</span> SearchFunc <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>source<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> sub<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> source<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">mySearch</span><span class="token punctuation">(</span><span class="token string">'abcd'</span><span class="token punctuation">,</span> <span class="token string">'bc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h1 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h1><blockquote><p>泛型就是类型变量</p></blockquote><p>使用情景：无法确定函数和类中要使用的具体类型（返回值、参数、属性的类型不能确定）；</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><h4 id="创建泛型函数"><a href="#创建泛型函数" class="headerlink" title="创建泛型函数"></a>创建泛型函数</h4><p>可以同时指定多个泛型，泛型间使用<strong>逗号</strong>隔开：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> test<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>E<span class="token operator">></span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span> T<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// &lt;T>就是泛型，表示某个类型；</span>    <span class="token keyword">return</span> arg<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="使用泛型函数"><a href="#使用泛型函数" class="headerlink" title="使用泛型函数"></a>使用泛型函数</h4><h5 id="方式一（直接使用，自动推断）："><a href="#方式一（直接使用，自动推断）：" class="headerlink" title="方式一（直接使用，自动推断）："></a>方式一（直接使用，自动推断）：</h5><p>使用时可以直接传递参数使用，<strong>类型会由TS自动推断出来</strong>，但有时编译器无法自动推断时还需要使用下面的方式</p><pre class=" language-typescript"><code class="language-typescript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span></code></pre><h5 id="方式二（指定类型）："><a href="#方式二（指定类型）：" class="headerlink" title="方式二（指定类型）："></a>方式二（指定类型）：</h5><p>也可以在函数后手动指定泛型；</p><pre class=" language-typescript"><code class="language-typescript">test<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span></code></pre><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类中同样可以使用泛型：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>  prop<span class="token punctuation">:</span> T<span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>prop<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>prop <span class="token operator">=</span> prop<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>在定义接口时, 为接口中的属性或方法定义泛型类型<br>在使用接口时, 再指定具体的泛型类型</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">IbaseCRUD</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span>  add<span class="token punctuation">:</span> <span class="token punctuation">(</span>t<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">void</span>  getById<span class="token punctuation">:</span> <span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> T<span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>  id<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//id主键自增</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//姓名</span>  age<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//年龄</span>  <span class="token keyword">constructor</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">UserCRUD</span> <span class="token keyword">implements</span> <span class="token class-name">IbaseCRUD</span> <span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> User<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">add</span><span class="token punctuation">(</span>user<span class="token punctuation">:</span> User<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>user<span class="token punctuation">,</span> id<span class="token punctuation">:</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'保存user'</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span>id<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> User <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item<span class="token punctuation">.</span>id<span class="token operator">===</span>id<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> userCRUD <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserCRUD</span><span class="token punctuation">(</span><span class="token punctuation">)</span>userCRUD<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">'tom'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span>userCRUD<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">'tom2'</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userCRUD<span class="token punctuation">.</span>data<span class="token punctuation">)</span></code></pre><h3 id="泛型继承-约束"><a href="#泛型继承-约束" class="headerlink" title="泛型继承(约束)"></a>泛型继承(约束)</h3><p>除此之外，也可以对泛型的范围进行约束</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">MyInter</span><span class="token punctuation">{</span>  length<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> test<span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">MyInter</span><span class="token operator">></span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> arg<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用；</p><h1 id="10-其它"><a href="#10-其它" class="headerlink" title="10. 其它"></a>10. 其它</h1><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能</p><p>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 <code>&lt;script&gt;</code> 标签引入 <code>jQuery</code>，然后就可以使用全局变量 <code>$</code> 或 <code>jQuery</code> 了。</p><p>但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西</p><pre class=" language-typescript"><code class="language-typescript"><span class="token function">jQuery</span><span class="token punctuation">(</span><span class="token string">'#foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ERROR: Cannot find name 'jQuery'.</span></code></pre><p>如果需要ts对新的语法进行检查, 需要要加载了对应的类型说明代码</p><p>可以自己写声明语句：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">var</span> jQuery<span class="token punctuation">:</span> <span class="token punctuation">(</span>selector<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">any</span><span class="token punctuation">;</span><span class="token function">jQuery</span><span class="token punctuation">(</span><span class="token string">'#foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token function">jQuery</span><span class="token punctuation">(</span><span class="token string">'#foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但通常是下载声明文件到node_modules的@types中，很多的第三方库都定义了对应的声明文件库, 库文件名一般为 <code>@types/xxx</code>，有的第三库在下载时就会自动下载对应的声明文件库(比如: webpack),有的可能需要单独下载(比如jQuery/react)</p><pre><code>npm install @types/jquery --save-dev</code></pre><p>声明文件: 把声明语句放到一个单独的xxx.d.ts文件（jQuery.d.ts）中,将声明语句定义其中,  TS编译器会扫描并加载项目中所有的TS声明文件</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。</p><p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p><ol><li>ECMAScript 的内置对象</li></ol><blockquote><p>Boolean<br>Number<br>String<br>Date<br>RegExp<br>Error</p></blockquote><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">/* 1. ECMAScript 的内置对象 */</span><span class="token keyword">let</span> b<span class="token punctuation">:</span> Boolean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">let</span> n<span class="token punctuation">:</span> Number <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token keyword">let</span> s<span class="token punctuation">:</span> String <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token keyword">let</span> d<span class="token punctuation">:</span> Date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> r<span class="token punctuation">:</span> RegExp <span class="token operator">=</span> <span class="token regex">/^1/</span><span class="token keyword">let</span> e<span class="token punctuation">:</span> Error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error message'</span><span class="token punctuation">)</span>b <span class="token operator">=</span> <span class="token keyword">true</span><span class="token comment" spellcheck="true">// let bb: boolean = new Boolean(2)  // error</span></code></pre><ol><li>BOM 和 DOM 的内置对象</li></ol><blockquote><p>Window<br>Document<br>HTMLElement<br>DocumentFragment<br>Event<br>NodeList</p></blockquote><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> div<span class="token punctuation">:</span> HTMLElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token keyword">const</span> divs<span class="token punctuation">:</span> NodeList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">:</span> MouseEvent<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">const</span> fragment<span class="token punctuation">:</span> DocumentFragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> 类型检查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 学习笔记</title>
      <link href="/9-nginx-xue-xi-bi-ji.html"/>
      <url>/9-nginx-xue-xi-bi-ji.html</url>
      
        <content type="html"><![CDATA[<h4 id="Nginx-学习笔记"><a href="#Nginx-学习笔记" class="headerlink" title="Nginx 学习笔记"></a><strong>Nginx 学习笔记</strong></h4><p>总结<br>1 、 Nginx 简介<br>（ 1 ） 什么是Nginx 和可以做什么事情<br>（ 2 ） 正向代理<br>（ 3 ） 反向代理<br>（ 4 ） 动静分离</p><p>2 、 在Linux中安装nginx</p><p>3 、 Nginx的常用命令和配置文件</p><p>4 、 Nginx配置实例 1 反向代理</p><p>5 、 Nginx配置实例 2 负载均衡</p><p>6 、 Nginx配置实例 3 动静分离</p><p>7 、 Nginx的高可用集群<br>（ 1 ） nginx配置主从模式<br>（ 2 ） nginx配置双主模式</p><h1 id="Nginx-的简介"><a href="#Nginx-的简介" class="headerlink" title="Nginx 的简介"></a>Nginx 的简介</h1><h5 id="1-、什么是nginx"><a href="#1-、什么是nginx" class="headerlink" title="1 、什么是nginx"></a>1 、什么是nginx</h5><p>Nginx是高性能的HTTP和反向代理的服务器，处理高并发能力是十分强大的，能经受高负<br>载的考验,有报告表明能支持高达 50,000个并发连接数。</p><h5 id="2-、正向代理"><a href="#2-、正向代理" class="headerlink" title="2 、正向代理"></a>2 、正向代理</h5><p>（ 1 ）需要在客户端配置代理服务器进行指定网站访问，隐藏了客户端的IP地址</p><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109110252280.png" alt="image-20210109110252280"></p><h5 id="3-、反向代理"><a href="#3-、反向代理" class="headerlink" title="3 、反向代理"></a>3 、反向代理</h5><p>服务器配置代理服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109110233040.png" alt="image-20210109110233040"></p><h5 id="4-、负载均衡"><a href="#4-、负载均衡" class="headerlink" title="4 、负载均衡"></a>4 、负载均衡</h5><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡</p><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109111630765.png" alt="image-20210109111630765"></p><h5 id="5-、动静分离"><a href="#5-、动静分离" class="headerlink" title="5 、动静分离"></a>5 、动静分离</h5><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速<br>度。降低原来单个服务器的压力。</p><blockquote><p>不需要跟数据库交互获取的资源都是静态资源</p></blockquote><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109113424433.png" alt="image-20210109113424433"></p><h1 id="Nginx-的安装"><a href="#Nginx-的安装" class="headerlink" title="Nginx 的安装"></a>Nginx 的安装</h1><h5 id="1-、准备工作"><a href="#1-、准备工作" class="headerlink" title="1 、准备工作"></a>1 、准备工作</h5><p>（ 1 ）打开虚拟机，使用远程连接工具连接linux操作系统<br>（ 2 ）到nginx官网下载软件：<a href="http://nginx.org/">http://nginx.org/</a></p><h5 id="2-、开始进行nginx安装"><a href="#2-、开始进行nginx安装" class="headerlink" title="2 、开始进行nginx安装"></a>2 、开始进行nginx安装</h5><blockquote><p>本来可以用 apt-get 的一起装的，但是想熟悉一下wget</p></blockquote><p>（ 1 ）安装pcre依赖</p><ol><li><p>联网下载pcre压缩文件依赖</p><pre><code>wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</code></pre></li><li><p>解压压缩文件</p><pre><code>tar –zxvf pcre-8.37.tar.gz</code></pre></li><li><p>执行<code>./configure</code></p></li><li><p>回到pcre目录下执行<code>make</code>，最后执行<code>make install</code></p></li><li><p>查看版本：</p><pre><code>pcre-config --version</code></pre></li></ol><p>（ 2 ）安装openssl 、zlib 、 gcc 依赖</p><pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</code></pre><p>（ 3 ）安装nginx</p><ol><li>使用命令解压</li><li>./configure</li><li>make &amp;&amp; make install</li></ol><p>进入目录 /usr/local/nginx/sbin/nginx 启动服务</p><blockquote><p>在windows系统中访问linux中nginx，默认不能访问的，因为防火墙问题<br>（ 1 ）关闭防火墙<br>（ 2 ）开放访问的端口号， 80 端口</p></blockquote><p>查看开放的端口号</p><pre><code>firewall-cmd --list-all</code></pre><p>设置开放的端口号</p><pre><code>firewall-cmd --add-service=http – permanentfirewall-cmd --add-port=80/tcp --permanent</code></pre><p>重启防火墙</p><pre><code>firewall-cmd **–** reload</code></pre><h1 id="Nginx-的常用的命令"><a href="#Nginx-的常用的命令" class="headerlink" title="Nginx 的常用的命令"></a>Nginx 的常用的命令</h1><p>进入nginx目录中<br>cd /usr/local/nginx/sbin</p><p>1 、查看nginx版本号</p><pre><code>./nginx -v或者nginx -v</code></pre><p>2 、启动nginx</p><pre><code>./nginxservice nginx start</code></pre><p>3 、停止nginx</p><pre><code>./nginx -s stop</code></pre><p>4 、重新加载nginx</p><pre><code>./nginx -s reload</code></pre><h1 id="Nginx-的配置文件"><a href="#Nginx-的配置文件" class="headerlink" title="Nginx 的配置文件"></a>Nginx 的配置文件</h1><h5 id="1-、nginx配置文件位置"><a href="#1-、nginx配置文件位置" class="headerlink" title="1 、nginx配置文件位置"></a>1 、nginx配置文件位置</h5><pre><code>cd /usr/local/nginx/conf/nginx.conf使用apt-get安装时，配置文件在 /etc/nginx 中</code></pre><h5 id="2-、配置文件中的内容"><a href="#2-、配置文件中的内容" class="headerlink" title="2 、配置文件中的内容"></a>2 、配置文件中的内容</h5><p>（ 1 ）全局块：配置服务器整体运行的配置指令</p><p>​            比如<code>worker_processes 1</code>：处理并发数的配置</p><p>（ 2 ）events块：影响 Nginx 服务器与用户的网络连接</p><p>​            比如<code>worker_connections 1024</code>： 支持的最大连接数为 1024</p><p>（ 3 ）http块<br>还包含两部分：<br>http全局块<br>server块</p><h1 id="Nginx-配置实例-反向代理实例-1"><a href="#Nginx-配置实例-反向代理实例-1" class="headerlink" title="Nginx 配置实例-反向代理实例 1"></a>Nginx 配置实例-反向代理实例 1</h1><h5 id="1-、实现效果"><a href="#1-、实现效果" class="headerlink" title="1 、实现效果"></a>1 、实现效果</h5><p>（ 1 ）打开浏览器，在浏览器地址栏输入地址 <strong><em><a href="http://www.123.com/">http://www.123.com</a></em></strong> ，跳转到liunx系统tomcat主页面中</p><h5 id="2-、准备工作"><a href="#2-、准备工作" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）在liunx系统安装tomcat，使用默认端口 8080</p><ul><li>tomcat安装文件放到liunx系统中，解压</li><li>进入tomcat的bin目录中，./startup.sh启动tomcat服务器</li></ul><h3 id="（-2-）对外开放访问的端口"><a href="#（-2-）对外开放访问的端口" class="headerlink" title="（ 2 ）对外开放访问的端口"></a>（ 2 ）对外开放访问的端口</h3><pre><code>firewall-cmd --add-port=80 80 /tcp --permanentfirewall-cmd **–** reload</code></pre><h3 id="查看已经开放的端口号"><a href="#查看已经开放的端口号" class="headerlink" title="查看已经开放的端口号"></a>查看已经开放的端口号</h3><pre><code>firewall-cmd --list-all</code></pre><p>（ 3 ）在windows系统中通过浏览器访问tomcat服务器</p><h5 id="3-、访问过程的分析"><a href="#3-、访问过程的分析" class="headerlink" title="3 、访问过程的分析"></a>3 、访问过程的分析</h5><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109115049027.png" alt="image-20210109115049027"></p><h5 id="4-、具体配置"><a href="#4-、具体配置" class="headerlink" title="4 、具体配置"></a>4 、具体配置</h5><p>第一步 在windows系统的host文件进行域名和ip对应关系的配置</p><p>（ 1 ）添加内容在host文件中</p><p>第二步 在nginx进行请求转发的配置（反向代理配置）</p><h5 id="5-、最终测试"><a href="#5-、最终测试" class="headerlink" title="5 、最终测试"></a>5 、最终测试</h5><h1 id="Nginx-配置实例-反向代理实例-2"><a href="#Nginx-配置实例-反向代理实例-2" class="headerlink" title="Nginx 配置实例-反向代理实例 2"></a>Nginx 配置实例-反向代理实例 2</h1><h5 id="1-、实现效果-1"><a href="#1-、实现效果-1" class="headerlink" title="1 、实现效果"></a>1 、实现效果</h5><p>使用nginx反向代理，根据访问的路径跳转到不同端口的服务中<br>nginx监听端口为 9001 ，</p><p>访问 <a href="http://192.168.17.129:9001/edu/">http://192.168.17.129:9001/edu/</a> 直接跳转到127.0.0.1:808 0<br>访问 <a href="http://">http://</a> 192.168.17.129:9001/vod/ 直接跳转到127.0.0.1:808 1</p><h5 id="2-、准备工作-1"><a href="#2-、准备工作-1" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）准备两个tomcat服务器，一个 8080 端口，一个 8081 端口<br>（ 2 ）创建文件夹和测试页面</p><h5 id="3-、具体配置"><a href="#3-、具体配置" class="headerlink" title="3 、具体配置"></a>3 、具体配置</h5><p>（ 1 ）找到nginx配置文件，进行反向代理配置</p><p>（ 2 ）开放对外访问的端口号 9001 8080 8081</p><h5 id="4-、最终测试"><a href="#4-、最终测试" class="headerlink" title="4 、最终测试"></a>4 、最终测试</h5><h1 id="Nginx-配置实例-负载均衡"><a href="#Nginx-配置实例-负载均衡" class="headerlink" title="Nginx 配置实例-负载均衡"></a>Nginx 配置实例-负载均衡</h1><h5 id="1-、实现效果-2"><a href="#1-、实现效果-2" class="headerlink" title="1 、实现效果"></a>1 、实现效果</h5><p>（ 1 ）浏览器地址栏输入地址 <a href="http://192.168.17.129/edu/a.html%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%88%E6%9E%9C%EF%BC%8C%E5%B9%B3%E5%9D%87">http://192.168.17.129/edu/a.html，负载均衡效果，平均</a> 8080<br>和 8081 端口中</p><h5 id="2-、准备工作-2"><a href="#2-、准备工作-2" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）准备两台tomcat服务器，一台 8080 ，一台 8081<br>（ 2 ）在两台tomcat里面webapps目录中，创建名称是edu文件夹，在edu文件夹中创建<br>页面a.html，用于测试</p><h5 id="3-、在nginx的配置文件中进行负载均衡的配置"><a href="#3-、在nginx的配置文件中进行负载均衡的配置" class="headerlink" title="3 、在nginx的配置文件中进行负载均衡的配置"></a>3 、在nginx的配置文件中进行负载均衡的配置</h5><h5 id="4-、nginx分配服务器策略"><a href="#4-、nginx分配服务器策略" class="headerlink" title="4 、nginx分配服务器策略"></a>4 、nginx分配服务器策略</h5><p>第一种 轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>第二种weight<br>weight代表权重默认为1,权重越高被分配的客户端越多</p><p>第三种ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器</p><p>第四种fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><h1 id="Nginx-配置实例-动静分离"><a href="#Nginx-配置实例-动静分离" class="headerlink" title="Nginx 配置实例-动静分离"></a>Nginx 配置实例-动静分离</h1><h5 id="1-、什么是动静分离"><a href="#1-、什么是动静分离" class="headerlink" title="1 、什么是动静分离"></a>1 、什么是动静分离</h5><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109115255261.png" alt="image-20210109115255261"></p><p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏<br>览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源<br>设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，<br>所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，<br>不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一<br>个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304 ，<br>如果有修改，则直接从服务器重新下载，返回状态码 200 。</p><h5 id="2-、准备工作-3"><a href="#2-、准备工作-3" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）在liunx系统中准备静态资源，用于进行访问</p><h5 id="3-、具体配置-1"><a href="#3-、具体配置-1" class="headerlink" title="3 、具体配置"></a>3 、具体配置</h5><p>（ 1 ）在nginx配置文件中进行配置</p><h5 id="4-、最终测试-1"><a href="#4-、最终测试-1" class="headerlink" title="4 、最终测试"></a>4 、最终测试</h5><p>（ 1 ）浏览器中输入地址：<a href="http://192.168.17.129/image/01.jpg">http://192.168.17.129/image/01.jpg</a></p><ul><li>因为配置文件 autoindex on</li></ul><p>（ 2 ）在浏览器地址栏输入地址：<a href="http://192.168.17.129/www/a.html">http://192.168.17.129/www/a.html</a></p><h1 id="Nginx-配置高可用的集群"><a href="#Nginx-配置高可用的集群" class="headerlink" title="Nginx 配置高可用的集群"></a>Nginx 配置高可用的集群</h1><h5 id="1-、什么是nginx高可用"><a href="#1-、什么是nginx高可用" class="headerlink" title="1 、什么是nginx高可用"></a>1 、什么是nginx高可用</h5><p><img src="/archives/9-nginx-xue-xi-bi-ji.htm/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109115401695.png" alt="image-20210109115401695"></p><p>（ 1 ）需要两台nginx服务器<br>（ 2 ）需要keepalived<br>（ 3 ）需要虚拟ip</p><h5 id="2-、配置高可用的准备工作"><a href="#2-、配置高可用的准备工作" class="headerlink" title="2 、配置高可用的准备工作"></a>2 、配置高可用的准备工作</h5><h3 id="（-1-）需要两台服务器-192-168-17-129-和-192-168-17"><a href="#（-1-）需要两台服务器-192-168-17-129-和-192-168-17" class="headerlink" title="（ 1 ）需要两台服务器 192.168.17.129 和 192.168.17."></a>（ 1 ）需要两台服务器 192.168.17.129 和 192.168.17.</h3><p>（ 2 ）在两台服务器安装nginx<br>（ 3 ）在两台服务器安装keepalived</p><h5 id="3-、在两台服务器安装keepalived"><a href="#3-、在两台服务器安装keepalived" class="headerlink" title="3 、在两台服务器安装keepalived"></a>3 、在两台服务器安装keepalived</h5><p>（ 1 ）使用yum命令进行安装<br>yum install keepalived <strong>–</strong> y</p><p>（ 2 ）安装之后，在etc里面生成目录keepalived，有文件keepalived.conf</p><h5 id="4-、完成高可用配置（主从配置）"><a href="#4-、完成高可用配置（主从配置）" class="headerlink" title="4 、完成高可用配置（主从配置）"></a>4 、完成高可用配置（主从配置）</h5><p>（ 1 ）修改/etc/keepalived/keepalivec.conf配置文件</p><pre><code>global_defs {notification_email {acassen@firewall.locfailover@firewall.locsysadmin@firewall.loc}notification_email_from Alexandre.Cassen@firewall.locsmtp_server 192.168.17.smtp_connect_timeout 30router_id LVS_DEVEL}vrrp_script chk_http_port {script "/usr/local/src/nginx_check.sh"interval 2 #（检测脚本执行的间隔）weight 2}vrrp_instance VI_1 {state BACKUP # 备份服务器上将 MASTER 改为 BACKUPinterface ens33 //网卡virtual_router_id 51 # 主、备机的virtual_router_id必须相同priority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小advert_int 1authentication {auth_type PASSauth_pass 1111}virtual_ipaddress {192.168.17.50 // VRRP H虚拟地址}}</code></pre><p>（ 2 ）在/usr/local/src添加检测脚本</p><pre><code>#!/bin/bashA=`ps -C nginx –no-header |wc -l`if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx sleep 2 if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then killall keepalived fifi</code></pre><p>（ 3 ）把两台服务器上nginx和keepalived启动<br>启动nginx：./nginx<br>启动keepalived：systemctl start keepalived.service</p><h5 id="5-、最终测试-1"><a href="#5-、最终测试-1" class="headerlink" title="5 、最终测试"></a>5 、最终测试</h5><p>（ 1 ）在浏览器地址栏输入 虚拟ip地址 192.168.17.</p><p>（ 2 ）把主服务器（192.168.17.129）nginx和keepalived停止，再输入192.168.17.</p><h2 id="Nginx的原理"><a href="#Nginx的原理" class="headerlink" title="Nginx的原理"></a>Nginx的原理</h2><p>1 、mater和worker</p><p>2 、worker如何进行工作的</p><p>3 、一个master和多个woker有好处<br>（ 1 ）可以使用nginx <strong>–</strong> s reload 热部署，利用nginx进行热部署操作<br>（ 2 ）每个woker是独立的进程，如果有其中的一个woker出现问题，其他woker独立的，<br>继续进行争抢，实现请求过程，不会造成服务中断</p><p>4 、设置多少个woker合适</p><p>worker数和服务器的cpu数相等是最为适宜的</p><p>5 、连接数worker_connection<br>第一个：发送请求，占用了woker的几个连接数？<br>答案： 2 或者 4 个</p><p>第二个：nginx有一个master，有四个woker，每个woker支持最大的连接数 1024 ，支持的<br>最大并发数是多少？</p><ul><li>普通的静态访问最大并发数是： worker_connections * worker_processes /2</li><li>而如果是HTTP作 为反向代理来说，最大并发数量应该是worker_connections *<br>worker_processes/4。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jest笔记</title>
      <link href="/8-jest-xue-xi-bi-ji.html"/>
      <url>/8-jest-xue-xi-bi-ji.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、jest介绍"><a href="#1、jest介绍" class="headerlink" title="1、jest介绍"></a>1、jest介绍</h1><p>主流前端测试框架：Jasmine，MOCHA，jest</p><h4 id="jest优点："><a href="#jest优点：" class="headerlink" title="jest优点："></a>jest优点：</h4><ul><li>新技术</li><li>性能好、功能多、简单易用</li><li>能差异化测试，只测试变化的模块</li><li>快出覆盖率</li><li>多项目并行</li></ul><h4 id="单元测试和集成测试的区别"><a href="#单元测试和集成测试的区别" class="headerlink" title="单元测试和集成测试的区别"></a>单元测试和集成测试的区别</h4><ul><li><strong>单元测试unit testing</strong>：指对软件中的最小可测试单元进行检查和验证。<strong>前端所说的单元测试就是对一个模块进行测试</strong></li><li><strong>集成测试</strong>：也叫组装测试或者联合测试。在单元测试的基础上，将所有模块按照涉及要求组装成为子系统或系统，进行集成测试。</li></ul><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><ol><li><code>npm i jest</code></li><li>修改package.json 的<code>script</code>的<code>test</code>为<code>jest</code>, 或者<code>jest --watchAll</code>(自动监测变化并测试，但有时测试结果是错误的:&lt;)</li><li><code>npm test</code></li></ol><h1 id="2、jest配置"><a href="#2、jest配置" class="headerlink" title="2、jest配置"></a>2、jest配置</h1><blockquote><p>只对<code>&lt;name&gt;.test.js</code>的文件进行测试</p></blockquote><h4 id="生成配置文件jest-config-js："><a href="#生成配置文件jest-config-js：" class="headerlink" title="生成配置文件jest.config.js："></a>生成配置文件jest.config.js：</h4><pre><code>npx jest --init</code></pre><h4 id="生成覆盖率报告："><a href="#生成覆盖率报告：" class="headerlink" title="生成覆盖率报告："></a>生成覆盖率报告：</h4><pre><code>npx jest --coverage</code></pre><blockquote><p>覆盖率报告文件夹的名字可通过 jest.config.js的<code>coverageDirectroy</code>指定</p></blockquote><h4 id="使jest支持es6的import语法：利用babel将es6转为commonjs语法"><a href="#使jest支持es6的import语法：利用babel将es6转为commonjs语法" class="headerlink" title="使jest支持es6的import语法：利用babel将es6转为commonjs语法"></a>使jest支持es6的import语法：利用babel将es6转为commonjs语法</h4><p>​    配置：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"presets"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>      <span class="token property">"targets"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"node"</span><span class="token operator">:</span> <span class="token string">"current"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h1 id="3、匹配器"><a href="#3、匹配器" class="headerlink" title="3、匹配器"></a>3、匹配器</h1><p>官网匹配器地址：<a href="https://jestjs.io/docs/en/expect">https://jestjs.io/docs/en/expect</a></p><ol><li><p>toBe(): 相当于 <code>===</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'toBe'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 就是 ===</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">expect</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>toEqual()： 外形是否一样</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'toEqual'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 外形</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">expect</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>toBeNull()：是null</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeNull', () => {  let a = null  expect(a).toBeNull()})</code></pre></li><li><p>toBeUndefined / toBeDefined：是否定义</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeUndefined', () => {  let a   expect(a).toBeUndefined()})</code></pre></li><li><p>toBeTruthy / toBeFalsy：转换为布尔值后为true还是false</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'toBeTruthy'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">expect</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBeTruthy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>toBeGreaterThan / toBeLessThan / toBeGreaterThanOrEqual / toBeLessThanOrEqual：数值比较</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeGreaterThan', () => {   // 大于  let a = 10  expect(a).toBeGreaterThan(4)})</code></pre></li><li><p>toBeCloseTo ：解决浮点数计算不精确的问题</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeCloseTo', () => {       // 解决浮点数计算不精确的问题  expect(0.1 + 0.2).toBeCloseTo(0.3)})</code></pre></li><li><p>toMatch：字符串内是否包含</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toMatch', () => {         // 字符串内是否包含  const arr = 'li, liu, wang'  expect(arr).toMatch('wang')})</code></pre></li><li><p>toContain：数组、set内是否包含</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toContain', () => {       // 数组、set内是否包含  const arr=['谢大脚','刘英','小红']  const data = new Set(arr)  expect(data).toContain('谢大脚')})</code></pre></li><li><p>toThrow：程序内是否抛出异常</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toThrow', () => {       // 程序内是否抛出异常  function throwError() {    // throw new Error('this is an error')  }  expect(throwError).not.toThrow('this is an error')    //使用 .not取反  // expect(outError).toThrow('this is an error')})</code></pre></li></ol><h1 id="4、异步代码测试"><a href="#4、异步代码测试" class="headerlink" title="4、异步代码测试"></a>4、异步代码测试</h1><blockquote><p>未明白原理，需要补充！！！！！！</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'异步代码测试'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//使用`done`表征异步完成</span>  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">expect</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>使用async/await实现：</p><pre><code></code></pre><h1 id="5、钩子函数"><a href="#5、钩子函数" class="headerlink" title="5、钩子函数"></a>5、钩子函数</h1><blockquote><p>钩子函数只作用于当前的文件</p></blockquote><ul><li><p>beforeAll(callback)：在所有测试用例之前进行执行</p></li><li><p>afterAll(callback)：完成所有测试用例之后才执行的函数</p></li><li><p>beforeEach(callback)：每个测试用例前都会执行一次的钩子函数</p></li><li><p>afterEach(callback)：每次测试用例完成测试之后执行一次的钩子函数</p><pre class=" language-JavaScript"><code class="language-JavaScript">// 举例afterEach(()=>{        console.log('afterEach')})</code></pre></li></ul><h1 id="6、测试作用域"><a href="#6、测试作用域" class="headerlink" title="6、测试作用域"></a>6、测试作用域</h1><p><code>describe(测试用例)</code>：创建作用域</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> jest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babel学习笔记</title>
      <link href="/7-babel-xue-xi-bi-ji.html"/>
      <url>/7-babel-xue-xi-bi-ji.html</url>
      
        <content type="html"><![CDATA[<p>学习地址：<a href="https://www.jiangruitao.com/babel/">姜瑞涛的官方网站</a></p><blockquote><p>babel是一个工具集，主要用于将ES6的js代码转为ES5等向后兼容的js代码</p></blockquote><h2 id="一、必要部分："><a href="#一、必要部分：" class="headerlink" title="一、必要部分："></a>一、必要部分：</h2><ol><li>babel配置文件：babelrc、babel.js、babel.config.js或package.json</li><li>相关的npm依赖</li><li>需要转码的js文件</li></ol><h2 id="二、作用："><a href="#二、作用：" class="headerlink" title="二、作用："></a>二、作用：</h2><ol><li>语法转换</li><li>补齐api     =&gt; polyfill (babel默认只转换JavaScript语法，不转换api)</li></ol><h2 id="三、版本"><a href="#三、版本" class="headerlink" title="三、版本"></a>三、版本</h2><blockquote><p>Babel是一个工具集，而这个工具集是围绕@babel/core这个核心npm包构成的。每次@babel/core发布新版本的时候，整个工具集的其它npm包也都会跟着升级到与@babel/core相同的版本号，即使它们的代码可能一行都没有改变</p></blockquote><ul><li><p>v7：<code>@babel/core</code></p></li><li><p>v6：<code>babel-core</code></p></li></ul><h2 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h2><blockquote><p>建议使用babel.config.js文件，可以进行逻辑处理</p></blockquote><ol><li><p>预设数组<code>presets</code>：就是一组Babel插件的集合</p><ol><li><strong>@babel/preset-env</strong>：TC39每年发布的进入标准的ES语法的转换器预设集合</li><li>@babel/preset-flow</li><li>@babel/preset-react</li><li>@babel/preset-typescript</li></ol></li><li><p>插件数组<code>plugins</code>：@babel/plugin-transform-runtime常用</p></li><li><p>其他<code>minified</code>、<code>ignore</code>等</p><blockquote><p><strong>plugin与preset的短名称：</strong></p><p>​    如果插件的npm包名称的前缀为 babel-plugin-，可以省略前缀。</p><p>​    如果npm包名称的前缀带有npm作用域@，例如@org/babel-plugin-xxx,短名称可以写成@org/xxx，但babel官方并没有给出明确的说明，所以还是推荐用全称。</p></blockquote></li></ol><p><strong>执行顺序：</strong></p><ul><li>插件比预设先执行</li><li>插件执行顺序是插件数组从前向后执行</li><li>预设执行顺序是预设数组从后向前执行</li></ul><h2 id="五、常用包及配置："><a href="#五、常用包及配置：" class="headerlink" title="五、常用包及配置："></a>五、常用包及配置：</h2><blockquote><p>默认为 v7</p></blockquote><ol><li>@babel/cli：Babel命令行转码工具，如果我们<strong>使用命令行</strong>进行Babel转码就需要安装它。</li></ol><ol start="2"><li>@babel/core：Babel的核心npm包。</li></ol><ol start="3"><li><p><strong>@babel/preset-env</strong>(常用)：提供了ES6转换ES5的语法转换规则</p><p>配置：</p><pre class=" language-json"><code class="language-json">presets<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"@babel/env"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    targets<span class="token operator">:</span> <span class="token punctuation">{</span>        //转码的最低环境        <span class="token property">"chrome"</span><span class="token operator">:</span> <span class="token string">"58"</span><span class="token punctuation">,</span>        <span class="token property">"ie"</span><span class="token operator">:</span> <span class="token string">"11"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    useBuiltIns<span class="token operator">:</span> <span class="token string">"usage"</span><span class="token punctuation">,</span>    //见下    corejs<span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>    //取值为<span class="token number">2</span>或<span class="token number">3</span>，指定core-js的使用版本    modules<span class="token operator">:</span><span class="token string">"false"</span><span class="token punctuation">,</span>     //见下<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre><ul><li><p><code>useBuiltIns</code>：</p><p>取值：    </p><ul><li><code>usage</code>：自动引入需要用到的polyfill</li><li><code>entry</code>：需要自行引入polyfill，且不会根据我们实际用到的API进行针对性引入polyfill</li><li><code>false</code></li></ul><blockquote><p>使用<code>entry</code>这种方式的时候，只能<code>import polyfill</code>一次，一般都是在入口文件。如果进行多次import，会发生错误。</p></blockquote></li><li><p><code>modules</code>：取值可以是<code>amd</code>、<code>umd</code> 、 <code>systemjs</code> 、 <code>commonjs</code> 、<code>cjs</code> 、<code>auto</code> 、<code>false</code>使用的模块语法</p><blockquote><p>在该参数项值是<code>auto</code>或不设置的时候，会发现我们转码前的代码里import都被转码成require了。</p><p>如果我们将参数项改成<code>false</code>，那么就不会对ES6模块化进行更改，还是使用import引入模块。</p></blockquote></li></ul></li></ol><ol start="4"><li><p><strong>@babel/polyfill</strong>： 垫片，从babel7.4开始，官方不推荐再使用了，因为@babel/polyfill本身其实就是两个npm包的集合：<strong>core-js与regenerator-runtime</strong>。</p><p>官方推荐直接使用这两个npm包。虽然@babel/polyfill还在进行版本升级，但其使用的core-js包为2.x.x版本，而core-js这个包本身已经发布到了3.x.x版本了，@babel/polyfill以后也不会使用3.x.x版本的包了。新版本的core-js实现了许多新的功能，例如数组的includes方法。</p><p>​        <strong>转码环境判断</strong>：如果我们的@babel/preset-env不设置任何参数，Babel就会完全根据package.json的<code>browserslist</code>的配置来做语法转换。如果没有browserslist，那么Babel就会把所有ES6的语法转换成ES5版本。</p><blockquote><p>注意：Babel使用browserslist的配置功能依赖于@babel/preset-env，如果Babel没有配置任何预设或插件，那么Babel对转换的代码会不做任何处理</p></blockquote></li></ol><ol start="5"><li><p><strong>@babel/runtime、<del>runtime-corejs2、</del>runtime-corejs3</strong>：原始的preset-env会在所有文件中重复注入辅助函数实现语法转换，将所有辅助函数移入runtime文件中再import入对应文件就不会增大项目体积了</p><p><a href="https://www.jiangruitao.com/babel/transform-runtime/">示例查看</a></p></li></ol><ol start="6"><li><p><strong>@babel/plugin-transform-runtime</strong>: @babel-runtime不能实现自动引入对应的辅助函数，借助此插件实现</p><pre class=" language-json"><code class="language-json">// 配置的默认值<span class="token punctuation">{</span>     <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span>        <span class="token string">"@babel/plugin-transform-runtime"</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            <span class="token property">"helpers"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    // 是否引入辅助包            <span class="token property">"corejs"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    //为<span class="token boolean">false</span>、<span class="token number">2</span>、<span class="token number">3</span>，一般开发JS库的时候才设置为<span class="token number">2</span>或<span class="token number">3</span>              <span class="token property">"regenerator"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    //转换async，await              <span class="token property">"useESModules"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>//是否使用es6的模块语法              <span class="token property">"absoluteRuntime"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    //用来自定义@babel/plugin-transform-runtime引入@babel/runtime/模块的路径规则              <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"7.0.0-beta.0"</span>    //该项主要是和@babel/runtime及其进化版@babel/runtime-corejs2、@babel/runtime-corejs3的版本号有关，这三个包我们只需要根据需要安装一个。我们把安装的npm包的版本号设置给version即可。例如，在上节的babel14例子里，安装的@babel/runtime-corejs3版本是^<span class="token number">7.10</span>.<span class="token number">4</span>，那么配置项version也取’^<span class="token number">7.10</span>.<span class="token number">4</span>’。//其实该项不填取默认值就行，目前填写版本号主要是可以减少打包体积。            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>​    作用：</p><ul><li>自动移除语法转换后内联的辅助函数，通过引入@babel/runtime/helpers里的辅助函数来替代；</li><li>当代码里使用了core-js的API，自动引入@babel/runtime-corejs3/core-js-stable/，以此来替代全局引入的core-js/stable</li><li>当代码里使用了Generator/async函数，自动引入@babel/runtime/regenerator以此来替代全局引入的regenerator-runtime/runtime；</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> babel </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在create-react-app创建的项目中对antd的样式按需引入</title>
      <link href="/6-zai-create-react-app-chuang-jian-de-xiang-mu-zhong-dui-antd-de-yang-shi-an-xu-yin-ru.html"/>
      <url>/6-zai-create-react-app-chuang-jian-de-xiang-mu-zhong-dui-antd-de-yang-shi-an-xu-yin-ru.html</url>
      
        <content type="html"><![CDATA[<h1 id="在create-react-app创建的项目中对antd的样式按需引入"><a href="#在create-react-app创建的项目中对antd的样式按需引入" class="headerlink" title="在create-react-app创建的项目中对antd的样式按需引入"></a>在create-react-app创建的项目中对antd的样式按需引入</h1><ol><li><p>下载 customize-cra,  react-app-rewired,  babel-plugin-import</p><blockquote><p><code>yarn add customize-cra react-app-rewired babel-plugin-import --dev</code></p></blockquote><p>​            customize-cra文档：<a href="https://github.com/arackaf/customize-cra">https://github.com/arackaf/customize-cra</a></p><p>​            react-app-rewired文档：<a href="https://github.com/timarney/react-app-rewired">https://github.com/timarney/react-app-rewired</a></p><p>​            babel-plugin-import文档：<a href="https://github.com/ant-design/babel-plugin-import">https://github.com/ant-design/babel-plugin-import</a></p></li></ol><ol start="2"><li><p>在package.json的同级创建config-overrides.js文件</p></li><li><p>config-overrides.js文件配置</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">{</span> override<span class="token punctuation">,</span> fixBabelImports <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'customize-cra'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">override</span><span class="token punctuation">(</span>    <span class="token function">fixBabelImports</span><span class="token punctuation">(</span><span class="token string">'import'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>           libraryName<span class="token punctuation">:</span> <span class="token string">'antd'</span><span class="token punctuation">,</span>        libraryDirectory<span class="token punctuation">:</span> <span class="token string">'lib'</span><span class="token punctuation">,</span>        style<span class="token punctuation">:</span> <span class="token string">"css"</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//如果是less文件则改为true</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>fixBabelImports配置：<a href="https://github.com/arackaf/customize-cra/blob/master/api.md#fixbabelimportslibraryname-options">https://github.com/arackaf/customize-cra/blob/master/api.md#fixbabelimportslibraryname-options</a></p></li></ol><p>   import部分配置找babel-plugin-import：<a href="https://github.com/ant-design/babel-plugin-import#usage">https://github.com/ant-design/babel-plugin-import#usage</a></p><ol start="4"><li><p>修改package.json的<code>script</code>选项</p><p>​    安装react-app-rewired后的：<a href="https://github.com/timarney/react-app-rewired#3-flip-the-existing-calls-to-react-scripts-in-npm-scripts-for-start-build-and-test">https://github.com/timarney/react-app-rewired#3-flip-the-existing-calls-to-react-scripts-in-npm-scripts-for-start-build-and-test</a></p><pre><code>  /* package.json */  "scripts": {-   "start": "react-scripts start",+   "start": "react-app-rewired start",-   "build": "react-scripts build",+   "build": "react-app-rewired build",-   "test": "react-scripts test",+   "test": "react-app-rewired test",    "eject": "react-scripts eject"}</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> antd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js设计模式</title>
      <link href="/5-js-she-ji-mo-shi.html"/>
      <url>/5-js-she-ji-mo-shi.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、设计模式"><a href="#一、设计模式" class="headerlink" title="一、设计模式"></a>一、设计模式</h2><blockquote><p><font color="brown"><strong>重中之重！！！：找出变化的地方，使变化的地方与不变的地方分离</strong></font></p></blockquote><h3 id="1-单例模式-singleton"><a href="#1-单例模式-singleton" class="headerlink" title="1. 单例模式 singleton"></a><strong>1. 单例模式 singleton</strong></h3><ol><li><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p></li><li><p>实现：用变量标志当前的是否已经为该类创造过实例对象，如果创造过则直接返回该实例，否则创造一个实例返回</p><pre class=" language-JavaScript"><code class="language-JavaScript">    let getSingle = (function() {        let instance;        return function (fn, ...rest) {     //fn: 用于创建单例的类            return instance || instance = fn.apply(this, rest);        }    })()</code></pre></li><li><p>惰性单例：在需要时才创建实例对象</p></li></ol><h3 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2.代理模式"></a><strong>2.代理模式</strong></h3><blockquote><p>当客户不方便直接访问一个对象，或者不满足需要的时候，提供一个替身对象让客户访问，替身对请求进行一些处理后再把请求转交给本体对象</p></blockquote><img src="/archives/5-js-she-ji-mo-shi.htm/images\5.代理模式.png" alt="5.代理模式" style="zoom: 25%;width:50px"><p><strong>注意</strong>：<strong>代理对象和本体对象的接口应一致</strong>，让客户使用代理对象，这个方便本体和代理使用的替换</p><ul><li><p>保护代理：用于过滤一些请求的代理</p></li><li><p>虚拟代理：选择在合适的时机处理请求的代理</p></li><li><p>缓存代理：使用代理暂时缓存远算结果，下次运算先在缓存容器里读取，没有再计算</p></li><li><p>其他代理：防火墙代理，远程代理，保护代理，智能引用代理，写时复制代理</p></li></ul><h3 id="3-发布订阅模式-PubSub"><a href="#3-发布订阅模式-PubSub" class="headerlink" title="3.发布订阅模式(PubSub)"></a><strong>3.发布订阅模式(PubSub)</strong></h3><ol><li><p>定义：又叫观察者模式，定义对象间的一种一对多的依赖关系，当对象改变时，所有依赖它的对象都会得到通知</p></li><li><p>实现：</p><ul><li>首先指定好谁充当发布者</li><li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者</li><li>发布消息时，发布者遍历这个列表，依次触发存放的订阅者的回调函数</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//订阅的通用实现</span><span class="token keyword">var</span> event <span class="token operator">=</span> <span class="token punctuation">{</span>         clientList<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 缓存列表</span>        listen<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span> key<span class="token punctuation">,</span> fn <span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//订阅函数， key用来判断发布者发布的事件是否是订阅者所希望收到订阅的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> fn <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 订阅的消息添加进缓存列表</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            trigger<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 发布函数</span>                <span class="token keyword">var</span> key <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">,</span>                 fns <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>fns <span class="token operator">||</span> fns<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没有绑定对应的消息</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> fn <span class="token operator">=</span> fns<span class="token punctuation">[</span> i<span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                    fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// arguments 是trigger 时带上的参数</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> installEvent <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token keyword">in</span> event <span class="token punctuation">)</span><span class="token punctuation">{</span>                obj<span class="token punctuation">[</span> i <span class="token punctuation">]</span> <span class="token operator">=</span> event<span class="token punctuation">[</span> i <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//个人认为应还应判断是否有重名方法</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取消订阅的通用实现</span>event<span class="token punctuation">.</span>remove <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> fns <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fns<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果key 对应的消息没有被人订阅，则直接返回</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果没有传入具体的回调函数，表示需要取消key 对应消息的所有订阅</span>      fns<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> l <span class="token operator">=</span> fns<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> l <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> l<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 反向遍历订阅的回调函数列表, 需要取消订阅的一般靠后，从后面开始遍历性能更好</span>            <span class="token keyword">var</span> _fn <span class="token operator">=</span> fns<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>_fn <span class="token operator">===</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>                fns<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除订阅者的回调函数</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ol><blockquote><p>缺点：</p><ul><li>创建订阅者本身要消耗一定的时间和内存，特别是订阅的消息一直未触发发布时，但这个订阅者会始终存在于内存中</li><li>发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解</li></ul></blockquote><blockquote><p>GitHub库：<a href="https://github.com/mroderick/PubSubJS">https://github.com/mroderick/PubSubJS</a></p></blockquote><h3 id="4-策略模式strategy"><a href="#4-策略模式strategy" class="headerlink" title="4. 策略模式strategy"></a>4. 策略模式strategy</h3><blockquote><p>个人理解： 将一个对象(事物, 情景)的不同情况都封装为方法，再在不同情况下去调用对应的方法</p></blockquote><ol><li>定义：将不同情况的解决办法定义为函数，并用对象封装起来，不同情况调用不同函数</li><li>目的：使算法的<strong>使用</strong>和<strong>实现</strong>分离，内部实现其功能，用户只用关心使用</li><li>组成：<ul><li>策略类strategy： 封装了解决不同情况的对个算法(函数), 负责计算具体过程</li><li>环境类context：接收用户的请求，并将请求委托(分发)给对应的策略，因此需要维持对策略类的引用</li></ul></li><li>典例：表单验证</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http:// xxx.com/register<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>registerForm<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            请输入用户名:&lt;input type="text" name="userName"/ > 请输入密码:&lt;input            type="text" name="password"/ > 请输入手机号码:&lt;input type="text"            name="phoneNumber"/ >            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>提交<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token comment" spellcheck="true">/***********************策略对象**************************/</span>            <span class="token keyword">var</span> strategies <span class="token operator">=</span> <span class="token punctuation">{</span>                isNonEmpty<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 传入表单值</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                minLength<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> length<span class="token punctuation">,</span> errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                isMobile<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex">/(^1[3|5|8][0-9]{9}$)/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***********************Validator 类**************************/</span>            <span class="token keyword">var</span> Validator <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 将需检查的规则全部缓存，不用考虑顺序</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 添加需检查的规则列表</span>            Validator<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>dom<span class="token punctuation">,</span> rules<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rule<span class="token punctuation">;</span> <span class="token punctuation">(</span>rule <span class="token operator">=</span> rules<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>rule<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 为什么需要闭包？</span>                        <span class="token keyword">var</span> strategyAry <span class="token operator">=</span> rule<span class="token punctuation">.</span>strategy<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> rule<span class="token punctuation">.</span>errorMsg<span class="token punctuation">;</span>                        self<span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//缓存规则检查前的信息加工函数</span>                            <span class="token keyword">var</span> strategy <span class="token operator">=</span> strategyAry<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            strategyAry<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>dom<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                            strategyAry<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">return</span> strategies<span class="token punctuation">[</span>strategy<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>dom<span class="token punctuation">,</span> strategyAry<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 依次调用cache的函数进行检查</span>            Validator<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> validatorFunc<span class="token punctuation">;</span><span class="token punctuation">(</span>validatorFunc <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> <span class="token function">validatorFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***********************客户调用代码**************************/</span>            <span class="token keyword">var</span> registerForm <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"registerForm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> validataFunc <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> validator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Validator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 添加检查需检查的表单项</span>                validator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registerForm<span class="token punctuation">.</span>userName<span class="token punctuation">,</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span> strategy<span class="token punctuation">:</span> <span class="token string">"isNonEmpty"</span><span class="token punctuation">,</span> errorMsg<span class="token punctuation">:</span> <span class="token string">"用户名不能为空"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token punctuation">{</span>                        strategy<span class="token punctuation">:</span> <span class="token string">"minLength:6"</span><span class="token punctuation">,</span>                        errorMsg<span class="token punctuation">:</span> <span class="token string">"用户名长度不能小于 10 位"</span><span class="token punctuation">,</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                validator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registerForm<span class="token punctuation">.</span>password<span class="token punctuation">,</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span>                        strategy<span class="token punctuation">:</span> <span class="token string">"minLength:6"</span><span class="token punctuation">,</span>                        errorMsg<span class="token punctuation">:</span> <span class="token string">"密码长度不能小于 6 位"</span><span class="token punctuation">,</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                validator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registerForm<span class="token punctuation">.</span>phoneNumber<span class="token punctuation">,</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span> strategy<span class="token punctuation">:</span> <span class="token string">"isMobile"</span><span class="token punctuation">,</span> errorMsg<span class="token punctuation">:</span> <span class="token string">"手机号码格式不正确"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> validator<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//绑定表单验证的事件</span>            registerForm<span class="token punctuation">.</span>onsubmit <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> <span class="token function">validataFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">alert</span><span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="5-迭代器模式"><a href="#5-迭代器模式" class="headerlink" title="5.迭代器模式"></a>5.迭代器模式</h3><blockquote><p>与策略模式的对比：策略模式的各种策略是自己已知的，而迭代器模式所需要元素是未知的，通过迭代后才能确定</p></blockquote><p>定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露对象的内部表示</p><p>分类：</p><ul><li>内部迭代器：规则隐藏在内部，外部不可见，缺点就是迭代规则不可控，交互只在第一次初始调用，</li><li>外部迭代器：迭代规则可手工控制，使迭代器更灵活，但调用也跟复杂了</li><li>倒序迭代器：从后面往前遍历的迭代器</li></ul><h3 id="6-命令模式"><a href="#6-命令模式" class="headerlink" title="6.命令模式"></a>6.命令模式</h3><blockquote><p>个人理解： 将执行的方法与执行的本体对象分离</p></blockquote><p>没有接收者的智能命令，和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们意图的不同。</p><p>策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标 的不同手段，它们的内部实现是针对“算法”而言的。</p><p>而智能命令模式指向的问题域更广，command 对象解决的目标更具发散性</p><h3 id="7-组合模式"><a href="#7-组合模式" class="headerlink" title="7.组合模式"></a>7.组合模式</h3><p>定义：用小的子对象来构建更大的对象，而这些子对象本身也有更小的孙对象构成</p><p>优点：</p><ul><li>用树形结构表示“部分-整体”的层次结构</li><li>通过对象的多态性，使用户对单个对象和组合对象的使用具有一致性(既方法名一样)</li></ul><p>注意：</p><ul><li>组合模式不是父子关系，只是组合对象把请求委托给叶子对象(类似职责链模式)</li><li>组合对象和叶子对象，叶子对象之间都必须是相同的接口，</li><li>组合对象和子对象为双向映射，一对一的关系，不能给同一个叶子对象两次请求委托</li></ul><p>缺点：</p><ul><li>系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解</li><li>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起</li></ul><h3 id="8-模板方法模式"><a href="#8-模板方法模式" class="headerlink" title="8.模板方法模式"></a>8.模板方法模式</h3><blockquote><p>个人理解：不变的封装到父类，可变的封装到子类</p></blockquote><p>在 JavaScript 中, 我们很多时候都不需要依样画瓢地去实现一个模版方法模式，<strong>高阶函数是更好的选择</strong></p><h3 id="9-享元模式"><a href="#9-享元模式" class="headerlink" title="9.享元模式"></a>9.享元模式</h3><blockquote><p>个人理解：一段逻辑本来需要许多重复或相似的对象，但只使用一个对象(带有内部状态)当做模板，每次使用时再包装(传入外部状态)成所需要的对象来达到效果</p></blockquote><p>关键是<strong>如何划分内部状态和外部状态</strong>：</p><ul><li>内部状态存储于对象内部</li><li>内部状态可以被一些对象共享</li><li>内部状态独立于具体的场景，通常不会改变</li><li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li></ul><p>例子：文件上传</p><pre class=" language-JavaScript"><code class="language-JavaScript">    Upload.prototype.delFile = function( id ){ // 文件删除函数        uploadManager.setExternalState( id, this );         if ( this.fileSize < 3000 ){            return this.dom.parentNode.removeChild( this.dom );        }        if ( window.confirm( '确定要删除该文件吗? ' + this.fileName ) ){            return this.dom.parentNode.removeChild( this.dom );        }    }    //实例化上传对象    var UploadFactory = (function(){        var createdFlyWeightObjs = {};        return {            create: function( uploadType){                 if ( createdFlyWeightObjs [ uploadType] ){  // 单例模式                    return createdFlyWeightObjs [ uploadType];                }                return createdFlyWeightObjs [ uploadType] = new Upload( uploadType);            }        }    })();    // 用统一的管理器封装外部状态    var uploadManager = (function(){        var uploadDatabase = {};        return {            add: function( id, uploadType, fileName, fileSize ){                var flyWeightObj = UploadFactory.create( uploadType );                var dom = document.createElement( 'div' );                dom.innerHTML =                '<span>文件名称:'+ fileName +', 文件大小: '+ fileSize +'</span>' +                '<button class="delFile">删除</button>';                dom.querySelector( '.delFile' ).onclick = function(){                    flyWeightObj.delFile( id );                }                document.body.appendChild( dom );                uploadDatabase[ id ] = {                    fileName: fileName,                    fileSize: fileSize,                    dom: dom                };                return flyWeightObj ;            },            setExternalState: function( id, flyWeightObj ){                var uploadData = uploadDatabase[ id ];                  for ( var i in uploadData ){        // 包装(传入外部状态)成所需要的对象                    flyWeightObj[ i ] = uploadData[ i ];                }            }        }    })();    // 触发开始上传的函数    var id = 0;    window.startUpload = function( uploadType, files ){        for ( var i = 0, file; file = files[ i++ ]; ){            var uploadObj = uploadManager.add( ++id, uploadType, file.fileName, file.fileSize );        }    };</code></pre><p>使用场景：</p><ul><li><p>一个程序中使用了大量的相似对象</p></li><li><p>由于使用了大量对象，造成很大的内存开销</p></li><li><p>对象的大多数状态都可以变为外部状态</p></li><li><p>剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象</p></li></ul><h3 id="10-职责链模式"><a href="#10-职责链模式" class="headerlink" title="10.职责链模式"></a>10.职责链模式</h3><p>定义：将多个对象连成一条链，若处理不了就将请求向下传递，直到有一个对象能处理，它避免请求对象与多个处理对象之间耦合的局面</p><p>优点：</p><ul><li>解耦了请求发送者和 N 个接收者之间的复杂关系，由于不知道链中的哪个节点可以处理你发出的请求，所以你只需把请求传递给第一个节点即可</li><li>链中的节点对象可以灵活地拆分重组</li><li>可以手动指定起始节点</li></ul><p>缺点</p><ul><li>需要在最后添加错误处理节点，以防没有成功处理请求的节点</li><li>可能存在多余的节点并未使用</li></ul><h3 id="11-中介者模式"><a href="#11-中介者模式" class="headerlink" title="11.中介者模式"></a>11.中介者模式</h3><blockquote><p>个人理解：让多个对象之间的相互联系变成多个对象只与中介者联系，由中介者统一进行管理，如vuex</p></blockquote><img src="/archives/5-js-she-ji-mo-shi.htm/hengBlog\source\images\5.中介者模式.png" style="zoom: 33%;"><p>优点：</p><ul><li>解耦对象之间的紧密关系</li><li>使对象间多对多的关系变成一对多关系</li></ul><h3 id="12-装饰者模式"><a href="#12-装饰者模式" class="headerlink" title="12.装饰者模式"></a>12.装饰者模式</h3><blockquote><p>可以配合AOP实现多个函数方法的整体化，又类似适配器模式，可以在外层包装一层函数进行装饰。值得注意的是，它并不会更改原对象</p></blockquote><p>定义： 给对象动态的增加职责(方法)</p><p>例子：AOP装饰函数</p><pre class=" language-javascript"><code class="language-javascript">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> beforefn <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> __self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 保存原函数的引用</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 返回包含了原函数和新函数的"代理"函数</span>        beforefn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 执行新函数，可在此处修改参数arguments</span>        <span class="token keyword">return</span> __self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行原函数并返回原函数的执行结果，并且保证this 不被劫持</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> afterfn <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> __self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> ret <span class="token operator">=</span> __self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>        afterfn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>值得注意的是：</p><ul><li>因为函数通过 <code>Function.prototype.before</code> 或者 <code>Function.prototype.after</code> 被装 饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失</li><li>装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一些 影响</li></ul><p>代理模式和装饰者模式的区别：<strong>在于它们的意图和设计目的</strong>。</p><ul><li><p>代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。代理模式强调一种关系(Proxy 与它的实体之间的关系)，这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而且代理模式通常只有一层代理本体的引用</p></li><li><p>装饰者模式的作用就是为对象动态加入行为，用于一开始不能确定对象的全部功能时。而且装饰者模式经常会形成一条长长的装饰链</p></li></ul><h3 id="13-状态模式"><a href="#13-状态模式" class="headerlink" title="13.状态模式"></a>13.状态模式</h3><p>定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p><p>应用关键：区别事物上下文(context)内部的状态，事物<strong>内部状态的改变</strong>往往会带来事物的<strong>行为改变</strong>，把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部</p><p>优点：</p><ul><li>状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换方法</li><li>避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过多的条件分支</li><li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然</li><li>Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响</li></ul><p>缺点：</p><ul><li>会在系统中定义许多状态类，枯燥乏味，而且系统中会因此而增加不少对象</li><li>由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑</li></ul><p><strong>状态模式和策略模式的关系</strong>：</p><p>相同点：它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行</p><p>区别：策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系， 所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法;    而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。</p><h3 id="14-适配器模式"><a href="#14-适配器模式" class="headerlink" title="14.适配器模式"></a>14.适配器模式</h3><p>应用：解决两个软件实体的接口不兼容的问题</p><p>装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。</p><h2 id="二、设计原则"><a href="#二、设计原则" class="headerlink" title="二、设计原则"></a>二、设计原则</h2><h3 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1.单一职责原则(SRP)"></a>1.单一职责原则(SRP)</h3><p>定义：一个类应该仅有一个引起它变化的原因, 既一个对象或方法只做一件事情</p><p>分离原则：</p><ul><li>如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们(比如在 ajax 请求的时候，创建 xhr 对象和发送 xhr 请求几乎总是在一起的，那么创建 xhr 对象的职责和发送 xhr 请求的职责就没有必要分开。)</li><li>另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。</li></ul><h3 id="2-最少知识原则-LKP"><a href="#2-最少知识原则-LKP" class="headerlink" title="2.最少知识原则(LKP)"></a>2.最少知识原则(LKP)</h3><p>定义：一个软件实体应当尽量少的与其他实体发生作用，既减少交互，减少耦合</p><h3 id="3-开放-封闭原则-OCP"><a href="#3-开放-封闭原则-OCP" class="headerlink" title="3.开放-封闭原则(OCP)"></a>3.开放-封闭原则(OCP)</h3><p>定义：软件实体(类，模块，函数等)应该是能扩展，但是不可修改的</p><h2 id="三、代码重构建议"><a href="#三、代码重构建议" class="headerlink" title="三、代码重构建议"></a>三、代码重构建议</h2><ol><li>提炼函数，及时添加注释，不要让函数过长</li><li>合并重复的条件片段</li><li>将条件分支语句提炼成函数</li><li>合理的使用循环，递归</li><li>使用return提前让条件退出以代替嵌套的条件分支(小技巧：即在面对一个嵌套的 if 分支时，我们可以把外层 if 表达式进行反转，就能转化为多个并级的条件判断语句)</li><li>传递对象参数以代替过长的参数列表</li><li>尽量减少参数数量</li><li>尽量不要用嵌套的三目运算符，该为if</li><li>合理使用链式调用(原理：方法结束后对象返回自身)</li><li>分解大型类为多个小类</li><li>使用return退出多重循环</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grid（网格）布局</title>
      <link href="/4-grid-wang-ge-bu-ju.html"/>
      <url>/4-grid-wang-ge-bu-ju.html</url>
      
        <content type="html"><![CDATA[<h1 id="grid（网格）布局"><a href="#grid（网格）布局" class="headerlink" title="grid（网格）布局"></a>grid（网格）布局</h1><h6 id="参考链接-http-www-ruanyifeng-com-blog-2019-03-grid-layout-tutorial-html"><a href="#参考链接-http-www-ruanyifeng-com-blog-2019-03-grid-layout-tutorial-html" class="headerlink" title="参考链接 http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html"></a>参考链接 <a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></h6><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a><code>display</code></h3><p>采用网格(grid)布局<br>==注意==: 设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p><ul><li><code>grid</code>：块级容器</li><li><code>inline-grid</code>：行内容器</li></ul><h3 id="grid-auto-columns-rows"><a href="#grid-auto-columns-rows" class="headerlink" title="grid-auto-columns / rows"></a><code>grid-auto-columns / rows</code></h3><ul><li>设置自动创建的多余网格的列宽和行高</li></ul><h3 id="grid-template-rows-columns"><a href="#grid-template-rows-columns" class="headerlink" title="grid-template-rows / columns"></a><code>grid-template-rows / columns</code></h3><ul><li><p>指定行列宽度</p><ul><li><p>用像素或百分比</p><pre><code>grid-template-rows: 100px 100px 100px;grid-template-columns: 33.3% 33.3% 33.3%;</code></pre></li><li><p>repeat()</p><pre><code>  grid-template-rows: repeat（3,100px）</code></pre></li><li><p>auto-fill</p><pre><code>grid-template-columns: repeat(auto-fill, 100px);</code></pre></li><li><p>fr单位(既fraction)</p><pre><code>grid-template-columns: 1fr 1fr;</code></pre></li><li><p>minmax(min, max)</p></li></ul></li><li><p>网格线名称</p><p>注意三行应制定四行网格线</p><ul><li>[name]</li></ul></li></ul><h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a><code>grid-template-areas</code></h3><ul><li>定义区域，名字即为网格网格名</li></ul><pre><code>    grid-template-areas: 'a b c'                               'd e f'                               'g h i';</code></pre><p>  不要利用的区域用”点”(.)表示<br>  注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><h3 id="grid-row-column-gap"><a href="#grid-row-column-gap" class="headerlink" title="grid-row / column-gap"></a><code>grid-row / column-gap</code></h3><p>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p><ul><li><p>指定行列的间距</p></li><li><p>合并写法</p><ul><li><code>grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</code></li><li><code>gap: &lt;row-gap&gt; &lt;column-gap&gt;;</code></li></ul></li></ul><h3 id="grid-auto-flow-先行后列"><a href="#grid-auto-flow-先行后列" class="headerlink" title="grid-auto-flow  先行后列"></a><code>grid-auto-flow</code>  先行后列</h3><ul><li><p>row / column</p><ul><li><p>不考虑空位，保证先后顺序</p><ul><li>链接：<a href="https://jsbin.com/wapejok/edit?css,output">https://jsbin.com/wapejok/edit?css,output</a></li></ul></li></ul></li><li><p>row dense / column dense</p><ul><li><p>尽量紧密排列</p><ul><li>链接：<a href="https://jsbin.com/xutokec/edit?css,output">https://jsbin.com/xutokec/edit?css,output</a></li></ul></li></ul></li></ul><h3 id="单元格内容的位置"><a href="#单元格内容的位置" class="headerlink" title="单元格内容的位置"></a>单元格内容的位置</h3><ul><li><code>align-items</code> 垂直方向</li><li><code>justify-items</code> 水平方向</li><li>合并写法: <code>place-items: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul><h3 id="项目整体在容器内的位置"><a href="#项目整体在容器内的位置" class="headerlink" title="项目整体在容器内的位置"></a>项目整体在容器内的位置</h3><ul><li><p><code>justify-content</code> 水平方向</p></li><li><p><code>align-content</code> 垂直方向</p></li><li><p><code>place-content</code>  前两个的合并写法</p><ul><li><code>place-content: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul></li></ul><hr><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="指定项目位置"><a href="#指定项目位置" class="headerlink" title="指定项目位置"></a>指定项目位置</h3><ul><li><p><code>grid-row / column-start / end</code></p><ul><li><p>写法</p><ul><li>网格线数字</li><li>网格线名字</li><li>span：num</li><li>重叠了用<code>z-index</code></li></ul></li><li><p>简写</p><ul><li><code>grid-row / column: &lt;start-line&gt; / &lt;end-line&gt;</code></li></ul></li></ul></li></ul><h3 id="指定项目区域名"><a href="#指定项目区域名" class="headerlink" title="指定项目区域名"></a>指定项目区域名</h3><ul><li><code>grid-area: 区域名</code></li></ul><h3 id="单元格内容的位置-优先"><a href="#单元格内容的位置-优先" class="headerlink" title="单元格内容的位置(优先)"></a>单元格内容的位置(优先)</h3><ul><li><code>align-self</code> 垂直方向</li><li><code>justify-self</code> 水平方向</li><li>合并写法: <code>place-self: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul><p><img src="/../images/4.%20%20grid%EF%BC%88%E7%BD%91%E6%A0%BC%EF%BC%89%E5%B8%83%E5%B1%80.png" alt="思维导图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> grid </tag>
            
            <tag> 布局 </tag>
            
            <tag> 网格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/3-git-chang-yong-ming-ling.html"/>
      <url>/3-git-chang-yong-ming-ling.html</url>
      
        <content type="html"><![CDATA[<h5 id="集中式和分布式版本控制系统的区别"><a href="#集中式和分布式版本控制系统的区别" class="headerlink" title="集中式和分布式版本控制系统的区别"></a>集中式和分布式版本控制系统的区别</h5><blockquote><p>分布式版本控制系统：每个开发者都有整个代码库的所有版本，在离线状态下开发者可以进行版本管理开发, 等网络恢复再push到仓库中。</p></blockquote><blockquote><p>集中式版本控制系统：每个开发者只有应用代码库的一个版本，在离线状态下开发者无法进行版本管理开发。</p></blockquote><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="Git 工作区、暂存区和版本库"></p><ol><li><h6 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h6></li></ol><p><code>git init</code>:初始化仓库<br><code>git status</code> : 查看状态：红色表示在工作区，绿色表示在暂存区，其他在版本区<br><code>git add 文件名</code>  :工作区添加到暂存区，”.”号表所有<br><code>git commit -m '注释'</code> : 暂存区到版本区<br><code>git clone URL</code> : 克隆仓库<br><code>git remote add 别名 URL</code>: 本地仓库关联远程仓库,别名一般用origin<br><code>git remote remove 别名</code>: 本地仓库移除关联</p><ol start="2"><li><h6 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h6></li></ol><p><code>git checkout 分支</code> : 切换分支<br><code>git checkout -b 分支</code> : 创建并切换<br><code>git branch 分支</code> : 创建分支但不切换<br><code>git branch</code>: 查看分支列表<br><code>git checkout -d 分支</code> : 删除分支<br><code>git push origin 分支</code> : 分支推送远程<br><code>git pull origin 分支</code> : 远程拉取到本地<br><code>git fetch origin master:tmp</code>: 新建一个tmp分支，将远程仓库的master分支上代码版本复制到tmp分支上，不会自动合并<br><code>git merge 分支</code> : 指定分支合并到当前分支</p><ol start="3"><li><h6 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h6><p><code>git log</code>: 提交日志<br><code>git reflog</code>: 每次提交的ID<br><code>git reset --hard HEAD^</code>: 版本回退到一个版本，”^“回退一个版本，”^^”回退两个版本<br><code>git reset --hard ID号</code>:回退到指定版本</p></li><li><h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><p><code>git rm 文件名</code>: 删除指定文件<br><code>git rm -r 文件名</code>: 删除指定文件夹<br><code>git rm --cached 文件</code>: 从暂存区删除 </p></li><li><h6 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h6></li></ol><p><code>git diff</code> : 比较暂存区与工作区<br><code>git diff --cached</code> : 比较版本区与暂存区<br><code>git diff master</code> : 比较版本区与工作区<br><code>git diff branch1 branch2</code>:显示出两个分支之间所有有差异的文件的详细差异<br><code>git diff branch1 branch2 --stat</code>:显示出两个分支之间所有有差异的文件列表<br><code>git diff branch1 branch2 xxx</code>:显示指定文件的详细差异</p><hr><h6 id="补充基础Linux命令"><a href="#补充基础Linux命令" class="headerlink" title="补充基础Linux命令"></a>补充基础Linux命令</h6><p><code>mkdir</code> :创建文件夹<br><code>vi</code> : 创建文件并进入<br><code>i</code> :编辑模式<br><code>ESC+:+wq</code> : 保存并退出<br><code>ESC+:+q!</code> : 不保存并退出<br><code>cd</code> : 进入文件夹<br><code>ls</code> : 当前文件夹文件列表<br><code>pwd</code> : 当前目录<br><code>cat</code> 文件 : 显示文件内容<br><code>clear</code> : 清屏</p><h6 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h6><ol><li>日常开发：feature =&gt; dev =&gt; test =&gt; master</li><li>紧急修复bug：master =&gt; hotfix =&gt; test =&gt; master</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>betterScroll踩坑记录</title>
      <link href="/1-betterscroll-cai-keng-ji-lu.html"/>
      <url>/1-betterscroll-cai-keng-ji-lu.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用BetterScroll刚<code>npm run serve</code>时无法进行滑动，需要修改BetterScroll的源码，<br>   修改<code>BetterSC/shared-utils/src/dom.ts</code> 中的常量hasTouch为true,<br>   这样就可以在初始化时对参数进行设置,把一切掌握在自己手中</p><p>   使用方法如下:</p><pre><code> new BScroll时,在参数options中加入 mouseWheel: true,   //开启鼠标滚轮 disableMouse: false,   //启用鼠标拖动 disableTouch: false    //启用手指触摸</code></pre><p>   参考博客：<a href="https://www.cnblogs.com/mldonkey/p/11421577.html">https://www.cnblogs.com/mldonkey/p/11421577.html</a></p></li></ol><ol start="2"><li>使用BetterScroll后绑定scroll, click事件后无法触发，也无报错<br> BetterScroll默认拦截了click事件可在<code>new Bscroll()</code>的配置对象中传入<code> click: true</code></li><li>使用BetterScroll的<code>scroll</code>事件必须同时在<code>new Bscroll()</code>配置对象中指定<code>probeType</code> </li></ol><p><img src="/../images/1.1.jpg" alt="what"></p><p>(后面发现官网都有说明… 链接：<a href="https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F">https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F</a>)</p><p><img src="/../images/1.2.jpg" alt="what"></p><p>. 使用better-scroll时注意$nextTick的使用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> scroll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue动态路由引入和异步组件记录</title>
      <link href="/2-vue-router-dong-tai-lu-you.html"/>
      <url>/2-vue-router-dong-tai-lu-you.html</url>
      
        <content type="html"><![CDATA[<p>动态引入的路由组件在打包时路由组件会被单独打包(代码分割 code split),<br>默认不请求加载路由组件打包文件, 当请求需要路由组件时才请求加载,当引入需要的的组件时在<code>Network</code>会增加一个打包文件(一般为<code>/^\d+.js$/</code>格式)。</p><h4 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h4><ul><li><p>component是一个执行就会<code>import()</code>的函数</p><pre><code>myComponent =  () =&gt; import(path)</code></pre></li><li><p>将组件定义对象(component definition)传递给 <code>resolve</code> 回调函数</p><pre><code>Vue.component(component, (resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve({      template: YourTemplate    })  }, 100)})</code></pre></li><li><p>使用<code>require</code>引入，这个特殊的 require 语法将指示 webpack 自动将构建后的代码，拆分到不同的 bundle 中，然后通过 Ajax 请求加载。</p><pre><code>Vue.component(component, (resolve) =&gt; {  setTimeOut(() =&gt; {    require(path, resolve);  }, 100)})</code></pre></li><li><p>使用返回的<code>promise</code>resolve前<code>import</code></p><pre><code>- Vue.component(component, (resolve) =&gt; {    setTimeOut(() =&gt; {      import(path).then(resolve);    }, 100)  })- Vue.component(component, Promise.resolve(template对象))- Vue.component(component, Promise.resolveDelay(template对象, time))</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
